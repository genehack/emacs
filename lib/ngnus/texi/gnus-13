Info file: gnus,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License" in the Emacs manual.

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding
     a copy of the license to the document, as described in section 6
     of the license.



INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus: (gnus).         The newsreader Gnus.
END-INFO-DIR-ENTRY








File: gnus, Node: Category Buffer, Next: Category Variables, Prev: Category Syntax, Up: Agent Categories

Category Buffer
...............

You'd normally do all category maintenance from the category buffer.
When you enter it for the first time (with the `J c' command from the
group buffer), you'll only see the `default' category.

The following commands are available in this buffer:

`q'
     Return to the group buffer (`gnus-category-exit').

`e'
     Use a customization buffer to set all of the selected category's
     parameters at one time (`gnus-category-customize-category').

`k'
     Kill the current category (`gnus-category-kill').

`c'
     Copy the current category (`gnus-category-copy').

`a'
     Add a new category (`gnus-category-add').

`p'
     Edit the predicate of the current category
     (`gnus-category-edit-predicate').

`g'
     Edit the list of groups belonging to the current category
     (`gnus-category-edit-groups').

`s'
     Edit the download score rule of the current category
     (`gnus-category-edit-score').

`l'
     List all the categories (`gnus-category-list').




File: gnus, Node: Category Variables, Prev: Category Buffer, Up: Agent Categories

Category Variables
..................

`gnus-category-mode-hook'
     Hook run in category buffers.

`gnus-category-line-format'
     Format of the lines in the category buffer (*Note Formatting
     Variables::).  Valid elements are:

     `c'
          The name of the category.

     `g'
          The number of groups in the category.

`gnus-category-mode-line-format'
     Format of the category mode line (*Note Mode Line Formatting::).

`gnus-agent-short-article'
     Articles that have fewer lines than this are short.  Default 100.

`gnus-agent-long-article'
     Articles that have more lines than this are long.  Default 200.

`gnus-agent-low-score'
     Articles that have a score lower than this have a low score.
     Default 0.

`gnus-agent-high-score'
     Articles that have a score higher than this have a high score.
     Default 0.

`gnus-agent-expire-days'
     The number of days that a `read' article must stay in the agent's
     local disk before becoming eligible for expiration (While the
     name is the same, this doesn't mean expiring the article on the
     server.  It just means deleting the local copy of the article).
     What is also important to understand is that the counter starts
     with the time the article was written to the local disk and not
     the time the article was read.  Default 7.

`gnus-agent-enable-expiration'
     Determines whether articles in a group are, by default, expired
     or retained indefinitely.  The default is `ENABLE' which means
     that you'll have to disable expiration when desired.  On the
     other hand, you could set this to `DISABLE'.  In that case, you
     would then have to enable expiration in selected groups.





File: gnus, Node: Agent Commands, Next: Agent Visuals, Prev: Agent Categories, Up: Gnus Unplugged

Agent Commands
--------------

All the Gnus Agent commands are on the `J' submap.  The `J j'
(`gnus-agent-toggle-plugged') command works in all modes, and toggles
the plugged/unplugged state of the Gnus Agent.


* Menu:

* Group Agent Commands::        Configure groups and fetch their contents.
* Summary Agent Commands::      Manually select then fetch specific articles.
* Server Agent Commands::       Select the servers that are supported by the agent.






File: gnus, Node: Group Agent Commands, Next: Summary Agent Commands, Prev: Agent Commands, Up: Agent Commands

Group Agent Commands
....................

`J u'
     Fetch all eligible articles in the current group
     (`gnus-agent-fetch-groups').

`J c'
     Enter the Agent category buffer (`gnus-enter-category-buffer').

`J s'
     Fetch all eligible articles in all groups
     (`gnus-agent-fetch-session').

`J S'
     Send all sendable messages in the queue group
     (`gnus-group-send-queue').  *Note Drafts::.

`J a'
     Add the current group to an Agent category
     (`gnus-agent-add-group').  This command understands the
     process/prefix convention (*Note Process/Prefix::).

`J r'
     Remove the current group from its category, if any
     (`gnus-agent-remove-group').  This command understands the
     process/prefix convention (*Note Process/Prefix::).

`J Y'
     Synchronize flags changed while unplugged with remote server, if
     any.






File: gnus, Node: Summary Agent Commands, Next: Server Agent Commands, Prev: Group Agent Commands, Up: Agent Commands

Summary Agent Commands
......................

`J #'
     Mark the article for downloading (`gnus-agent-mark-article').

`J M-#'
     Remove the downloading mark from the article
     (`gnus-agent-unmark-article').

`@'
     Toggle whether to download the article
     (`gnus-agent-toggle-mark').  The download mark is `%' by default.

`J c'
     Mark all articles as read (`gnus-agent-catchup') that are neither
     cached, downloaded, nor downloadable.

`J S'
     Download all eligible (*Note Agent Categories::) articles in this
     group.  (`gnus-agent-fetch-group').

`J s'
     Download all processable articles in this group.
     (`gnus-agent-summary-fetch-series').

`J u'
     Download all downloadable articles in the current group
     (`gnus-agent-summary-fetch-group').





File: gnus, Node: Server Agent Commands, Prev: Summary Agent Commands, Up: Agent Commands

Server Agent Commands
.....................

`J a'
     Add the current server to the list of servers covered by the Gnus
     Agent (`gnus-agent-add-server').

`J r'
     Remove the current server from the list of servers covered by the
     Gnus Agent (`gnus-agent-remove-server').





File: gnus, Node: Agent Visuals, Next: Agent as Cache, Prev: Agent Commands, Up: Gnus Unplugged

Agent Visuals
-------------

If you open a summary while unplugged and, Gnus knows from the group's
active range that there are more articles than the headers currently
stored in the Agent, you may see some articles whose subject looks
something like `[Undownloaded article #####]'.  These are placeholders
for the missing headers.  Aside from setting a mark, there is not much
that can be done with one of these placeholders.  When Gnus finally
gets a chance to fetch the group's headers, the placeholders will
automatically be replaced by the actual headers.  You can configure
the summary buffer's maneuvering to skip over the placeholders if you
care (See `gnus-auto-goto-ignores').

While it may be obvious to all, the only headers and articles
available while unplugged are those headers and articles that were
fetched into the Agent while previously plugged.  To put it another
way, "If you forget to fetch something while plugged, you might have a
less than satisfying unplugged session".  For this reason, the Agent
adds two visual effects to your summary buffer.  These effects display
the download status of each article so that you always know which
articles will be available when unplugged.

The first visual effect is the `%O' spec.  If you customize
`gnus-summary-line-format' to include this specifier, you will add a
single character field that indicates an article's download status.
Articles that have been fetched into either the Agent or the Cache,
will display `gnus-downloaded-mark' (defaults to `+').  All other
articles will display `gnus-undownloaded-mark' (defaults to `-').  If
you open a group that has not been agentized, a space (` ') will be
displayed.

The second visual effect are the undownloaded faces.  The faces, there
are three indicating the article's score (low, normal, high), seem to
result in a love/hate response from many Gnus users.  The problem is
that the face selection is controlled by a list of condition tests and
face names (See `gnus-summary-highlight').  Each condition is tested
in the order in which it appears in the list so early conditions have
precedence over later conditions.  All of this means that, if you tick
an undownloaded article, the article will continue to be displayed in
the undownloaded face rather than the ticked face.

If you use the Agent as a cache (to avoid downloading the same article
each time you visit it or to minimize your connection time), the
undownloaded face will probably seem like a good idea.  The reason
being that you do all of our work (marking, reading, deleting) with
downloaded articles so the normal faces always appear.  For those
users using the agent to improve online performance by caching the NOV
database (most users since 5.10.2), the undownloaded faces may appear
to be an absolutely horrible idea.  The issue being that, since none
of their articles have been fetched into the Agent, all of the normal
faces will be obscured by the undownloaded faces.

If you would like to use the undownloaded faces, you must enable the
undownloaded faces by setting the `agent-enable-undownloaded-faces'
group parameter to `t'.  This parameter, like all other agent
parameters, may be set on an Agent Category (*Note Agent
Categories::), a Group Topic (*Note Topic Parameters::), or an
individual group (*Note Group Parameters::).

The one problem common to all users using the agent is how quickly it
can consume disk space.  If you using the agent on many groups, it is
even more difficult to effectively recover disk space.  One solution
is the `%F' format available in `gnus-group-line-format'.  This format
will display the actual disk space used by articles fetched into both
the agent and cache.  By knowing which groups use the most space,
users know where to focus their efforts when "agent expiring"
articles.



File: gnus, Node: Agent as Cache, Next: Agent Expiry, Prev: Agent Visuals, Up: Gnus Unplugged

Agent as Cache
--------------

When Gnus is plugged, it is not efficient to download headers or
articles from the server again, if they are already stored in the
Agent.  So, Gnus normally only downloads headers once, and stores them
in the Agent.  These headers are later used when generating the
summary buffer, regardless of whether you are plugged or unplugged.
Articles are not cached in the Agent by default though (that would
potentially consume lots of disk space), but if you have already
downloaded an article into the Agent, Gnus will not download the
article from the server again but use the locally stored copy instead.

If you so desire, you can configure the agent (see `gnus-agent-cache'
*Note Agent Variables::) to always download headers and articles while
plugged.  Gnus will almost certainly be slower, but it will be kept
synchronized with the server.  That last point probably won't make any
sense if you are using a nntp or nnimap back end.



File: gnus, Node: Agent Expiry, Next: Agent Regeneration, Prev: Agent as Cache, Up: Gnus Unplugged

Agent Expiry
------------


The Agent back end, `nnagent', doesn't handle expiry.  Well, at
least it doesn't handle it like other back ends.  Instead, there are
special `gnus-agent-expire' and `gnus-agent-expire-group'
commands that will expire all read articles that are older than
`gnus-agent-expire-days' days.  They can be run whenever you feel
that you're running out of space.  Neither are particularly fast or
efficient, and it's not a particularly good idea to interrupt them (with
`C-g' or anything else) once you've started one of them.

Note that other functions, e.g. `gnus-request-expire-articles', might
run `gnus-agent-expire' for you to keep the agent synchronized with
the group.

The agent parameter `agent-enable-expiration' may be used to prevent
expiration in selected groups.

If `gnus-agent-expire-all' is non-`nil', the agent expiration commands
will expire all articles--unread, read, ticked and dormant.  If `nil'
(which is the default), only read articles are eligible for expiry,
and unread, ticked and dormant articles will be kept indefinitely.

If you find that some articles eligible for expiry are never expired,
perhaps some Gnus Agent files are corrupted.  There's are special
commands, `gnus-agent-regenerate' and
`gnus-agent-regenerate-group', to fix possible problems.



File: gnus, Node: Agent Regeneration, Next: Agent and flags, Prev: Agent Expiry, Up: Gnus Unplugged

Agent Regeneration
------------------


The local data structures used by `nnagent' may become corrupted due
to certain exceptional conditions.  When this happens, `nnagent'
functionality may degrade or even fail.  The solution to this problem
is to repair the local data structures by removing all internal
inconsistencies.

For example, if your connection to your server is lost while
downloaded articles into the agent, the local data structures will not
know about articles successfully downloaded prior to the connection
failure.  Running `gnus-agent-regenerate' or
`gnus-agent-regenerate-group' will update the data structures such
that you don't need to download these articles a second time.

The command `gnus-agent-regenerate' will perform
`gnus-agent-regenerate-group' on every agentized group.  While you can
run `gnus-agent-regenerate' in any buffer, it is strongly recommended
that you first close all summary buffers.

The command `gnus-agent-regenerate-group' uses the local copies of
individual articles to repair the local NOV(header) database.  It then
updates the internal data structures that document which articles are
stored locally.  An optional argument will mark articles in the agent
as unread.



File: gnus, Node: Agent and flags, Next: Agent and IMAP, Prev: Agent Regeneration, Up: Gnus Unplugged

Agent and flags
---------------

The Agent works with any Gnus back end including those, such as
nnimap, that store flags (read, ticked, etc) on the server.  Sadly,
the Agent does not actually know which backends keep their flags in
the backend server rather than in `.newsrc'.  This means that the
Agent, while unplugged or disconnected, will always record all changes
to the flags in its own files.

When you plug back in, Gnus will then check to see if you have any
changed any flags and ask if you wish to synchronize these with the
server.  This behavior is customizable by
`gnus-agent-synchronize-flags'.

If `gnus-agent-synchronize-flags' is `nil', the Agent will never
automatically synchronize flags.  If it is `ask', which is the
default, the Agent will check if you made any changes and if so ask if
you wish to synchronize these when you re-connect.  If it has any
other value, all flags will be synchronized automatically.

If you do not wish to synchronize flags automatically when you
re-connect, you can do it manually with the
`gnus-agent-synchronize-flags' command that is bound to `J Y' in the
group buffer.

Technical note: the synchronization algorithm does not work by
pushing" all local flags to the server, but rather by incrementally
updated the server view of flags by changing only those flags that
were changed by the user.  Thus, if you set one flag on an article,
quit the group then re-select the group and remove the flag; the flag
will be set and removed from the server when you "synchronize".  The
queued flag operations can be found in the per-server `flags' file in
the Agent directory.  It's emptied when you synchronize flags.



File: gnus, Node: Agent and IMAP, Next: Outgoing Messages, Prev: Agent and flags, Up: Gnus Unplugged

Agent and IMAP
--------------

The Agent works with any Gnus back end, including nnimap.  However,
since there are some conceptual differences between NNTP and IMAP,
this section (should) provide you with some information to make Gnus
Agent work smoother as a IMAP Disconnected Mode client.

Some things are currently not implemented in the Agent that you'd
might expect from a disconnected IMAP client, including:


   * Copying/moving articles into nnimap groups when unplugged.

   * Creating/deleting nnimap groups when unplugged.




File: gnus, Node: Outgoing Messages, Next: Agent Variables, Prev: Agent and IMAP, Up: Gnus Unplugged

Outgoing Messages
-----------------

By default, when Gnus is unplugged, all outgoing messages (both mail
and news) are stored in the draft group "queue" (*Note Drafts::).  You
can view them there after posting, and edit them at will.

You can control the circumstances under which outgoing mail is queued
(see `gnus-agent-queue-mail', *Note Agent Variables::).  Outgoing news
is always queued when Gnus is unplugged, and never otherwise.

You can send the messages either from the draft group with the special
commands available there, or you can use the `J S' command in the
group buffer to send all the sendable messages in the draft group.
Posting news will only work when Gnus is plugged, but you can send
mail at any time.

If sending mail while unplugged does not work for you and you worry
about hitting `J S' by accident when unplugged, you can have Gnus
ask you to confirm your action (see
`gnus-agent-prompt-send-queue', *Note Agent Variables::).



File: gnus, Node: Agent Variables, Next: Example Setup, Prev: Outgoing Messages, Up: Gnus Unplugged

Agent Variables
---------------

`gnus-agent'
     Is the agent enabled?  The default is `t'.  When first enabled,
     the agent will use `gnus-agent-auto-agentize-methods' to
     automatically mark some back ends as agentized.  You may change
     which back ends are agentized using the agent commands in the
     server buffer.

     To enter the server buffer, use the `^'
     (`gnus-group-enter-server-mode') command in the group buffer.


`gnus-agent-directory'
     Where the Gnus Agent will store its files.  The default is
     `~/News/agent/'.

`gnus-agent-handle-level'
     Groups on levels (*Note Group Levels::) higher than this variable
     will be ignored by the Agent.  The default is
     `gnus-level-subscribed', which means that only subscribed group
     will be considered by the Agent by default.

`gnus-agent-plugged-hook'
     Hook run when connecting to the network.

`gnus-agent-unplugged-hook'
     Hook run when disconnecting from the network.

`gnus-agent-fetched-hook'
     Hook run when finished fetching articles.

`gnus-agent-cache'
     Variable to control whether use the locally stored NOV and
     articles when plugged, e.g. essentially using the Agent as a
     cache.  The default is non-`nil', which means to use the Agent as
     a cache.

`gnus-agent-go-online'
     If `gnus-agent-go-online' is `nil', the Agent will never
     automatically switch offline servers into online status.  If it
     is `ask', the default, the Agent will ask if you wish to switch
     offline servers into online status when you re-connect.  If it
     has any other value, all offline servers will be automatically
     switched into online status.

`gnus-agent-mark-unread-after-downloaded'
     If `gnus-agent-mark-unread-after-downloaded' is non-`nil', mark
     articles as unread after downloading.  This is usually a safe
     thing to do as the newly downloaded article has obviously not
     been read.  The default is `t'.

`gnus-agent-synchronize-flags'
     If `gnus-agent-synchronize-flags' is `nil', the Agent will never
     automatically synchronize flags.  If it is `ask', which is the
     default, the Agent will check if you made any changes and if so
     ask if you wish to synchronize these when you re-connect.  If it
     has any other value, all flags will be synchronized
     automatically.

`gnus-agent-consider-all-articles'
     If `gnus-agent-consider-all-articles' is non-`nil', the agent
     will let the agent predicate decide whether articles need to be
     downloaded or not, for all articles.  When `nil', the default,
     the agent will only let the predicate decide whether unread
     articles are downloaded or not.  If you enable this, you may also
     want to look into the agent expiry settings (*Note Category
     Variables::), so that the agent doesn't download articles which
     the agent will later expire, over and over again.

`gnus-agent-max-fetch-size'
     The agent fetches articles into a temporary buffer prior to
     parsing them into individual files.  To avoid exceeding the
     max. buffer size, the agent alternates between fetching and
     parsing until all articles have been fetched.
     `gnus-agent-max-fetch-size' provides a size limit to control how
     often the cycling occurs.  A large value improves performance.  A
     small value minimizes the time lost should the connection be lost
     while fetching (You may need to run `gnus-agent-regenerate-group'
     to update the group's state.  However, all articles parsed prior
     to loosing the connection will be available while unplugged).
     The default is 10M so it is unusual to see any cycling.

`gnus-server-unopen-status'
     Perhaps not an Agent variable, but closely related to the Agent,
     this variable says what will happen if Gnus cannot open a server.
     If the Agent is enabled, the default, `nil', makes Gnus ask the
     user whether to deny the server or whether to unplug the agent.
     If the Agent is disabled, Gnus always simply deny the server.
     Other choices for this variable include `denied' and `offline'
     the latter is only valid if the Agent is used.

`gnus-auto-goto-ignores'
     Another variable that isn't an Agent variable, yet so closely
     related that most will look for it here, this variable tells the
     summary buffer how to maneuver around undownloaded (only headers
     stored in the agent) and unfetched (neither article nor headers
     stored) articles.

     The valid values are `nil' (maneuver to any article),
     `undownloaded' (maneuvering while unplugged ignores articles that
     have not been fetched), `always-undownloaded' (maneuvering always
     ignores articles that have not been fetched), `unfetched'
     (maneuvering ignores articles whose headers have not been
     fetched).

`gnus-agent-queue-mail'
     When `gnus-agent-queue-mail' is `always', Gnus will always queue
     mail rather than sending it straight away.  When `t', Gnus will
     queue mail when unplugged only.  When `nil', never queue mail.
     The default is `t'.

`gnus-agent-prompt-send-queue'
     When `gnus-agent-prompt-send-queue' is non-`nil' Gnus will
     prompt you to confirm that you really wish to proceed if you hit
     `J S' while unplugged.  The default is `nil'.

`gnus-agent-auto-agentize-methods'
     If you have never used the Agent before (or more technically, if
     `~/News/agent/lib/servers' does not exist), Gnus will
     automatically agentize a few servers for you.  This variable
     control which back ends should be auto-agentized.  It is
     typically only useful to agentize remote back ends.  The
     auto-agentizing has the same effect as running `J a' on the
     servers (*Note Server Agent Commands::).  If the file exist, you
     must manage the servers manually by adding or removing them, this
     variable is only applicable the first time you start Gnus.  The
     default is `(nntp nnimap)'.





File: gnus, Node: Example Setup, Next: Batching Agents, Prev: Agent Variables, Up: Gnus Unplugged

Example Setup
-------------

If you don't want to read this manual, and you have a fairly standard
setup, you may be able to use something like the following as your
`~/.gnus.el' file to get started.

     ;; Define how Gnus is to fetch news.  We do this over NNTP
     ;; from your ISP's server.
     (setq gnus-select-method '(nntp "news.your-isp.com"))

     ;; Define how Gnus is to read your mail.  We read mail from
     ;; your ISP's POP server.
     (setq mail-sources '((pop :server "pop.your-isp.com")))

     ;; Say how Gnus is to store the mail.  We use nnml groups.
     (setq gnus-secondary-select-methods '((nnml "")))

     ;; Make Gnus into an offline newsreader.
     ;; (gnus-agentize) ; The obsolete setting.
     ;; (setq gnus-agent t) ; Now the default.

That should be it, basically.  Put that in your `~/.gnus.el' file,
edit to suit your needs, start up PPP (or whatever), and type `M-x
gnus'.

If this is the first time you've run Gnus, you will be subscribed
automatically to a few default newsgroups.  You'll probably want to
subscribe to more groups, and to do that, you have to query the NNTP
server for a complete list of groups with the `A A' command.  This
usually takes quite a while, but you only have to do it once.

After reading and parsing a while, you'll be presented with a list of
groups.  Subscribe to the ones you want to read with the `u' command.
`l' to make all the killed groups disappear after you've subscribe to
all the groups you want to read.  (`A k' will bring back all the
killed groups.)

You can now read the groups at once, or you can download the articles
with the `J s' command.  And then read the rest of this manual to find
out which of the other gazillion things you want to customize.




File: gnus, Node: Batching Agents, Next: Agent Caveats, Prev: Example Setup, Up: Gnus Unplugged

Batching Agents
---------------

Having the Gnus Agent fetch articles (and post whatever messages
you've written) is quite easy once you've gotten things set up
properly.  The following shell script will do everything that is
necessary:

You can run a complete batch command from the command line with the
following incantation:

     #!/bin/sh
     emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-agent-batch >/dev/null 2>&1




File: gnus, Node: Agent Caveats, Prev: Batching Agents, Up: Gnus Unplugged

Agent Caveats
-------------

The Gnus Agent doesn't seem to work like most other offline
newsreaders.  Here are some common questions that some imaginary
people may ask:

"If I read an article while plugged, do they get entered into the Agent?"

     *No*.  If you want this behavior, add
     `gnus-agent-fetch-selected-article' to
     `gnus-select-article-hook'.

"If I read an article while plugged, and the article already exists in"
     the Agent, will it get downloaded once more?

     *No*, unless `gnus-agent-cache' is `nil'.


In short, when Gnus is unplugged, it only looks into the locally
stored articles; when it's plugged, it talks to your ISP and may also
use the locally stored articles.




File: gnus, Node: Scoring, Next: Various, Prev: Select Methods, Up: Top

Scoring
*******

Other people use "kill files", but we here at Gnus Towers like scoring
better than killing, so we'd rather switch than fight.  They do
something completely different as well, so sit up straight and pay
attention!

All articles have a default score (`gnus-summary-default-score'),
which is 0 by default.  This score may be raised or lowered either
interactively or by score files.  Articles that have a score lower than
`gnus-summary-mark-below' are marked as read.

Gnus will read any "score files" that apply to the current group
before generating the summary buffer.

There are several commands in the summary buffer that insert score
entries based on the current article.  You can, for instance, ask Gnus
to lower or increase the score of all articles with a certain subject.

There are two sorts of scoring entries: Permanent and temporary.
Temporary score entries are self-expiring entries.  Any entries that
are temporary and have not been used for, say, a week, will be removed
silently to help keep the sizes of the score files down.

* Menu:

* Summary Score Commands::      Adding score entries for the current group.
* Group Score Commands::        General score commands.
* Score Variables::             Customize your scoring.  (My, what terminology).
* Score File Format::           What a score file may contain.
* Score File Editing::          You can edit score files by hand as well.
* Adaptive Scoring::            Big Sister Gnus knows what you read.
* Home Score File::             How to say where new score entries are to go.
* Followups To Yourself::       Having Gnus notice when people answer you.
* Scoring On Other Headers::    Scoring on non-standard headers.
* Scoring Tips::                How to score effectively.
* Reverse Scoring::             That problem child of old is not problem.
* Global Score Files::          Earth-spanning, ear-splitting score files.
* Kill Files::                  They are still here, but they can be ignored.
* Converting Kill Files::       Translating kill files to score files.
* Advanced Scoring::            Using logical expressions to build score rules.
* Score Decays::                It can be useful to let scores wither away.




File: gnus, Node: Summary Score Commands, Next: Group Score Commands, Prev: Scoring, Up: Scoring

Summary Score Commands
======================

The score commands that alter score entries do not actually modify
real score files.  That would be too inefficient.  Gnus maintains a
cache of previously loaded score files, one of which is considered the
current score file alist".  The score commands simply insert entries
into this list, and upon group exit, this list is saved.

The current score file is by default the group's local score file,
even if no such score file actually exists.  To insert score commands
into some other score file (e.g. `all.SCORE'), you must first make
this score file the current one.

General score commands that don't actually change the score file:


`V s'
     Set the score of the current article (`gnus-summary-set-score').

`V S'
     Display the score of the current article
     (`gnus-summary-current-score').

`V t'
     Display all score rules that have been used on the current
     article (`gnus-score-find-trace').  In the `*Score Trace*'
     buffer, you may type `e' to edit score file corresponding to the
     score rule on current line and `f' to format
     (`gnus-score-pretty-print') the score file and edit it.

`V w'
     List words used in scoring (`gnus-score-find-favourite-words').

`V R'
     Run the current summary through the scoring process
     (`gnus-summary-rescore').  This might be useful if you're playing
     around with your score files behind Gnus' back and want to see
     the effect you're having.

`V c'
     Make a different score file the current
     (`gnus-score-change-score-file').

`V e'
     Edit the current score file (`gnus-score-edit-current-scores').
     You will be popped into a `gnus-score-mode' buffer (*Note Score
     File Editing::).

`V f'
     Edit a score file and make this score file the current one
     (`gnus-score-edit-file').

`V F'
     Flush the score cache (`gnus-score-flush-cache').  This is useful
     after editing score files.

`V C'
     Customize a score file in a visually pleasing manner
     (`gnus-score-customize').


The rest of these commands modify the local score file.


`V m'
     Prompt for a score, and mark all articles with a score below this
     as read (`gnus-score-set-mark-below').

`V x'
     Prompt for a score, and add a score rule to the current score
     file to expunge all articles below this score
     (`gnus-score-set-expunge-below').

The keystrokes for actually making score entries follow a very regular
pattern, so there's no need to list all the commands.  (Hundreds of
them.)


  1. The first key is either `I' (upper case i) for increasing the
     score or `L' for lowering the score.
  2. The second key says what header you want to score on.  The
     following keys are available:

     `a'
          Score on the author name.

     `s'
          Score on the subject line.

     `x'
          Score on the `Xref' line--i.e., the cross-posting line.

     `r'
          Score on the `References' line.

     `d'
          Score on the date.

     `l'
          Score on the number of lines.

     `i'
          Score on the `Message-ID' header.

     `e'
          Score on an "extra" header, that is, one of those in
          gnus-extra-headers, if your NNTP server tracks additional
          header data in overviews.

     `f'
          Score on followups--this matches the author name, and adds scores to
          the followups to this author.  (Using this key leads to the creation of
          `ADAPT' files.)

     `b'
          Score on the body.

     `h'
          Score on the head.

     `t'
          Score on thread.  (Using this key leads to the creation of
          `ADAPT' files.)


  3. The third key is the match type.  Which match types are valid
     depends on what headers you are scoring on.


     `strings'


          `e'
               Exact matching.

          `s'
               Substring matching.

          `f'
               Fuzzy matching (*Note Fuzzy Matching::).

          `r'
               Regexp matching

     `date'

          `b'
               Before date.

          `a'
               After date.

          `n'
               This date.

     `number'

          `<'
               Less than number.

          `='
               Equal to number.

          `>'
               Greater than number.

  4. The fourth and usually final key says whether this is a temporary
     (i.e., expiring) score entry, or a permanent (i.e., non-expiring)
     score entry, or whether it is to be done immediately, without
     adding to the score file.

     `t'
          Temporary score entry.

     `p'
          Permanent score entry.

     `i'
          Immediately scoring.

  5. If you are scoring on `e' (extra) headers, you will then be
     prompted for the header name on which you wish to score.  This
     must be a header named in gnus-extra-headers, and `TAB'
     completion is available.


So, let's say you want to increase the score on the current author
with exact matching permanently: `I a e p'.  If you want to lower the
score based on the subject line, using substring matching, and make a
temporary score entry: `L s s t'.  Pretty easy.

To make things a bit more complicated, there are shortcuts.  If you
use a capital letter on either the second or third keys, Gnus will use
defaults for the remaining one or two keystrokes.  The defaults are
substring" and "temporary".  So `I A' is the same as `I a s t', and `I
a R' is the same as `I a r t'.

These functions take both the numerical prefix and the symbolic prefix
(*Note Symbolic Prefixes::).  A numerical prefix says how much to
lower (or increase) the score of the article.  A symbolic prefix of
`a' says to use the `all.SCORE' file for the command instead of the
current score file.

The `gnus-score-mimic-keymap' says whether these commands will pretend
they are keymaps or not.




File: gnus, Node: Group Score Commands, Next: Score Variables, Prev: Summary Score Commands, Up: Scoring

Group Score Commands
====================

There aren't many of these as yet, I'm afraid.


`W e'
     Edit the apply-to-all-groups all.SCORE file.  You will be popped
     into a `gnus-score-mode' buffer (*Note Score File Editing::).

`W f'
     Gnus maintains a cache of score alists to avoid having to reload
     them all the time.  This command will flush the cache
     (`gnus-score-flush-cache').


You can do scoring from the command line by saying something like:

     $ emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-batch-score




File: gnus, Node: Score Variables, Next: Score File Format, Prev: Group Score Commands, Up: Scoring

Score Variables
===============


`gnus-use-scoring'
     If `nil', Gnus will not check for score files, and will not, in
     general, do any score-related work.  This is `t' by default.

`gnus-kill-killed'
     If this variable is `nil', Gnus will never apply score files to
     articles that have already been through the kill process.  While
     this may save you lots of time, it also means that if you apply a
     kill file to a group, and then change the kill file and want to
     run it over you group again to kill more articles, it won't work.
     You have to set this variable to `t' to do that.  (It is `t' by
     default.)

`gnus-kill-files-directory'
     All kill and score files will be stored in this directory, which
     is initialized from the `SAVEDIR' environment variable by
     default.  This is `~/News/' by default.

`gnus-score-file-suffix'
     Suffix to add to the group name to arrive at the score file name
     (`SCORE' by default.)

`gnus-score-uncacheable-files'
     All score files are normally cached to avoid excessive re-loading
     of score files.  However, this might make your Emacs grow big and
     bloated, so this regexp can be used to weed out score files
     unlikely to be needed again.  It would be a bad idea to deny
     caching of `all.SCORE', while it might be a good idea to not
     cache `comp.infosystems.www.authoring.misc.ADAPT'.  In fact, this
     variable is `ADAPT$' by default, so no adaptive score files will
     be cached.

`gnus-save-score'
     If you have really complicated score files, and do lots of batch
     scoring, then you might set this variable to `t'.  This will make
     Gnus save the scores into the `.newsrc.eld' file.

     If you do not set this to `t', then manual scores (like those set
     with `V s' (`gnus-summary-set-score')) will not be preserved
     across group visits.

`gnus-score-interactive-default-score'
     Score used by all the interactive raise/lower commands to
     raise/lower score with.  Default is 1000, which may seem
     excessive, but this is to ensure that the adaptive scoring scheme
     gets enough room to play with.  We don't want the small changes
     from the adaptive scoring to overwrite manually entered data.

`gnus-summary-default-score'
     Default score of an article, which is 0 by default.

`gnus-summary-expunge-below'
     Don't display the summary lines of articles that have scores
     lower than this variable.  This is `nil' by default, which means
     that no articles will be hidden.  This variable is local to the
     summary buffers, and has to be set from `gnus-summary-mode-hook'.

`gnus-score-over-mark'
     Mark (in the third column) used for articles with a score over
     the default.  Default is `+'.

`gnus-score-below-mark'
     Mark (in the third column) used for articles with a score below
     the default.  Default is `-'.

`gnus-score-find-score-files-function'
     Function used to find score files for the current group.  This
     function is called with the name of the group as the argument.

     Predefined functions available are:

     `gnus-score-find-single'
          Only apply the group's own score file.

     `gnus-score-find-bnews'
          Apply all score files that match, using bnews syntax.  This
          is the default.  If the current group is `gnu.emacs.gnus',
          for instance, `all.emacs.all.SCORE', `not.alt.all.SCORE' and
          `gnu.all.SCORE' would all apply.  In short, the instances of
          `all' in the score file names are translated into `.*', and
          then a regexp match is done.

          This means that if you have some score entries that you want
          to apply to all groups, then you put those entries in the
          `all.SCORE' file.

          The score files are applied in a semi-random order, although
          Gnus will try to apply the more general score files before
          the more specific score files.  It does this by looking at
          the number of elements in the score file names--discarding
          the `all' elements.

     `gnus-score-find-hierarchical'
          Apply all score files from all the parent groups.  This
          means that you can't have score files like `all.SCORE', but
          you can have `SCORE', `comp.SCORE' and `comp.emacs.SCORE'
          for each server.

     This variable can also be a list of functions.  In that case, all
     these functions will be called with the group name as argument,
     and all the returned lists of score files will be applied.  These
     functions can also return lists of lists of score alists
     directly.  In that case, the functions that return these non-file
     score alists should probably be placed before the "real" score
     file functions, to ensure that the last score file returned is
     the local score file.  Phu.

     For example, to do hierarchical scoring but use a
     non-server-specific overall score file, you could use the value
          (list (lambda (group) ("all.SCORE"))
                'gnus-score-find-hierarchical)

`gnus-score-expiry-days'
     This variable says how many days should pass before an unused
     score file entry is expired.  If this variable is `nil', no score
     file entries are expired.  It's 7 by default.

`gnus-update-score-entry-dates'
     If this variable is non-`nil', temporary score entries that have
     been triggered (matched) will have their dates updated.  (This is
     how Gnus controls expiry--all non-matched-entries will become too
     old while matched entries will stay fresh and young.)  However,
     if you set this variable to `nil', even matched entries will grow
     old and will have to face that oh-so grim reaper.

`gnus-score-after-write-file-function'
     Function called with the name of the score file just written.

`gnus-score-thread-simplify'
     If this variable is non-`nil', article subjects will be
     simplified for subject scoring purposes in the same manner as
     with threading--according to the current value of
     `gnus-simplify-subject-functions'.  If the scoring entry uses
     `substring' or `exact' matching, the match will also be
     simplified in this manner.





File: gnus, Node: Score File Format, Next: Score File Editing, Prev: Score Variables, Up: Scoring

Score File Format
=================

A score file is an `emacs-lisp' file that normally contains just a
single form.  Casual users are not expected to edit these files;
everything can be changed from the summary buffer.

Anyway, if you'd like to dig into it yourself, here's an example:

     (("from"
       ("Lars Ingebrigtsen" -10000)
       ("Per Abrahamsen")
       ("larsi\\|lmi" -50000 nil R))
      ("subject"
       ("Ding is Badd" nil 728373))
      ("xref"
       ("alt.politics" -1000 728372 s))
      ("lines"
       (2 -100 nil <))
      (mark 0)
      (expunge -1000)
      (mark-and-expunge -10)
      (read-only nil)
      (orphan -10)
      (adapt t)
      (files "/hom/larsi/News/gnu.SCORE")
      (exclude-files "all.SCORE")
      (local (gnus-newsgroup-auto-expire t)
             (gnus-summary-make-false-root empty))
      (eval (ding)))

This example demonstrates most score file elements.  *Note Advanced
Scoring::, for a different approach.

Even though this looks much like Lisp code, nothing here is actually
`eval'ed.  The Lisp reader is used to read this form, though, so it
has to be valid syntactically, if not semantically.

Six keys are supported by this alist:


`STRING'
     If the key is a string, it is the name of the header to perform
     the match on.  Scoring can only be performed on these eight
     headers: `From', `Subject', `References', `Message-ID', `Xref',
     `Lines', `Chars' and `Date'.  In addition to these headers, there
     are three strings to tell Gnus to fetch the entire article and do
     the match on larger parts of the article: `Body' will perform the
     match on the body of the article, `Head' will perform the match
     on the head of the article, and `All' will perform the match on
     the entire article.  Note that using any of these last three keys
     will slow down group entry *considerably*.  The final "header"
     you can score on is `Followup'.  These score entries will result
     in new score entries being added for all follow-ups to articles
     that matches these score entries.

     Following this key is an arbitrary number of score entries, where
     each score entry has one to four elements.

       1. The first element is the "match element".  On most headers
          this will be a string, but on the Lines and Chars headers,
          this must be an integer.

       2. If the second element is present, it should be a number--the
          score element".  This number should be an integer in the
          neginf to posinf interval.  This number is added to the
          score of the article if the match is successful.  If this
          element is not present, the
          `gnus-score-interactive-default-score' number will be used
          instead.  This is 1000 by default.

       3. If the third element is present, it should be a number--the
          date element".  This date says when the last time this score
          entry matched, which provides a mechanism for expiring the
          score entries.  It this element is not present, the score
          entry is permanent.  The date is represented by the number
          of days since December 31, 1 BCE.

       4. If the fourth element is present, it should be a symbol--the
          type element".  This element specifies what function should
          be used to see whether this score entry matches the article.
          What match types that can be used depends on what header you
          wish to perform the match on.

          "From, Subject, References, Xref, Message-ID"
               For most header types, there are the `r' and `R'
               (regexp), as well as `s' and `S' (substring) types, and
               `e' and `E' (exact match), and `w' (word match) types.
               If this element is not present, Gnus will assume that
               substring matching should be used.  `R', `S', and `E'
               differ from the others in that the matches will be done
               in a case-sensitive manner.  All these one-letter types
               are really just abbreviations for the `regexp',
               `string', `exact', and `word' types, which you can use
               instead, if you feel like.

          "Extra"
               Just as for the standard string overview headers, if
               you are using gnus-extra-headers, you can score on
               these headers' values.  In this case, there is a 5th
               element in the score entry, being the name of the
               header to be scored.  The following entry is useful in
               your `all.SCORE' file in case of spam attacks from a
               single origin host, if your NNTP server tracks
               `NNTP-Posting-Host' in overviews:

                    ("111.222.333.444" -1000 nil s
                     "NNTP-Posting-Host")

          "Lines, Chars"
               These two headers use different match types: `<', `>',
               `=', `>=' and `<='.

               These predicates are true if

                    (PREDICATE HEADER MATCH)

               evaluates to non-`nil'.  For instance, the advanced
               match `("lines" 4 <)' (*Note Advanced Scoring::) will
               result in the following form:

                    (< header-value 4)

               Or to put it another way: When using `<' on `Lines'
               with 4 as the match, we get the score added if the
               article has less than 4 lines.  (It's easy to get
               confused and think it's the other way around.  But it's
               not.  I think.)

               When matching on `Lines', be careful because some back
               ends (like `nndir') do not generate `Lines' header, so
               every article ends up being marked as having 0 lines.
               This can lead to strange results if you happen to lower
               score of the articles with few lines.

          "Date"
               For the Date header we have three kinda silly match
               types: `before', `at' and `after'.  I can't really
               imagine this ever being useful, but, like, it would
               feel kinda silly not to provide this function.  Just in
               case.  You never know.  Better safe than sorry.  Once
               burnt, twice shy.  Don't judge a book by its cover.
               Never not have sex on a first date.  (I have been told
               that at least one person, and I quote, "found this
               function indispensable", however.)

               A more useful match type is `regexp'.  With it, you can
               match the date string using a regular expression.  The
               date is normalized to ISO8601 compact format
               first---YYYYMMDD`T'HHMMSS.  If you want to match all
               articles that have been posted on April 1st in every
               year, you could use `....0401.........' as a match
               string, for instance.  (Note that the date is kept in
               its original time zone, so this will match articles
               that were posted when it was April 1st where the
               article was posted from.  Time zones are such wholesome
               fun for the whole family, eh?)

          "Head, Body, All"
               These three match keys use the same match types as the
               `From' (etc) header uses.

          "Followup"
               This match key is somewhat special, in that it will
               match the `From' header, and affect the score of not
               only the matching articles, but also all followups to
               the matching articles.  This allows you e.g. increase
               the score of followups to your own articles, or
               decrease the score of followups to the articles of some
               known trouble-maker.  Uses the same match types as the
               `From' header uses.  (Using this match key will lead to
               creation of `ADAPT' files.)

          "Thread"
               This match key works along the same lines as the
               `Followup' match key.  If you say that you want to
               score on a (sub-)thread started by an article with a
               `Message-ID' X, then you add a `thread' match.  This
               will add a new `thread' match for each article that has
               X in its `References' header.  (These new `thread'
               matches will use the `Message-ID's of these matching
               articles.)  This will ensure that you can raise/lower
               the score of an entire thread, even though some
               articles in the thread may not have complete
               `References' headers.  Note that using this may lead to
               undeterministic scores of the articles in the thread.
               (Using this match key will lead to creation of `ADAPT'
               files.)

`mark'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be marked as read.

`expunge'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be removed from the summary
     buffer.

`mark-and-expunge'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be marked as read and removed
     from the summary buffer.

`thread-mark-and-expunge'
     The value of this entry should be a number.  All articles that
     belong to a thread that has a total score below this number will
     be marked as read and removed from the summary buffer.
     `gnus-thread-score-function' says how to compute the total score
     for a thread.

`files'
     The value of this entry should be any number of file names.
     These files are assumed to be score files as well, and will be
     loaded the same way this one was.

`exclude-files'
     The clue of this entry should be any number of files.  These
     files will not be loaded, even though they would normally be so,
     for some reason or other.

`eval'
     The value of this entry will be `eval'el.  This element will be
     ignored when handling global score files.

`read-only'
     Read-only score files will not be updated or saved.  Global score
     files should feature this atom (*Note Global Score Files::).
     (Note: "Global" here really means "global"; not your personal
     apply-to-all-groups score files.)

`orphan'
     The value of this entry should be a number.  Articles that do not
     have parents will get this number added to their scores.  Imagine
     you follow some high-volume newsgroup, like `comp.lang.c'.  Most
     likely you will only follow a few of the threads, also want to
     see any new threads.

     You can do this with the following two score file entries:

                  (orphan -500)
                  (mark-and-expunge -100)

     When you enter the group the first time, you will only see the
     new threads.  You then raise the score of the threads that you
     find interesting (with `I T' or `I S'), and ignore (`C y') the
     rest.  Next time you enter the group, you will see new articles
     in the interesting threads, plus any new threads.

     I.e.---the orphan score atom is for high-volume groups where a
     few interesting threads which can't be found automatically by
     ordinary scoring rules exist.

`adapt'
     This entry controls the adaptive scoring.  If it is `t', the
     default adaptive scoring rules will be used.  If it is `ignore',
     no adaptive scoring will be performed on this group.  If it is a
     list, this list will be used as the adaptive scoring rules.  If
     it isn't present, or is something other than `t' or `ignore', the
     default adaptive scoring rules will be used.  If you want to use
     adaptive scoring on most groups, you'd set
     `gnus-use-adaptive-scoring' to `t', and insert an `(adapt
     ignore)' in the groups where you do not want adaptive scoring.
     If you only want adaptive scoring in a few groups, you'd set
     `gnus-use-adaptive-scoring' to `nil', and insert `(adapt t)' in
     the score files of the groups where you want it.

`adapt-file'
     All adaptive score entries will go to the file named by this
     entry.  It will also be applied when entering the group.  This
     atom might be handy if you want to adapt on several groups at
     once, using the same adaptive file for a number of groups.

`local'
     The value of this entry should be a list of `(VAR VALUE)' pairs.
     Each VAR will be made buffer-local to the current summary buffer,
     and set to the value specified.  This is a convenient, if
     somewhat strange, way of setting variables in some groups if you
     don't like hooks much.  Note that the VALUE won't be evaluated.




