Info file: gnus,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License" in the Emacs manual.

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding
     a copy of the license to the document, as described in section 6
     of the license.



INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus: (gnus).         The newsreader Gnus.
END-INFO-DIR-ENTRY








File: gnus, Node: Score File Editing, Next: Adaptive Scoring, Prev: Score File Format, Up: Scoring

Score File Editing
==================

You normally enter all scoring commands from the summary buffer, but
you might feel the urge to edit them by hand as well, so we've
supplied you with a mode for that.

It's simply a slightly customized `emacs-lisp' mode, with these
additional commands:


`C-c C-c'
     Save the changes you have made and return to the summary buffer
     (`gnus-score-edit-exit').

`C-c C-d'
     Insert the current date in numerical format
     (`gnus-score-edit-insert-date').  This is really the day number,
     if you were wondering.

`C-c C-p'
     The adaptive score files are saved in an unformatted fashion.  If
     you intend to read one of these files, you want to "pretty print"
     it first.  This command (`gnus-score-pretty-print') does that for
     you.


Type `M-x gnus-score-mode' to use this mode.

`gnus-score-menu-hook' is run in score mode buffers.

In the summary buffer you can use commands like `V f', `V e' and
`V t' to begin editing score files.




File: gnus, Node: Adaptive Scoring, Next: Home Score File, Prev: Score File Editing, Up: Scoring

Adaptive Scoring
================

If all this scoring is getting you down, Gnus has a way of making it
all happen automatically--as if by magic.  Or rather, as if by
artificial stupidity, to be precise.

When you read an article, or mark an article as read, or kill an
article, you leave marks behind.  On exit from the group, Gnus can
sniff these marks and add score elements depending on what marks it
finds.  You turn on this ability by setting
`gnus-use-adaptive-scoring' to `t' or `(line)'.  If you want score
adaptively on separate words appearing in the subjects, you should set
this variable to `(word)'.  If you want to use both adaptive methods,
set this variable to `(word line)'.

To give you complete control over the scoring process, you can
customize the `gnus-default-adaptive-score-alist' variable.  For
instance, it might look something like this:

     (setq gnus-default-adaptive-score-alist
       '((gnus-unread-mark)
         (gnus-ticked-mark (from 4))
         (gnus-dormant-mark (from 5))
         (gnus-del-mark (from -4) (subject -1))
         (gnus-read-mark (from 4) (subject 2))
         (gnus-expirable-mark (from -1) (subject -1))
         (gnus-killed-mark (from -1) (subject -3))
         (gnus-kill-file-mark)
         (gnus-ancient-mark)
         (gnus-low-score-mark)
         (gnus-catchup-mark (from -1) (subject -1))))

As you see, each element in this alist has a mark as a key (either a
variable name or a "real" mark--a character).  Following this key is a
arbitrary number of header/score pairs.  If there are no header/score
pairs following the key, no adaptive scoring will be done on articles
that have that key as the article mark.  For instance, articles with
`gnus-unread-mark' in the example above will not get adaptive score
entries.

Each article can have only one mark, so just a single of these rules
will be applied to each article.

To take `gnus-del-mark' as an example--this alist says that all
articles that have that mark (i.e., are marked with `e') will have a
score entry added to lower based on the `From' header by -4, and
lowered by `Subject' by -1.  Change this to fit your prejudices.

If you have marked 10 articles with the same subject with
`gnus-del-mark', the rule for that mark will be applied ten times.
That means that that subject will get a score of ten times -1, which
should be, unless I'm much mistaken, -10.

If you have auto-expirable (mail) groups (*Note Expiring Mail::), all
the read articles will be marked with the `E' mark.  This'll probably
make adaptive scoring slightly impossible, so auto-expiring and
adaptive scoring doesn't really mix very well.

The headers you can score on are `from', `subject', `message-id',
`references', `xref', `lines', `chars' and `date'.  In addition, you
can score on `followup', which will create an adaptive score entry
that matches on the `References' header using the `Message-ID' of the
current article, thereby matching the following thread.

If you use this scheme, you should set the score file atom `mark' to
something small--like -300, perhaps, to avoid having small random
changes result in articles getting marked as read.

After using adaptive scoring for a week or so, Gnus should start to
become properly trained and enhance the authors you like best, and
kill the authors you like least, without you having to say so
explicitly.

You can control what groups the adaptive scoring is to be performed on
by using the score files (*Note Score File Format::).  This will also
let you use different rules in different groups.

The adaptive score entries will be put into a file where the name is
the group name with `gnus-adaptive-file-suffix' appended.  The default
is `ADAPT'.

Adaptive score files can get huge and are not meant to be edited by
human hands.  If `gnus-adaptive-pretty-print' is `nil' (the deafult)
those files will not be written in a human readable way.

When doing adaptive scoring, substring or fuzzy matching would
probably give you the best results in most cases.  However, if the
header one matches is short, the possibility for false positives is
great, so if the length of the match is less than
`gnus-score-exact-adapt-limit', exact matching will be used.  If this
variable is `nil', exact matching will always be used to avoid this
problem.

As mentioned above, you can adapt either on individual words or entire
headers.  If you adapt on words, the
`gnus-default-adaptive-word-score-alist' variable says what score each
instance of a word should add given a mark.

     (setq gnus-default-adaptive-word-score-alist
           `((,gnus-read-mark . 30)
             (,gnus-catchup-mark . -10)
             (,gnus-killed-mark . -20)
             (,gnus-del-mark . -15)))

This is the default value.  If you have adaption on words enabled,
every word that appears in subjects of articles marked with
`gnus-read-mark' will result in a score rule that increase the score
with 30 points.

Words that appear in the `gnus-default-ignored-adaptive-words' list
will be ignored.  If you wish to add more words to be ignored, use the
`gnus-ignored-adaptive-words' list instead.

Some may feel that short words shouldn't count when doing adaptive
scoring.  If so, you may set `gnus-adaptive-word-length-limit' to an
integer.  Words shorter than this number will be ignored.  This
variable defaults to `nil'.

When the scoring is done, `gnus-adaptive-word-syntax-table' is the
syntax table in effect.  It is similar to the standard syntax table,
but it considers numbers to be non-word-constituent characters.

If `gnus-adaptive-word-minimum' is set to a number, the adaptive word
scoring process will never bring down the score of an article to below
this number.  The default is `nil'.

If `gnus-adaptive-word-no-group-words' is set to `t', gnus won't
adaptively word score any of the words in the group name.  Useful for
groups like `comp.editors.emacs', where most of the subject lines
contain the word `emacs'.

After using this scheme for a while, it might be nice to write a
`gnus-psychoanalyze-user' command to go through the rules and see what
words you like and what words you don't like.  Or perhaps not.

Note that the adaptive word scoring thing is highly experimental and
is likely to change in the future.  Initial impressions seem to
indicate that it's totally useless as it stands.  Some more work
(involving more rigorous statistical methods) will have to be done to
make this useful.




File: gnus, Node: Home Score File, Next: Followups To Yourself, Prev: Adaptive Scoring, Up: Scoring

Home Score File
===============

The score file where new score file entries will go is called the
"home score file".  This is normally (and by default) the score file
for the group itself.  For instance, the home score file for
`gnu.emacs.gnus' is `gnu.emacs.gnus.SCORE'.

However, this may not be what you want.  It is often convenient to
share a common home score file among many groups--all `emacs' groups
could perhaps use the same home score file.

The variable that controls this is `gnus-home-score-file'.  It can be:

  1. A string.  Then this file will be used as the home score file for
     all groups.

  2. A function.  The result of this function will be used as the home
     score file.  The function will be called with the name of the
     group as the parameter.

  3. A list.  The elements in this list can be:

       1. `(REGEXP FILE-NAME)'.  If the REGEXP matches the group name,
          the FILE-NAME will be used as the home score file.

       2. A function.  If the function returns non-`nil', the result
          will be used as the home score file.  The function will be
          called with the name of the group as the parameter.

       3. A string.  Use the string as the home score file.

     The list will be traversed from the beginning towards the end
     looking for matches.


So, if you want to use just a single score file, you could say:

     (setq gnus-home-score-file
           "my-total-score-file.SCORE")

If you want to use `gnu.SCORE' for all `gnu' groups and
`rec.SCORE' for all `rec' groups (and so on), you can say:

     (setq gnus-home-score-file
           'gnus-hierarchial-home-score-file)

This is a ready-made function provided for your convenience.  Other
functions include

`gnus-current-home-score-file'
     Return the "current" regular score file.  This will make scoring
     commands add entry to the "innermost" matching score file.


If you want to have one score file for the `emacs' groups and another
for the `comp' groups, while letting all other groups use their own
home score files:

     (setq gnus-home-score-file
           ;; All groups that match the regexp `"\\.emacs"'
           '(("\\.emacs" "emacs.SCORE")
             ;; All the comp groups in one score file
             ("^comp" "comp.SCORE")))

`gnus-home-adapt-file' works exactly the same way as
`gnus-home-score-file', but says what the home adaptive score file is
instead.  All new adaptive file entries will go into the file
specified by this variable, and the same syntax is allowed.

In addition to using `gnus-home-score-file' and
`gnus-home-adapt-file', you can also use group parameters (*Note Group
Parameters::) and topic parameters (*Note Topic Parameters::) to
achieve much the same.  Group and topic parameters take precedence
over this variable.




File: gnus, Node: Followups To Yourself, Next: Scoring On Other Headers, Prev: Home Score File, Up: Scoring

Followups To Yourself
=====================

Gnus offers two commands for picking out the `Message-ID' header in
the current buffer.  Gnus will then add a score rule that scores using
this `Message-ID' on the `References' header of other articles.  This
will, in effect, increase the score of all articles that respond to
the article in the current buffer.  Quite useful if you want to easily
note when people answer what you've said.


`gnus-score-followup-article'
     This will add a score to articles that directly follow up your
     own article.

`gnus-score-followup-thread'
     This will add a score to all articles that appear in a thread
     below" your own article.

These two functions are both primarily meant to be used in hooks like
`message-sent-hook', like this:
     (add-hook 'message-sent-hook 'gnus-score-followup-thread)


If you look closely at your own `Message-ID', you'll notice that the
first two or three characters are always the same.  Here's two of
mine:

     <x6u3u47icf.fsf@eyesore.no>
     <x6sp9o7ibw.fsf@eyesore.no>

So "my" ident on this machine is `x6'.  This can be exploited--the
following rule will raise the score on all followups to myself:

     ("references"
      ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@.*eyesore\\.no>"
       1000 nil r))

Whether it's the first two or first three characters that are "yours"
is system-dependent.




File: gnus, Node: Scoring On Other Headers, Next: Scoring Tips, Prev: Followups To Yourself, Up: Scoring

Scoring On Other Headers
========================

Gnus is quite fast when scoring the "traditional" headers---`From',
`Subject' and so on.  However, scoring other headers requires writing
a `head' scoring rule, which means that Gnus has to request every
single article from the back end to find matches.  This takes a long
time in big groups.

Now, there's not much you can do about this for news groups, but for
mail groups, you have greater control.  In *Note To From Newsgroups::,
it's explained in greater detail what this mechanism does, but here's
a cookbook example for `nnml' on how to allow scoring on the
`To' and `Cc' headers.

Put the following in your `~/.gnus.el' file.

     (setq gnus-extra-headers '(To Cc Newsgroups Keywords)
           nnmail-extra-headers gnus-extra-headers)

Restart Gnus and rebuild your `nnml' overview files with the `M-x
nnml-generate-nov-databases' command.  This will take a long time if
you have much mail.

Now you can score on `To' and `Cc' as "extra headers" like so: `I e s
p To RET <your name> RET'.

See?  Simple.

You can inhibit scoring the slow scoring on headers or body by setting
the variable `gnus-inhibit-slow-scoring'.  If
`gnus-inhibit-slow-scoring' is regexp, slow scoring is inhibited if
the group matches the regexp.  If it is t, slow scoring on it is
inhibited for all groups.




File: gnus, Node: Scoring Tips, Next: Reverse Scoring, Prev: Scoring On Other Headers, Up: Scoring

Scoring Tips
============


"Crossposts"
     If you want to lower the score of crossposts, the line to match
     on is the `Xref' header.
          ("xref" (" talk.politics.misc:" -1000))

"Multiple crossposts"
     If you want to lower the score of articles that have been
     crossposted to more than, say, 3 groups:
          ("xref"
            ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+"
             -1000 nil r))

"Matching on the body"
     This is generally not a very good idea--it takes a very long
     time.  Gnus actually has to fetch each individual article from
     the server.  But you might want to anyway, I guess.  Even though
     there are three match keys (`Head', `Body' and `All'), you should
     choose one and stick with it in each score file.  If you use any
     two, each article will be fetched *twice*.  If you want to match
     a bit on the `Head' and a bit on the `Body', just use `All' for
     all the matches.

"Marking as read"
     You will probably want to mark articles that have scores below a
     certain number as read.  This is most easily achieved by putting
     the following in your `all.SCORE' file: ((mark -100)) You may
     also consider doing something similar with `expunge'.

"Negated character classes"
     If you say stuff like `[^abcd]*', you may get unexpected results.
     That will match newlines, which might lead to, well, The Unknown.  Say
     `[^abcd\n]*' instead.




File: gnus, Node: Reverse Scoring, Next: Global Score Files, Prev: Scoring Tips, Up: Scoring

Reverse Scoring
===============

If you want to keep just articles that have `Sex with Emacs' in the
subject header, and expunge all other articles, you could put
something like this in your score file:

     (("subject"
       ("Sex with Emacs" 2))
      (mark 1)
      (expunge 1))

So, you raise all articles that match `Sex with Emacs' and mark the
rest as read, and expunge them to boot.




File: gnus, Node: Global Score Files, Next: Kill Files, Prev: Reverse Scoring, Up: Scoring

Global Score Files
==================

Sure, other newsreaders have "global kill files".  These are usually
nothing more than a single kill file that applies to all groups,
stored in the user's home directory.  Bah!  Puny, weak newsreaders!

What I'm talking about here are Global Score Files.  Score files from
all over the world, from users everywhere, uniting all nations in one
big, happy score file union!  Ange-score!  New and untested!

All you have to do to use other people's score files is to set the
`gnus-global-score-files' variable.  One entry for each score file, or
each score file directory.  Gnus will decide by itself what score
files are applicable to which group.

To use the score file
`/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE' and all
score files in the `/ftp@ftp.some-where:/pub/score' directory, say
this:

     (setq gnus-global-score-files
           '("/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
             "/ftp@ftp.some-where:/pub/score/"))

Simple, eh?  Directory names must end with a `/'.  These directories
are typically scanned only once during each Gnus session.  If you feel
the need to manually re-scan the remote directories, you can use the
`gnus-score-search-global-directories' command.

Note that, at present, using this option will slow down group entry
somewhat.  (That is--a lot.)

If you want to start maintaining score files for other people to use,
just put your score file up for anonymous ftp and announce it to the
world.  Become a retro-moderator!  Participate in the retro-moderator
wars sure to ensue, where retro-moderators battle it out for the
sympathy of the people, luring them to use their score files on false
premises!  Yay!  The net is saved!

Here are some tips for the would-be retro-moderator, off the top of my
head:


   * Articles heavily crossposted are probably junk.
   * To lower a single inappropriate article, lower by `Message-ID'.
   * Particularly brilliant authors can be raised on a permanent
     basis.
   * Authors that repeatedly post off-charter for the group can safely
     be lowered out of existence.
   * Set the `mark' and `expunge' atoms to obliterate the nastiest
     articles completely.

   * Use expiring score entries to keep the size of the file down.
     You should probably have a long expiry period, though, as some
     sites keep old articles for a long time.

... I wonder whether other newsreaders will support global score files
in the future.  *Snicker*.  Yup, any day now, newsreaders like Blue
Wave, xrn and 1stReader are bound to implement scoring.  Should we
start holding our breath yet?




File: gnus, Node: Kill Files, Next: Converting Kill Files, Prev: Global Score Files, Up: Scoring

Kill Files
==========

Gnus still supports those pesky old kill files.  In fact, the kill
file entries can now be expiring, which is something I wrote before
Daniel Quinlan thought of doing score files, so I've left the code in
there.

In short, kill processing is a lot slower (and I do mean *a lot*) than
score processing, so it might be a good idea to rewrite your kill
files into score files.

Anyway, a kill file is a normal `emacs-lisp' file.  You can put any
forms into this file, which means that you can use kill files as some
sort of primitive hook function to be run on group entry, even though
that isn't a very good idea.

Normal kill files look like this:

     (gnus-kill "From" "Lars Ingebrigtsen")
     (gnus-kill "Subject" "ding")
     (gnus-expunge "X")

This will mark every article written by me as read, and remove the
marked articles from the summary buffer.  Very useful, you'll agree.

Other programs use a totally different kill file syntax.  If Gnus
encounters what looks like a `rn' kill file, it will take a stab at
interpreting it.

Two summary functions for editing a GNUS kill file:


`M-k'
     Edit this group's kill file (`gnus-summary-edit-local-kill').

`M-K'
     Edit the general kill file (`gnus-summary-edit-global-kill').

Two group mode functions for editing the kill files:


`M-k'
     Edit this group's kill file (`gnus-group-edit-local-kill').

`M-K'
     Edit the general kill file (`gnus-group-edit-global-kill').

Kill file variables:

`gnus-kill-file-name'
     A kill file for the group `soc.motss' is normally called
     `soc.motss.KILL'.  The suffix appended to the group name to get
     this file name is detailed by the `gnus-kill-file-name' variable.
     The "global" kill file (not in the score file sense of "global",
     of course) is just called `KILL'.

`gnus-kill-save-kill-file'
     If this variable is non-`nil', Gnus will save the kill file after
     processing, which is necessary if you use expiring kills.

`gnus-apply-kill-hook'
     A hook called to apply kill files to a group.  It is
     `(gnus-apply-kill-file)' by default.  If you want to ignore the
     kill file if you have a score file for the same group, you can
     set this hook to `(gnus-apply-kill-file-unless-scored)'.  If you
     don't want kill files to be processed, you should set this
     variable to `nil'.

`gnus-kill-file-mode-hook'
     A hook called in kill-file mode buffers.





File: gnus, Node: Converting Kill Files, Next: Advanced Scoring, Prev: Kill Files, Up: Scoring

Converting Kill Files
=====================

If you have loads of old kill files, you may want to convert them into
score files.  If they are "regular", you can use the
`gnus-kill-to-score.el' package; if not, you'll have to do it by hand.

The kill to score conversion package isn't included in Gnus by default.
You can fetch it from
`http://www.stud.ifi.uio.no/~larsi/ding-various/gnus-kill-to-score.el'.

If your old kill files are very complex--if they contain more
non-`gnus-kill' forms than not, you'll have to convert them by hand.
Or just let them be as they are.  Gnus will still use them as before.




File: gnus, Node: Advanced Scoring, Next: Score Decays, Prev: Converting Kill Files, Up: Scoring

Advanced Scoring
================

Scoring on Subjects and From headers is nice enough, but what if
you're really interested in what a person has to say only when she's
talking about a particular subject?  Or what if you really don't want
to read what person A has to say when she's following up to person B,
but want to read what she says when she's following up to person C?

By using advanced scoring rules you may create arbitrarily complex
scoring patterns.

* Menu:

* Advanced Scoring Syntax::     A definition.
* Advanced Scoring Examples::   What they look like.
* Advanced Scoring Tips::       Getting the most out of it.




File: gnus, Node: Advanced Scoring Syntax, Next: Advanced Scoring Examples, Prev: Advanced Scoring, Up: Advanced Scoring

Advanced Scoring Syntax
-----------------------

Ordinary scoring rules have a string as the first element in the rule.
Advanced scoring rules have a list as the first element.  The second
element is the score to be applied if the first element evaluated to a
non-`nil' value.

These lists may consist of three logical operators, one redirection
operator, and various match operators.

Logical operators:

`&'
`and'
     This logical operator will evaluate each of its arguments until it finds
     one that evaluates to `false', and then it'll stop.  If all arguments
     evaluate to `true' values, then this operator will return
     `true'.

`|'
`or'
     This logical operator will evaluate each of its arguments until
     it finds one that evaluates to `true'.  If no arguments are
     `true', then this operator will return `false'.

`!'
`not'
`¬'
     This logical operator only takes a single argument.  It returns
     the logical negation of the value of its argument.


There is an "indirection operator" that will make its arguments apply
to the ancestors of the current article being scored.  For instance,
`1-' will make score rules apply to the parent of the current article.
`2-' will make score rules apply to the grandparent of the current
article.  Alternatively, you can write `^^', where the number of `^'s
(carets) says how far back into the ancestry you want to go.

Finally, we have the match operators.  These are the ones that do the
real work.  Match operators are header name strings followed by a
match and a match type.  A typical match operator looks like `("from"
Lars Ingebrigtsen" s)'.  The header names are the same as when using
simple scoring, and the match types are also the same.




File: gnus, Node: Advanced Scoring Examples, Next: Advanced Scoring Tips, Prev: Advanced Scoring Syntax, Up: Advanced Scoring

Advanced Scoring Examples
-------------------------

Please note that the following examples are score file rules.  To make
a complete score file from them, surround them with another pair of
parentheses.

Let's say you want to increase the score of articles written by Lars
when he's talking about Gnus:

     ((&
       ("from" "Lars Ingebrigtsen")
       ("subject" "Gnus"))
      1000)

Quite simple, huh?

When he writes long articles, he sometimes has something nice to say:

     ((&
       ("from" "Lars Ingebrigtsen")
       (|
        ("subject" "Gnus")
        ("lines" 100 >)))
      1000)

However, when he responds to things written by Reig Eigil Logge, you
really don't want to read what he's written:

     ((&
       ("from" "Lars Ingebrigtsen")
       (1- ("from" "Reig Eigil Logge")))
      -100000)

Everybody that follows up Redmondo when he writes about disappearing
socks should have their scores raised, but only when they talk about
white socks.  However, when Lars talks about socks, it's usually not
very interesting:

     ((&
       (1-
        (&
         ("from" "redmondo@.*no" r)
         ("body" "disappearing.*socks" t)))
       (! ("from" "Lars Ingebrigtsen"))
       ("body" "white.*socks"))
      1000)

Suppose you're reading a high volume group and you're only interested
in replies. The plan is to score down all articles that don't have
subject that begin with "Re:", "Fw:" or "Fwd:" and then score up all
parents of articles that have subjects that begin with reply marks.

     ((! ("subject" "re:\\|fwd?:" r))
       -200)
     ((1- ("subject" "re:\\|fwd?:" r))
       200)

The possibilities are endless.



File: gnus, Node: Advanced Scoring Tips, Prev: Advanced Scoring Examples, Up: Advanced Scoring

Advanced Scoring Tips
---------------------

The `&' and `|' logical operators do short-circuit logic.
That is, they stop processing their arguments when it's clear what the
result of the operation will be.  For instance, if one of the arguments
of an `&' evaluates to `false', there's no point in evaluating
the rest of the arguments.  This means that you should put slow matches
(`body', `header') last and quick matches (`from',
`subject') first.

The indirection arguments (`1-' and so on) will make their arguments
work on previous generations of the thread.  If you say something
like:

     ...
     (1-
      (1-
       ("from" "lars")))
     ...

Then that means "score on the from header of the grandparent of the
current article".  An indirection is quite fast, but it's better to
say:

     (1-
      (&
       ("from" "Lars")
       ("subject" "Gnus")))

than it is to say:

     (&
      (1- ("from" "Lars"))
      (1- ("subject" "Gnus")))




File: gnus, Node: Score Decays, Prev: Advanced Scoring, Up: Scoring

Score Decays
============

You may find that your scores have a tendency to grow without bounds,
especially if you're using adaptive scoring.  If scores get too big,
they lose all meaning--they simply max out and it's difficult to use
them in any sensible way.

Gnus provides a mechanism for decaying scores to help with this
problem.  When score files are loaded and `gnus-decay-scores' is
non-`nil', Gnus will run the score files through the decaying
mechanism thereby lowering the scores of all non-permanent score
rules.  If `gnus-decay-scores' is a regexp, only score files matching
this regexp are treated.  E.g. you may set it to `\\.ADAPT\\'' if only
*adaptive* score files should be decayed.  The decay itself if
performed by the `gnus-decay-score-function' function, which is
`gnus-decay-score' by default.  Here's the definition of that
function:

     (defun gnus-decay-score (score)
       "Decay SCORE according to `gnus-score-decay-constant'
     and `gnus-score-decay-scale'."
       (let ((n (- score
                   (* (if (< score 0) -1 1)
                      (min (abs score)
                           (max gnus-score-decay-constant
                                (* (abs score)
                                   gnus-score-decay-scale)))))))
         (if (and (featurep 'xemacs)
                  ;; XEmacs' floor can handle only the floating point
                  ;; number below the half of the maximum integer.
                  (> (abs n) (lsh -1 -2)))
             (string-to-number
              (car (split-string (number-to-string n) "\\.")))
           (floor n))))

`gnus-score-decay-constant' is 3 by default and
`gnus-score-decay-scale' is 0.05.  This should cause the following:

  1. Scores between -3 and 3 will be set to 0 when this function is
     called.

  2. Scores with magnitudes between 3 and 60 will be shrunk by 3.

  3. Scores with magnitudes greater than 60 will be shrunk by 5% of
     the score.

If you don't like this decay function, write your own.  It is called
with the score to be decayed as its only parameter, and it should
return the new score, which should be an integer.

Gnus will try to decay scores once a day.  If you haven't run Gnus for
four days, Gnus will decay the scores four times, for instance.




File: gnus, Node: Various, Next: The End, Prev: Scoring, Up: Top

Various
*******

* Menu:

* Process/Prefix::              A convention used by many treatment commands.
* Interactive::                 Making Gnus ask you many questions.
* Symbolic Prefixes::           How to supply some Gnus functions with options.
* Formatting Variables::        You can specify what buffers should look like.
* Window Layout::               Configuring the Gnus buffer windows.
* Faces and Fonts::             How to change how faces look.
* Compilation::                 How to speed Gnus up.
* Mode Lines::                  Displaying information in the mode lines.
* Highlighting and Menus::      Making buffers look all nice and cozy.
* Buttons::                     Get tendinitis in ten easy steps!
* Daemons::                     Gnus can do things behind your back.
* NoCeM::                       How to avoid spam and other fatty foods.
* Undo::                        Some actions can be undone.
* Predicate Specifiers::        Specifying predicates.
* Moderation::                  What to do if you're a moderator.
* Fetching a Group::            Starting Gnus just to read a group.
* Image Enhancements::          Modern versions of Emacs/XEmacs can display images.
* Fuzzy Matching::              What's the big fuzz?
* Thwarting Email Spam::        Simple ways to avoid unsolicited commercial email.
* Spam Package::                A package for filtering and processing spam.
* Other modes::                 Interaction with other modes.
* Various Various::             Things that are really various.




File: gnus, Node: Process/Prefix, Next: Interactive, Prev: Various, Up: Various

Process/Prefix
==============

Many functions, among them functions for moving, decoding and saving
articles, use what is known as the "Process/Prefix convention".

This is a method for figuring out what articles the user wants the
command to be performed on.

It goes like this:

If the numeric prefix is N, perform the operation on the next N
articles, starting with the current one.  If the numeric prefix is
negative, perform the operation on the previous N articles, starting
with the current one.

If `transient-mark-mode' in non-`nil' and the region is active, all
articles in the region will be worked upon.

If there is no numeric prefix, but some articles are marked with the
process mark, perform the operation on the articles marked with the
process mark.

If there is neither a numeric prefix nor any articles marked with the
process mark, just perform the operation on the current article.

Quite simple, really, but it needs to be made clear so that surprises
are avoided.

Commands that react to the process mark will push the current list of
process marked articles onto a stack and will then clear all process
marked articles.  You can restore the previous configuration with the
`M P y' command (*Note Setting Process Marks::).

One thing that seems to shock & horrify lots of people is that, for
instance, `3 d' does exactly the same as `d' `d' `d'.
Since each `d' (which marks the current article as read) by default
goes to the next unread article after marking, this means that `3 d'
will mark the next three unread articles as read, no matter what the
summary buffer looks like.  Set `gnus-summary-goto-unread' to
`nil' for a more straightforward action.

Many commands do not use the process/prefix convention.  All commands
that do explicitly say so in this manual.  To apply the process/prefix
convention to commands that do not use it, you can use the `M-&'
command.  For instance, to mark all the articles in the group as
expirable, you could say `M P b M-& E'.




File: gnus, Node: Interactive, Next: Symbolic Prefixes, Prev: Process/Prefix, Up: Various

Interactive
===========


`gnus-novice-user'
     If this variable is non-`nil', you are either a newcomer to the
     World of Usenet, or you are very cautious, which is a nice thing
     to be, really.  You will be given questions of the type "Are you
     sure you want to do this?" before doing anything dangerous.  This
     is `t' by default.

`gnus-expert-user'
     If this variable is non-`nil', you will seldom be asked any
     questions by Gnus.  It will simply assume you know what you're
     doing, no matter how strange.

`gnus-interactive-catchup'
     Require confirmation before catching up a group if non-`nil'.  It
     is `t' by default.

`gnus-interactive-exit'
     Require confirmation before exiting Gnus.  This variable is `t'
     by default.




File: gnus, Node: Symbolic Prefixes, Next: Formatting Variables, Prev: Interactive, Up: Various

Symbolic Prefixes
=================

Quite a lot of Emacs commands react to the (numeric) prefix.  For
instance, `C-u 4 C-f' moves point four characters forward, and `C-u 9
0 0 I s s p' adds a permanent `Subject' substring score rule of 900 to
the current article.

This is all nice and well, but what if you want to give a command some
additional information?  Well, what most commands do is interpret the
raw" prefix in some special way.  `C-u 0 C-x C-s' means that one
doesn't want a backup file to be created when saving the current
buffer, for instance.  But what if you want to save without making a
backup file, and you want Emacs to flash lights and play a nice tune
at the same time?  You can't, and you're probably perfectly happy that
way.

I'm not, so I've added a second prefix--the "symbolic prefix".  The
prefix key is `M-i' (`gnus-symbolic-argument'), and the next
character typed in is the value.  You can stack as many `M-i'
prefixes as you want.  `M-i a C-M-u' means "feed the `C-M-u'
command the symbolic prefix `a'".  `M-i a M-i b C-M-u' means
"feed the `C-M-u' command the symbolic prefixes `a' and
`b'".  You get the drift.

Typing in symbolic prefixes to commands that don't accept them doesn't
hurt, but it doesn't do any good either.  Currently not many Gnus
functions make use of the symbolic prefix.

If you're interested in how Gnus implements this, *Note Extended
Interactive::.




File: gnus, Node: Formatting Variables, Next: Window Layout, Prev: Symbolic Prefixes, Up: Various

Formatting Variables
====================

Throughout this manual you've probably noticed lots of variables
called things like `gnus-group-line-format' and
`gnus-summary-mode-line-format'.  These control how Gnus is to output
lines in the various buffers.  There's quite a lot of them.
Fortunately, they all use the same syntax, so there's not that much to
be annoyed by.

Here's an example format spec (from the group buffer): `%M%S%5y:
%(%g%)\n'.  We see that it is indeed extremely ugly, and that there
are lots of percentages everywhere.

* Menu:

* Formatting Basics::           A formatting variable is basically a format string.
* Mode Line Formatting::        Some rules about mode line formatting variables.
* Advanced Formatting::         Modifying output in various ways.
* User-Defined Specs::          Having Gnus call your own functions.
* Formatting Fonts::            Making the formatting look colorful and nice.
* Positioning Point::           Moving point to a position after an operation.
* Tabulation::                  Tabulating your output.
* Wide Characters::             Dealing with wide characters.

Currently Gnus uses the following formatting variables:
`gnus-group-line-format', `gnus-summary-line-format',
`gnus-server-line-format', `gnus-topic-line-format',
`gnus-group-mode-line-format',
`gnus-summary-mode-line-format',
`gnus-article-mode-line-format',
`gnus-server-mode-line-format', and
`gnus-summary-pick-line-format'.

All these format variables can also be arbitrary elisp forms.  In that
case, they will be `eval'ed to insert the required lines.

Gnus includes a command to help you while creating your own format
specs.  `M-x gnus-update-format' will `eval' the current form, update
the spec in question and pop you to a buffer where you can examine the
resulting Lisp code to be run to generate the line.





File: gnus, Node: Formatting Basics, Next: Mode Line Formatting, Prev: Formatting Variables, Up: Formatting Variables

Formatting Basics
-----------------

Each `%' element will be replaced by some string or other when the
buffer in question is generated.  `%5y' means "insert the `y' spec,
and pad with spaces to get a 5-character field".

As with normal C and Emacs Lisp formatting strings, the numerical
modifier between the `%' and the formatting type character will "pad"
the output so that it is always at least that long.  `%5y' will make
the field always (at least) five characters wide by padding with
spaces to the left.  If you say `%-5y', it will pad to the right
instead.

You may also wish to limit the length of the field to protect against
particularly wide values.  For that you can say `%4,6y', which means
that the field will never be more than 6 characters wide and never
less than 4 characters wide.

Also Gnus supports some extended format specifications, such as
`%&user-date;'.




File: gnus, Node: Mode Line Formatting, Next: Advanced Formatting, Prev: Formatting Basics, Up: Formatting Variables

Mode Line Formatting
--------------------

Mode line formatting variables (e.g., `gnus-summary-mode-line-format')
follow the same rules as other, buffer line oriented formatting
variables (*Note Formatting Basics::) with the following two
differences:


  1. There must be no newline (`\n') at the end.

  2. The special `%%b' spec can be used to display the buffer name.
     Well, it's no spec at all, really---`%%' is just a way to quote
     `%' to allow it to pass through the formatting machinery unmangled,
     so that Emacs receives `%b', which is something the Emacs mode line
     display interprets to mean "show the buffer name".  For a full list of
     mode line specs Emacs understands, see the documentation of the
     `mode-line-format' variable.





File: gnus, Node: Advanced Formatting, Next: User-Defined Specs, Prev: Mode Line Formatting, Up: Formatting Variables

Advanced Formatting
-------------------

It is frequently useful to post-process the fields in some way.
Padding, limiting, cutting off parts and suppressing certain values
can be achieved by using "tilde modifiers".  A typical tilde spec
might look like `%~(cut 3)~(ignore "0")y'.

These are the valid modifiers:

`pad'
`pad-left'
     Pad the field to the left with spaces until it reaches the
     required length.

`pad-right'
     Pad the field to the right with spaces until it reaches the
     required length.

`max'
`max-left'
     Cut off characters from the left until it reaches the specified
     length.

`max-right'
     Cut off characters from the right until it reaches the specified
     length.

`cut'
`cut-left'
     Cut off the specified number of characters from the left.

`cut-right'
     Cut off the specified number of characters from the right.

`ignore'
     Return an empty string if the field is equal to the specified
     value.

`form'
     Use the specified form as the field value when the `@' spec is
     used.

     Here's an example:

          "~(form (current-time-string))@"


Let's take an example.  The `%o' spec in the summary mode lines will
return a date in compact ISO8601 format---`19960809T230410'.  This is
quite a mouthful, so we want to shave off the century number and the
time, leaving us with a six-character date.  That would be
`%~(cut-left 2)~(max-right 6)~(pad 6)o'.  (Cutting is done before
maxing, and we need the padding to ensure that the date is never less
than 6 characters to make it look nice in columns.)

Ignoring is done first; then cutting; then maxing; and then as the
very last operation, padding.

If you use lots of these advanced thingies, you'll find that Gnus gets
quite slow.  This can be helped enormously by running `M-x
gnus-compile' when you are satisfied with the look of your lines.
*Note Compilation::.




File: gnus, Node: User-Defined Specs, Next: Formatting Fonts, Prev: Advanced Formatting, Up: Formatting Variables

User-Defined Specs
------------------

All the specs allow for inserting user defined specifiers---`u'.  The
next character in the format string should be a letter.  Gnus will
call the function `gnus-user-format-function-'`X', where `X' is the
letter following `%u'.  The function will be passed a single
parameter--what the parameter means depends on what buffer it's being
called from.  The function should return a string, which will be
inserted into the buffer just like information from any other
specifier.  This function may also be called with dummy values, so it
should protect against that.

Also Gnus supports extended user-defined specs, such as `%u&foo;'.
Gnus will call the function `gnus-user-format-function-'`foo'.

You can also use tilde modifiers (*Note Advanced Formatting:: to
achieve much the same without defining new functions.  Here's an
example: `%~(form (count-lines (point-min) (point)))@'.  The form
given here will be evaluated to yield the current line number, and
then inserted.




File: gnus, Node: Formatting Fonts, Next: Positioning Point, Prev: User-Defined Specs, Up: Formatting Variables

Formatting Fonts
----------------

There are specs for highlighting, and these are shared by all the
format variables.  Text inside the `%(' and `%)' specifiers will get
the special `mouse-face' property set, which means that it will be
highlighted (with `gnus-mouse-face') when you put the mouse pointer
over it.

Text inside the `%{' and `%}' specifiers will have their
normal faces set using `gnus-face-0', which is `bold' by
default.  If you say `%1{', you'll get `gnus-face-1' instead,
and so on.  Create as many faces as you wish.  The same goes for the
`mouse-face' specs--you can say `%3(hello%)' to have
`hello' mouse-highlighted with `gnus-mouse-face-3'.

Text inside the `%<<' and `%>>' specifiers will get the special
`balloon-help' property set to `gnus-balloon-face-0'.  If you say
`%1<<', you'll get `gnus-balloon-face-1' and so on.  The
`gnus-balloon-face-*' variables should be either strings or symbols
naming functions that return a string.  When the mouse passes over
text with this property set, a balloon window will appear and display
the string.  Please refer to *Note Tooltips: (emacs)Tooltips, (in GNU
Emacs) or the doc string of `balloon-help-mode' (in XEmacs) for more
information on this.  (For technical reasons, the guillemets have been
approximated as `<<' and `>>' in this paragraph.)

Here's an alternative recipe for the group buffer:

     ;; Create three face types.
     (setq gnus-face-1 'bold)
     (setq gnus-face-3 'italic)

     ;; We want the article count to be in
     ;; a bold and green face.  So we create
     ;; a new face called `my-green-bold'.
     (copy-face 'bold 'my-green-bold)
     ;; Set the color.
     (set-face-foreground 'my-green-bold "ForestGreen")
     (setq gnus-face-2 'my-green-bold)

     ;; Set the new & fancy format.
     (setq gnus-group-line-format
           "%M%S%3{%5y%}%2[:%] %(%1{%g%}%)\n")

I'm sure you'll be able to use this scheme to create totally
unreadable and extremely vulgar displays.  Have fun!

Note that the `%(' specs (and friends) do not make any sense on the
mode-line variables.



File: gnus, Node: Positioning Point, Next: Tabulation, Prev: Formatting Fonts, Up: Formatting Variables

Positioning Point
-----------------

Gnus usually moves point to a pre-defined place on each line in most
buffers.  By default, point move to the first colon character on the
line.  You can customize this behavior in three different ways.

You can move the colon character to somewhere else on the line.

You can redefine the function that moves the point to the colon.  The
function is called `gnus-goto-colon'.

But perhaps the most convenient way to deal with this, if you don't
want to have a colon in your line, is to use the `%*' specifier.  If
you put a `%*' somewhere in your format line definition, Gnus will
place point there.




File: gnus, Node: Tabulation, Next: Wide Characters, Prev: Positioning Point, Up: Formatting Variables

Tabulation
----------

You can usually line up your displays by padding and cutting your
strings.  However, when combining various strings of different size,
it can often be more convenient to just output the strings, and then
worry about lining up the following text afterwards.

To do that, Gnus supplies tabulator specs---`%='.  There are two
different types---"hard tabulators" and "soft tabulators".

`%50=' will insert space characters to pad the line up to column 50.
If the text is already past column 50, nothing will be inserted.  This
is the soft tabulator.

`%-50=' will insert space characters to pad the line up to column 50.
If the text is already past column 50, the excess text past column 50
will be removed.  This is the hard tabulator.




File: gnus, Node: Wide Characters, Prev: Tabulation, Up: Formatting Variables

Wide Characters
---------------

Fixed width fonts in most countries have characters of the same width.
Some countries, however, use Latin characters mixed with wider
characters--most notable East Asian countries.

The problem is that when formatting, Gnus assumes that if a string is
10 characters wide, it'll be 10 Latin characters wide on the screen.
In these countries, that's not true.

To help fix this, you can set `gnus-use-correct-string-widths' to `t'.
This makes buffer generation slower, but the results will be prettier.
The default value under XEmacs is `t' but `nil' for Emacs.




File: gnus, Node: Window Layout, Next: Faces and Fonts, Prev: Formatting Variables, Up: Various

Window Layout
=============

No, there's nothing here about X, so be quiet.

If `gnus-use-full-window' non-`nil', Gnus will delete all
other windows and occupy the entire Emacs screen by itself.  It is
`t' by default.

Setting this variable to `nil' kinda works, but there are glitches.
Use at your own peril.

`gnus-buffer-configuration' describes how much space each Gnus buffer
should be given.  Here's an excerpt of this variable:

     ((group (vertical 1.0 (group 1.0 point)
                           (if gnus-carpal (group-carpal 4))))
      (article (vertical 1.0 (summary 0.25 point)
                             (article 1.0))))

This is an alist.  The "key" is a symbol that names some action or
other.  For instance, when displaying the group buffer, the window
configuration function will use `group' as the key.  A full list of
possible names is listed below.

The "value" (i.e., the "split") says how much space each buffer should
occupy.  To take the `article' split as an example -

     (article (vertical 1.0 (summary 0.25 point)
                            (article 1.0)))

This "split" says that the summary buffer should occupy 25% of upper
half of the screen, and that it is placed over the article buffer.  As
you may have noticed, 100% + 25% is actually 125% (yup, I saw y'all
reaching for that calculator there).  However, the special number
`1.0' is used to signal that this buffer should soak up all the rest
of the space available after the rest of the buffers have taken
whatever they need.  There should be only one buffer with the `1.0'
size spec per split.

Point will be put in the buffer that has the optional third element
`point'.  In a `frame' split, the last subsplit having a leaf split
where the tag `frame-focus' is a member (i.e. is the third or fourth
element in the list, depending on whether the `point' tag is present)
gets focus.

Here's a more complicated example:

     (article (vertical 1.0 (group 4)
                            (summary 0.25 point)
                            (if gnus-carpal (summary-carpal 4))
                            (article 1.0)))

If the size spec is an integer instead of a floating point number,
then that number will be used to say how many lines a buffer should
occupy, not a percentage.

If the "split" looks like something that can be `eval'ed (to be
precise--if the `car' of the split is a function or a subr), this
split will be `eval'ed.  If the result is non-`nil', it will be used
as a split.  This means that there will be three buffers if
`gnus-carpal' is `nil', and four buffers if `gnus-carpal' is
non-`nil'.

Not complicated enough for you?  Well, try this on for size:

     (article (horizontal 1.0
                  (vertical 0.5
                      (group 1.0)
                      (gnus-carpal 4))
                  (vertical 1.0
                      (summary 0.25 point)
                      (summary-carpal 4)
                      (article 1.0))))

Whoops.  Two buffers with the mystery 100% tag.  And what's that
`horizontal' thingie?

If the first element in one of the split is `horizontal', Gnus will
split the window horizontally, giving you two windows side-by-side.
Inside each of these strips you may carry on all you like in the
normal fashion.  The number following `horizontal' says what
percentage of the screen is to be given to this strip.

For each split, there *must* be one element that has the 100% tag.
The splitting is never accurate, and this buffer will eat any leftover
lines from the splits.

To be slightly more formal, here's a definition of what a valid split
may look like:

     split      = frame | horizontal | vertical | buffer | form
     frame      = "(frame " size *split ")"
     horizontal = "(horizontal " size *split ")"
     vertical   = "(vertical " size *split ")"
     buffer     = "(" buf-name " " size *[ "point" ] *[ "frame-focus"] ")"
     size       = number | frame-params
     buf-name   = group | article | summary ...

The limitations are that the `frame' split can only appear as the
top-level split.  FORM should be an Emacs Lisp form that should return
a valid split.  We see that each split is fully recursive, and may
contain any number of `vertical' and `horizontal' splits.

Finding the right sizes can be a bit complicated.  No window may be
less than `gnus-window-min-height' (default 1) characters high, and
all windows must be at least `gnus-window-min-width' (default 1)
characters wide.  Gnus will try to enforce this before applying the
splits.  If you want to use the normal Emacs window width/height
limit, you can just set these two variables to `nil'.

If you're not familiar with Emacs terminology, `horizontal' and
`vertical' splits may work the opposite way of what you'd expect.
Windows inside a `horizontal' split are shown side-by-side, and
windows within a `vertical' split are shown above each other.

If you want to experiment with window placement, a good tip is to call
`gnus-configure-frame' directly with a split.  This is the function
that does all the real work when splitting buffers.  Below is a pretty
nonsensical configuration with 5 windows; two for the group buffer and
three for the article buffer.  (I said it was nonsensical.)  If you
`eval' the statement below, you can get an idea of how that would look
straight away, without going through the normal Gnus channels.  Play
with it until you're satisfied, and then use `gnus-add-configuration'
to add your new creation to the buffer configuration list.

     (gnus-configure-frame
      '(horizontal 1.0
         (vertical 10
           (group 1.0)
           (article 0.3 point))
         (vertical 1.0
           (article 1.0)
           (horizontal 4
             (group 1.0)
             (article 10)))))

You might want to have several frames as well.  No prob--just use the
`frame' split:

     (gnus-configure-frame
      '(frame 1.0
              (vertical 1.0
                        (summary 0.25 point frame-focus)
                        (article 1.0))
              (vertical ((height . 5) (width . 15)
                         (user-position . t)
                         (left . -1) (top . 1))
                        (picon 1.0))))


This split will result in the familiar summary/article window
configuration in the first (or "main") frame, while a small additional
frame will be created where picons will be shown.  As you can see,
instead of the normal `1.0' top-level spec, each additional split
should have a frame parameter alist as the size spec.  *Note Frame
Parameters: (elisp)Frame Parameters.  Under XEmacs, a frame property
list will be accepted, too--for instance, `(height 5 width 15 left -1
top 1)' is such a plist.  The list of all possible keys for
`gnus-buffer-configuration' can be found in its default value.

Note that the `message' key is used for both `gnus-group-mail' and
`gnus-summary-mail-other-window'.  If it is desirable to distinguish
between the two, something like this might be used:

     (message (horizontal 1.0
                          (vertical 1.0 (message 1.0 point))
                          (vertical 0.24
                                    (if (buffer-live-p gnus-summary-buffer)
                                        '(summary 0.5))
                                    (group 1.0))))

One common desire for a multiple frame split is to have a separate
frame for composing mail and news while leaving the original frame
intact.  To accomplish that, something like the following can be done:

     (message
       (frame 1.0
              (if (not (buffer-live-p gnus-summary-buffer))
                  (car (cdr (assoc 'group gnus-buffer-configuration)))
                (car (cdr (assoc 'summary gnus-buffer-configuration))))
              (vertical ((user-position . t) (top . 1) (left . 1)
                         (name . "Message"))
                        (message 1.0 point))))

Since the `gnus-buffer-configuration' variable is so long and
complicated, there's a function you can use to ease changing the
config of a single setting: `gnus-add-configuration'.  If, for
instance, you want to change the `article' setting, you could say:

     (gnus-add-configuration
      '(article (vertical 1.0
                    (group 4)
                    (summary .25 point)
                    (article 1.0))))

You'd typically stick these `gnus-add-configuration' calls in your
`~/.gnus.el' file or in some startup hook--they should be run after
Gnus has been loaded.

If all windows mentioned in the configuration are already visible, Gnus
won't change the window configuration.  If you always want to force the
"right" window configuration, you can set
`gnus-always-force-window-configuration' to non-`nil'.

If you're using tree displays (*Note Tree Display::), and the tree
window is displayed vertically next to another window, you may also
want to fiddle with `gnus-tree-minimize-window' to avoid having the
windows resized.


Example Window Configurations
-----------------------------

   * Narrow left hand side occupied by group buffer.  Right hand side
     split between summary buffer (top one-sixth) and article buffer
     (bottom).

          +---+---------+
          | G | Summary |
          | r +---------+
          | o |         |
          | u | Article |
          | p |         |
          +---+---------+

          (gnus-add-configuration
           '(article
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0
                                   (summary 0.16 point)
                                   (article 1.0)))))

          (gnus-add-configuration
           '(summary
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0 (summary 1.0 point)))))





