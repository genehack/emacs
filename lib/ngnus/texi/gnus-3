Info file: gnus,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License" in the Emacs manual.

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding
     a copy of the license to the document, as described in section 6
     of the license.



INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus: (gnus).         The newsreader Gnus.
END-INFO-DIR-ENTRY








File: gnus, Node: RSS, Next: Customizing W3, Prev: Web Archive, Up: Browsing the Web

RSS
---

Some web sites have an RDF Site Summary (RSS).  RSS is a format for
summarizing headlines from news related sites (such as BBC or CNN).
But basically anything list-like can be presented as an RSS feed:
weblogs, changelogs or recent changes to a wiki
(e.g. `http://cliki.net/recent-changes.rdf').

RSS has a quite regular and nice interface, and it's possible to get
the information Gnus needs to keep groups updated.

Note: you had better use Emacs which supports the `utf-8' coding
system because RSS uses UTF-8 for encoding non-ASCII text by default.
It is also used by default for non-ASCII group names.

Use `G R' from the group buffer to subscribe to a feed--you will be
prompted for the location, the title and the description of the feed.
The title, which allows any characters, will be used for the group
name and the name of the group data file.  The description can be
omitted.

An easy way to get started with `nnrss' is to say something like the
following in the group buffer: `B nnrss RET RET y', then subscribe to
groups.

The `nnrss' back end saves the group data file in `nnrss-directory'
(see below) for each `nnrss' group.  File names containing non-ASCII
characters will be encoded by the coding system specified with the
`nnmail-pathname-coding-system' variable.  If it is `nil', in Emacs
the coding system defaults to the value of
`default-file-name-coding-system'.  If you are using XEmacs and want
to use non-ASCII group names, you should set the value for the
`nnmail-pathname-coding-system' variable properly.

The `nnrss' back end generates `multipart/alternative' MIME articles
in which each contains a `text/plain' part and a `text/html' part.

You can also use the following commands to import and export your
subscriptions from a file in OPML format (Outline Processor Markup
Language).

 -- Function: nnrss-opml-import FILE
     Prompt for an OPML file, and subscribe to each feed in the file.

 -- Function: nnrss-opml-export
     Write your current RSS subscriptions to a buffer in
     OPML format.

The following `nnrss' variables can be altered:

`nnrss-directory'
     The directory where `nnrss' stores its files.  The default is
     `~/News/rss/'.

`nnrss-file-coding-system'
     The coding system used when reading and writing the `nnrss'
     groups data files.  The default is the value of
     `mm-universal-coding-system' (which defaults to `emacs-mule' in
     Emacs or `escape-quoted' in XEmacs).

`nnrss-ignore-article-fields'
     Some feeds update constantly article fields during their publications,
     e.g. to indicate the number of comments.  However, if there is
     a difference between the local article and the distant one, the latter
     is considered to be new.  To avoid this and discard some fields, set this
     variable to the list of fields to be ignored.  The default is
     `'(slash:comments)'.

`nnrss-use-local'
     If you set `nnrss-use-local' to `t', `nnrss' will read the feeds
     from local files in `nnrss-directory'.  You can use the command
     `nnrss-generate-download-script' to generate a download script
     using `wget'.

`nnrss-wash-html-in-text-plain-parts'
     Non-`nil' means that `nnrss' renders text in `text/plain'
     parts as HTML.  The function specified by the
     `mm-text-html-renderer' variable (*Note Display Customization: (emacs-mime)Display Customization.) will be used
     to render text.  If it is `nil', which is the default, text will
     simply be folded.  Leave it `nil' if you prefer to see
     `text/html' parts.

The following code may be helpful, if you want to show the description
in the summary buffer.

     (add-to-list 'nnmail-extra-headers nnrss-description-field)
     (setq gnus-summary-line-format "%U%R%z%I%(%[%4L: %-15,15f%]%) %s%uX\n")

     (defun gnus-user-format-function-X (header)
       (let ((descr
              (assq nnrss-description-field (mail-header-extra header))))
         (if descr (concat "\n\t" (cdr descr)) "")))

The following code may be useful to open an nnrss url directly from
the summary buffer.

     (require 'browse-url)

     (defun browse-nnrss-url (arg)
       (interactive "p")
       (let ((url (assq nnrss-url-field
                        (mail-header-extra
                         (gnus-data-header
                          (assq (gnus-summary-article-number)
                                gnus-newsgroup-data))))))
         (if url
             (progn
               (browse-url (cdr url))
               (gnus-summary-mark-as-read-forward 1))
           (gnus-summary-scroll-up arg))))

     (eval-after-load "gnus"
       #'(define-key gnus-summary-mode-map
           (kbd "<RET>") 'browse-nnrss-url))
     (add-to-list 'nnmail-extra-headers nnrss-url-field)

Even if you have added `text/html' to the
`mm-discouraged-alternatives' variable (*Note Display Customization: (emacs-mime)Display Customization.) since you don't want to see HTML parts, it might be
more useful especially in `nnrss' groups to display
`text/html' parts.  Here's an example of setting
`mm-discouraged-alternatives' as a group parameter (*Note Group Parameters::) in order to display `text/html' parts only in
`nnrss' groups:

     ;; Set the default value of `mm-discouraged-alternatives'.
     (eval-after-load "gnus-sum"
       '(add-to-list
         'gnus-newsgroup-variables
         '(mm-discouraged-alternatives
           . '("text/html" "image/.*"))))

     ;; Display `text/html' parts in `nnrss' groups.
     (add-to-list
      'gnus-parameters
      '("\\`nnrss:" (mm-discouraged-alternatives nil)))




File: gnus, Node: Customizing W3, Prev: RSS, Up: Browsing the Web

Customizing W3
--------------

Gnus uses the url library to fetch web pages and Emacs/W3 (or those
alternatives) to display web pages.  Emacs/W3 is documented in its own
manual, but there are some things that may be more relevant for Gnus
users.

For instance, a common question is how to make Emacs/W3 follow links
using the `browse-url' functions (which will call some external web
browser like Netscape).  Here's one way:

     (eval-after-load "w3"
       '(progn
         (fset 'w3-fetch-orig (symbol-function 'w3-fetch))
         (defun w3-fetch (&optional url target)
           (interactive (list (w3-read-url-with-default)))
           (if (eq major-mode 'gnus-article-mode)
               (browse-url url)
             (w3-fetch-orig url target)))))

Put that in your `.emacs' file, and hitting links in W3-rendered HTML
in the Gnus article buffers will use `browse-url' to follow the link.




File: gnus, Node: IMAP, Next: Other Sources, Prev: Browsing the Web, Up: Select Methods

IMAP
====

IMAP is a network protocol for reading mail (or news, or ...), think
of it as a modernized NNTP.  Connecting to a IMAP server is much
similar to connecting to a news server, you just specify the network
address of the server.

IMAP has two properties.  First, IMAP can do everything that POP can,
it can hence be viewed as a POP++.  Secondly, IMAP is a mail storage
protocol, similar to NNTP being a news storage protocol--however, IMAP
offers more features than NNTP because news is more or less read-only
whereas mail is read-write.

If you want to use IMAP as a POP++, use an imap entry in
`mail-sources'.  With this, Gnus will fetch mails from the IMAP server
and store them on the local disk.  This is not the usage described in
this section---*Note Mail Sources::.

If you want to use IMAP as a mail storage protocol, use an nnimap
entry in `gnus-secondary-select-methods'.  With this, Gnus will
manipulate mails stored on the IMAP server.  This is the kind of usage
explained in this section.

A server configuration in `~/.gnus.el' with a few IMAP servers might
look something like the following.  (Note that for TLS/SSL, you need
external programs and libraries, see below.)

     (setq gnus-secondary-select-methods
           '((nnimap "simpleserver") ; no special configuration
             ; perhaps a ssh port forwarded server:
             (nnimap "dolk"
                     (nnimap-address "localhost")
                     (nnimap-server-port 1430))
             ; a UW server running on localhost
             (nnimap "barbar"
                     (nnimap-server-port 143)
                     (nnimap-address "localhost")
                     (nnimap-list-pattern ("INBOX" "mail/*")))
             ; anonymous public cyrus server:
             (nnimap "cyrus.andrew.cmu.edu"
                     (nnimap-authenticator anonymous)
                     (nnimap-list-pattern "archive.*")
                     (nnimap-stream network))
             ; a ssl server on a non-standard port:
             (nnimap "vic20"
                     (nnimap-address "vic20.somewhere.com")
                     (nnimap-server-port 9930)
                     (nnimap-stream ssl))))

After defining the new server, you can subscribe to groups on the
server using normal Gnus commands such as `U' in the Group Buffer
(*Note Subscription Commands::) or via the Server Buffer (*Note Server
Buffer::).

The following variables can be used to create a virtual `nnimap'
server:


`nnimap-address'

     The address of the remote IMAP server.  Defaults to the virtual
     server name if not specified.

`nnimap-server-port'
     Port on server to contact.  Defaults to port 143, or 993 for
     TLS/SSL.

     Note that this should be an integer, example server
     specification:

          (nnimap "mail.server.com"
                  (nnimap-server-port 4711))

`nnimap-list-pattern'
     String or list of strings of mailboxes to limit available groups to.
     This is used when the server has very many mailboxes and you're only
     interested in a few--some servers export your home directory via
     IMAP, you'll probably want to limit the mailboxes to those in
     `~/Mail/*' then.

     The string can also be a cons of REFERENCE and the string as
     above, what REFERENCE is used for is server specific, but on the
     University of Washington server it's a directory that will be
     concatenated with the mailbox.

     Example server specification:

          (nnimap "mail.server.com"
                  (nnimap-list-pattern ("INBOX" "Mail/*" "alt.sex.*"
                                         ("~friend/Mail/" . "list/*"))))

`nnimap-stream'
     The type of stream used to connect to your server.  By default,
     nnimap will detect and automatically use all of the below, with
     the exception of TLS/SSL.  (IMAP over TLS/SSL is being replaced
     by STARTTLS, which can be automatically detected, but it's not
     widely deployed yet.)

     Example server specification:

          (nnimap "mail.server.com"
                  (nnimap-stream ssl))

     Please note that the value of `nnimap-stream' is a symbol!

        * "gssapi:" Connect with GSSAPI (usually Kerberos 5).  Requires the
          `gsasl' or `imtest' program.
        * "kerberos4:" Connect with Kerberos 4.  Requires the `imtest' program.
        * "starttls:" Connect via the STARTTLS extension (similar to
          TLS/SSL).  Requires the external library `starttls.el' and program
          `starttls'.
        * "tls:" Connect through TLS.  Requires GNUTLS (the program
          `gnutls-cli').
        * "ssl:" Connect through SSL.  Requires OpenSSL (the program
          `openssl') or SSLeay (`s_client').
        * "shell:" Use a shell command to start IMAP connection.
        * "network:" Plain, TCP/IP network connection.

     The `imtest' program is shipped with Cyrus IMAPD.  If you're
     using `imtest' from Cyrus IMAPD < 2.0.14 (which includes version
     1.5.x and 1.6.x) you need to frob `imap-process-connection-type'
     to make `imap.el' use a pty instead of a pipe when communicating
     with `imtest'.  You will then suffer from a line length
     restrictions on IMAP commands, which might make Gnus seem to hang
     indefinitely if you have many articles in a mailbox.  The
     variable `imap-kerberos4-program' contain parameters to pass to
     the imtest program.

     For TLS connection, the `gnutls-cli' program from GNUTLS is
     needed.  It is available from
     `http://www.gnu.org/software/gnutls/'.

     This parameter specifies a list of command lines that invoke a
     GSSAPI authenticated IMAP stream in a subshell.  They are tried
     sequentially until a connection is made, or the list has been
     exhausted.  By default, `gsasl' from GNU SASL, available from
     `http://www.gnu.org/software/gsasl/', and the `imtest' program
     from Cyrus IMAPD (see `imap-kerberos4-program'), are tried.

     For SSL connections, the OpenSSL program is available from
     `http://www.openssl.org/'.  OpenSSL was formerly known as SSLeay,
     and nnimap support it too--although the most recent versions of
     SSLeay, 0.9.x, are known to have serious bugs making it useless.
     Earlier versions, especially 0.8.x, of SSLeay are known to work.
     The variable `imap-ssl-program' contain parameters to pass to
     OpenSSL/SSLeay.

     For IMAP connections using the `shell' stream, the variable
     `imap-shell-program' specify what program to call.  Make sure
     nothing is interfering with the output of the program, e.g.,
     don't forget to redirect the error output to the void.

`nnimap-authenticator'

     The authenticator used to connect to the server.  By default,
     nnimap will use the most secure authenticator your server is
     capable of.

     Example server specification:

          (nnimap "mail.server.com"
                  (nnimap-authenticator anonymous))

     Please note that the value of `nnimap-authenticator' is a symbol!

        * "gssapi:" GSSAPI (usually kerberos 5) authentication.
          Requires external program `gsasl' or `imtest'.
        * "kerberos4:" Kerberos 4 authentication.  Requires external program
          `imtest'.
        * "digest-md5:" Encrypted username/password via DIGEST-MD5.
          Requires external library `digest-md5.el'.
        * "cram-md5:" Encrypted username/password via CRAM-MD5.
        * "login:" Plain-text username/password via LOGIN.
        * "anonymous:" Login as "anonymous", supplying your email address as password.

`nnimap-expunge-on-close'
     Unlike Parmenides the IMAP designers have decided things that
     don't exist actually do exist.  More specifically, IMAP has this
     concept of marking articles `Deleted' which doesn't actually
     delete them, and this (marking them `Deleted', that is) is what
     nnimap does when you delete an article in Gnus (with `B DEL' or
     similar).

     Since the articles aren't really removed when we mark them with
     the `Deleted' flag we'll need a way to actually delete them.
     Feel like running in circles yet?

     Traditionally, nnimap has removed all articles marked as
     `Deleted' when closing a mailbox but this is now configurable by
     this server variable.

     The possible options are:


     `always'
          The default behavior, delete all articles marked as
          Deleted" when closing a mailbox.
     `never'
          Never actually delete articles.  Currently there is no way
          of showing the articles marked for deletion in nnimap, but
          other IMAP clients may allow you to do this.  If you ever
          want to run the EXPUNGE command manually, *Note Expunging
          mailboxes::.
     `ask'
          When closing mailboxes, nnimap will ask if you wish to
          expunge deleted articles or not.


`nnimap-importantize-dormant'

     If non-`nil' (the default), marks dormant articles as ticked (as
     well), for other IMAP clients.  Within Gnus, dormant articles
     will naturally still (only) be marked as dormant.  This is to
     make dormant articles stand out, just like ticked articles, in
     other IMAP clients.  (In other words, Gnus has two "Tick" marks
     and IMAP has only one.)

     Probably the only reason for frobbing this would be if you're
     trying enable per-user persistent dormant flags, using something
     like:

          (setcdr (assq 'dormant nnimap-mark-to-flag-alist)
                  (format "gnus-dormant-%s" (user-login-name)))
          (setcdr (assq 'dormant nnimap-mark-to-predicate-alist)
                  (format "KEYWORD gnus-dormant-%s" (user-login-name)))

     In this case, you would not want the per-user dormant flag
     showing up as ticked for other users.

`nnimap-expunge-search-string'

     This variable contain the IMAP search command sent to server when
     searching for articles eligible for expiring.  The default is
     `"UID %s NOT SINCE %s"', where the first `%s' is replaced by UID
     set and the second `%s' is replaced by a date.

     Probably the only useful value to change this to is `"UID %s NOT
     SENTSINCE %s"', which makes nnimap use the Date: in messages
     instead of the internal article date.  See section 6.4.4 of RFC
     2060 for more information on valid strings.

     However, if `nnimap-search-uids-not-since-is-evil' is true, this
     variable has no effect since the search logic is reversed, as
     described below.

`nnimap-authinfo-file'

     A file containing credentials used to log in on servers.  The format is
     (almost) the same as the `ftp' `~/.netrc' file.  See the
     variable `nntp-authinfo-file' for exact syntax; also see
     *Note NNTP::.  An example of an .authinfo line for an IMAP server, is:

          machine students.uio.no login larsi password geheimnis port imap

     Note that it should be `port imap', or `port 143', if you
     use a `nnimap-stream' of `tls' or `ssl', even if the
     actual port number used is port 993 for secured IMAP.  For
     convenience, Gnus will accept `port imaps' as a synonym of
     `port imap'.

`nnimap-need-unselect-to-notice-new-mail'

     Unselect mailboxes before looking for new mail in them.  Some
     servers seem to need this under some circumstances; it was
     reported that Courier 1.7.1 did.

`nnimap-nov-is-evil'

     Never generate or use a local NOV database. Defaults to the value
     of `gnus-agent'.

     Using a NOV database usually makes header fetching much faster,
     but it uses the `UID SEARCH UID' command, which is very slow on
     some servers (notably some versions of Courier). Since the Gnus
     Agent caches the information in the NOV database without using
     the slow command, this variable defaults to true if the Agent is
     in use, and false otherwise.

`nnimap-search-uids-not-since-is-evil'

     Avoid the `UID SEARCH UID MESSAGE NUMBERS NOT SINCE
     DATE' command, which is slow on some IMAP servers
     (notably, some versions of Courier). Instead, use `UID SEARCH SINCE
     DATE' and prune the list of expirable articles within Gnus.

     When Gnus expires your mail (*Note Expiring Mail::), it starts
     with a list of expirable articles and asks the IMAP server
     questions like "Of these articles, which ones are older than a
     week?" While this seems like a perfectly reasonable question,
     some IMAP servers take a long time to answer it, since they
     seemingly go looking into every old article to see if it is one
     of the expirable ones. Curiously, the question "Of *all*
     articles, which ones are newer than a week?" seems to be much
     faster to answer, so setting this variable causes Gnus to ask
     this question and figure out the answer to the real question
     itself.

     This problem can really sneak up on you: when you first configure
     Gnus, everything works fine, but once you accumulate a couple
     thousand messages, you start cursing Gnus for being so slow. On
     the other hand, if you get a lot of email within a week, setting
     this variable will cause a lot of network traffic between Gnus
     and the IMAP server.

`nnimap-logout-timeout'

     There is a case where a connection to a IMAP server is unable to
     close, when connecting to the server via a certain kind of
     network, e.g. VPN.  In that case, it will be observed that a
     connection between Emacs and the local network looks alive even
     if the server has closed a connection for some reason (typically,
     a timeout).  Consequently, Emacs continues waiting for a response
     from the server for the `LOGOUT' command that Emacs sent, or
     hangs in other words.  If you are in such a network, setting this
     variable to a number of seconds will be helpful.  If it is set, a
     hung connection will be closed forcibly, after this number of
     seconds from the time Emacs sends the `LOGOUT' command.  It
     should not be too small value but too large value will be
     inconvenient too.  Perhaps the value 1.0 will be a good candidate
     but it might be worth trying some other values.

     Example server specification:

          (nnimap "mail.server.com"
                  (nnimap-logout-timeout 1.0))


* Menu:

* Splitting in IMAP::           Splitting mail with nnimap.
* Expiring in IMAP::            Expiring mail with nnimap.
* Editing IMAP ACLs::           Limiting/enabling other users access to a mailbox.
* Expunging mailboxes::         Equivalent of a "compress mailbox" button.
* A note on namespaces::        How to (not) use IMAP namespace in Gnus.
* Debugging IMAP::              What to do when things don't work.





File: gnus, Node: Splitting in IMAP, Next: Expiring in IMAP, Prev: IMAP, Up: IMAP

Splitting in IMAP
-----------------

Splitting is something Gnus users have loved and used for years, and now
the rest of the world is catching up.  Yeah, dream on, not many
IMAP servers have server side splitting and those that have
splitting seem to use some non-standard protocol.  This means that
IMAP support for Gnus has to do its own splitting.

And it does.

(Incidentally, people seem to have been dreaming on, and Sieve has
gaining a market share and is supported by several IMAP servers.
Fortunately, Gnus support it too, *Note Sieve Commands::.)

Here are the variables of interest:


`nnimap-split-crosspost'

     If non-`nil', do crossposting if several split methods match the
     mail.  If `nil', the first match in `nnimap-split-rule' found
     will be used.

     Nnmail equivalent: `nnmail-crosspost'.

`nnimap-split-inbox'

     A string or a list of strings that gives the name(s) of IMAP
     mailboxes to split from.  Defaults to `nil', which means that
     splitting is disabled!

          (setq nnimap-split-inbox
                '("INBOX" ("~/friend/Mail" . "lists/*") "lists.imap"))

     No nnmail equivalent.

`nnimap-split-rule'

     New mail found in `nnimap-split-inbox' will be split according to
     this variable.

     This variable contains a list of lists, where the first element
     in the sublist gives the name of the IMAP mailbox to move
     articles matching the regexp in the second element in the
     sublist.  Got that?  Neither did I, we need examples.

          (setq nnimap-split-rule
                '(("INBOX.nnimap"
                   "^Sender: owner-nnimap@vic20.globalcom.se")
                  ("INBOX.junk"    "^Subject:.*MAKE MONEY")
                  ("INBOX.private" "")))

     This will put all articles from the nnimap mailing list into
     mailbox INBOX.nnimap, all articles containing MAKE MONEY in the
     Subject: line into INBOX.junk and everything else in
     INBOX.private.

     The first string may contain `\\1' forms, like the ones used by
     replace-match to insert sub-expressions from the matched text.
     For instance:

          ("INBOX.lists.\\1"     "^Sender: owner-\\([a-z-]+\\)@")

     The first element can also be the symbol `junk' to indicate that
     matching messages should simply be deleted.  Use with care.

     The second element can also be a function.  In that case, it will
     be called with the first element of the rule as the argument, in
     a buffer containing the headers of the article.  It should return
     a non-`nil' value if it thinks that the mail belongs in that
     group.

     Nnmail users might recollect that the last regexp had to be empty
     to match all articles (like in the example above).  This is not
     required in nnimap.  Articles not matching any of the regexps
     will not be moved out of your inbox.  (This might affect
     performance if you keep lots of unread articles in your inbox,
     since the splitting code would go over them every time you fetch
     new mail.)

     These rules are processed from the beginning of the alist toward
     the end.  The first rule to make a match will "win", unless you
     have crossposting enabled.  In that case, all matching rules will
     win".

     This variable can also have a function as its value, the function
     will be called with the headers narrowed and should return a
     group where it thinks the article should be split to.  See
     `nnimap-split-fancy'.

     The splitting code tries to create mailboxes if it needs to.

     To allow for different split rules on different virtual servers,
     and even different split rules in different inboxes on the same
     server, the syntax of this variable have been extended along the
     lines of:

          (setq nnimap-split-rule
                '(("my1server"    (".*" (("ding"    "ding@gnus.org")
                                         ("junk"    "From:.*Simon"))))
                  ("my2server"    ("INBOX" nnimap-split-fancy))
                  ("my[34]server" (".*" (("private" "To:.*Simon")
                                         ("junk"    my-junk-func))))))

     The virtual server name is in fact a regexp, so that the same
     rules may apply to several servers.  In the example, the servers
     `my3server' and `my4server' both use the same rules.  Similarly,
     the inbox string is also a regexp.  The actual splitting rules
     are as before, either a function, or a list with group/regexp or
     group/function elements.

     Nnmail equivalent: `nnmail-split-methods'.

`nnimap-split-predicate'

     Mail matching this predicate in `nnimap-split-inbox' will be
     split, it is a string and the default is `UNSEEN UNDELETED'.

     This might be useful if you use another IMAP client to read mail in
     your inbox but would like Gnus to split all articles in the inbox
     regardless of readedness.  Then you might change this to
     `UNDELETED'.

`nnimap-split-fancy'

     It's possible to set `nnimap-split-rule' to `nnmail-split-fancy'
     if you want to use fancy splitting.  *Note Fancy Mail
     Splitting::.

     However, to be able to have different fancy split rules for
     nnmail and nnimap back ends you can set `nnimap-split-rule' to
     `nnimap-split-fancy' and define the nnimap specific fancy split
     rule in `nnimap-split-fancy'.

     Example:

          (setq nnimap-split-rule 'nnimap-split-fancy
                nnimap-split-fancy ...)

     Nnmail equivalent: `nnmail-split-fancy'.

`nnimap-split-download-body'

     Set to non-`nil' to download entire articles during splitting.
     This is generally not required, and will slow things down
     considerably.  You may need it if you want to use an advanced
     splitting function that analyzes the body to split the article.




File: gnus, Node: Expiring in IMAP, Next: Editing IMAP ACLs, Prev: Splitting in IMAP, Up: IMAP

Expiring in IMAP
----------------

Even though `nnimap' is not a proper `nnmail' derived back end, it
supports most features in regular expiring (*Note Expiring Mail::).
Unlike splitting in IMAP (*Note Splitting in IMAP::) it does not clone
the `nnmail' variables (i.e., creating NNIMAP-EXPIRY-WAIT) but reuse
the `nnmail' variables.  What follows below are the variables used by
the `nnimap' expiry process.

A note on how the expire mark is stored on the IMAP server is
appropriate here as well.  The expire mark is translated into a `imap'
client specific mark, `gnus-expire', and stored on the message.  This
means that likely only Gnus will understand and treat the
`gnus-expire' mark properly, although other clients may allow you to
view client specific flags on the message.  It also means that your
server must support permanent storage of client specific flags on
messages.  Most do, fortunately.

If expiring IMAP mail seems very slow, try setting the server variable
`nnimap-search-uids-not-since-is-evil'.


`nnmail-expiry-wait'
`nnmail-expiry-wait-function'

     These variables are fully supported.  The expire value can be a
     number, the symbol `immediate' or `never'.

`nnmail-expiry-target'

     This variable is supported, and internally implemented by calling
     the `nnmail' functions that handle this.  It contains an
     optimization that if the destination is a IMAP group on the same
     server, the article is copied instead of appended (that is,
     uploaded again).




File: gnus, Node: Editing IMAP ACLs, Next: Expunging mailboxes, Prev: Expiring in IMAP, Up: IMAP

Editing IMAP ACLs
-----------------

ACL stands for Access Control List.  ACLs are used in IMAP for
limiting (or enabling) other users access to your mail boxes.  Not all
IMAP servers support this, this function will give an error if it
doesn't.

To edit an ACL for a mailbox, type `G l'
(`gnus-group-edit-nnimap-acl') and you'll be presented with an ACL
editing window with detailed instructions.

Some possible uses:

   * Giving "anyone" the "lrs" rights (lookup, read, keep seen/unseen
     flags) on your mailing list mailboxes enables other users on the
     same server to follow the list without subscribing to it.
   * At least with the Cyrus server, you are required to give the user
     anyone" posting ("p") capabilities to have "plussing" work (that
     is, mail sent to user+mailbox@domain ending up in the IMAP
     mailbox INBOX.mailbox).



File: gnus, Node: Expunging mailboxes, Next: A note on namespaces, Prev: Editing IMAP ACLs, Up: IMAP

Expunging mailboxes
-------------------


If you're using the `never' setting of `nnimap-expunge-on-close', you
may want the option of expunging all deleted articles in a mailbox
manually.  This is exactly what `G x' does.

Currently there is no way of showing deleted articles, you can just
delete them.



File: gnus, Node: A note on namespaces, Next: Debugging IMAP, Prev: Expunging mailboxes, Up: IMAP

A note on namespaces
--------------------

The IMAP protocol has a concept called namespaces, described by the
following text in the RFC2060:

     5.1.2.  Mailbox Namespace Naming Convention

        By convention, the first hierarchical element of any mailbox name
        which begins with "#" identifies the "namespace" of the remainder of
        the name.  This makes it possible to disambiguate between different
        types of mailbox stores, each of which have their own namespaces.

           For example, implementations which offer access to USENET
           newsgroups MAY use the "#news" namespace to partition the USENET
           newsgroup namespace from that of other mailboxes.  Thus, the
           comp.mail.misc newsgroup would have an mailbox name of
           "#news.comp.mail.misc", and the name "comp.mail.misc" could refer
           to a different object (e.g. a user's private mailbox).

While there is nothing in this text that warrants concern for the IMAP
implementation in Gnus, some servers use namespace prefixes in a way
that does not work with how Gnus uses mailbox names.

Specifically, University of Washington's IMAP server uses mailbox
names like `#driver.mbx/read-mail' which are valid only in the CREATE
and APPEND commands.  After the mailbox is created (or a messages is
appended to a mailbox), it must be accessed without the namespace
prefix, i.e. `read-mail'.  Since Gnus do not make it possible for the
user to guarantee that user entered mailbox names will only be used
with the CREATE and APPEND commands, you should simply not use the
namespace prefixed mailbox names in Gnus.

See the UoW IMAPD documentation for the `#driver.*/' prefix for more
information on how to use the prefixes.  They are a power tool and
should be used only if you are sure what the effects are.



File: gnus, Node: Debugging IMAP, Prev: A note on namespaces, Up: IMAP

Debugging IMAP
--------------

IMAP is a complex protocol, more so than NNTP or POP3.  Implementation
bugs are not unlikely, and we do our best to fix them right away.  If
you encounter odd behavior, chances are that either the server or Gnus
is buggy.

If you are familiar with network protocols in general, you will
probably be able to extract some clues from the protocol dump of the
exchanges between Gnus and the server.  Even if you are not familiar
with network protocols, when you include the protocol dump in
IMAP-related bug reports you are helping us with data critical to
solving the problem.  Therefore, we strongly encourage you to include
the protocol dump when reporting IMAP bugs in Gnus.


Because the protocol dump, when enabled, generates lots of data, it is
disabled by default.  You can enable it by setting `imap-log' as
follows:

     (setq imap-log t)

This instructs the `imap.el' package to log any exchanges with the
server.  The log is stored in the buffer `*imap-log*'.  Look for error
messages, which sometimes are tagged with the keyword `BAD'---but when
submitting a bug, make sure to include all the data.



File: gnus, Node: Other Sources, Next: Combined Groups, Prev: IMAP, Up: Select Methods

Other Sources
=============

Gnus can do more than just read news or mail.  The methods described
below allow Gnus to view directories and files as if they were
newsgroups.

* Menu:

* Directory Groups::            You can read a directory as if it was a newsgroup.
* Anything Groups::             Dired?  Who needs dired?
* Document Groups::             Single files can be the basis of a group.
* SOUP::                        Reading SOUP packets "offline".
* Mail-To-News Gateways::       Posting articles via mail-to-news gateways.




File: gnus, Node: Directory Groups, Next: Anything Groups, Prev: Other Sources, Up: Other Sources

Directory Groups
----------------

If you have a directory that has lots of articles in separate files in
it, you might treat it as a newsgroup.  The files have to have
numerical names, of course.

This might be an opportune moment to mention `ange-ftp' (and its
successor `efs'), that most wonderful of all wonderful Emacs packages.
When I wrote `nndir', I didn't think much about it--a back end to read
directories.  Big deal.

`ange-ftp' changes that picture dramatically.  For instance, if you
enter the `ange-ftp' file name `/ftp.hpc.uh.edu:/pub/emacs/ding-list/'
as the directory name, `ange-ftp' or `efs' will actually allow you to
read this directory over at `sina' as a newsgroup.  Distributed news
ahoy!

`nndir' will use NOV files if they are present.

`nndir' is a "read-only" back end--you can't delete or expire articles
with this method.  You can use `nnmh' or `nnml' for whatever you use
`nndir' for, so you could switch to any of those methods if you feel
the need to have a non-read-only `nndir'.




File: gnus, Node: Anything Groups, Next: Document Groups, Prev: Directory Groups, Up: Other Sources

Anything Groups
---------------

From the `nndir' back end (which reads a single spool-like directory),
it's just a hop and a skip to `nneething', which pretends that any
arbitrary directory is a newsgroup.  Strange, but true.

When `nneething' is presented with a directory, it will scan this
directory and assign article numbers to each file.  When you enter
such a group, `nneething' must create "headers" that Gnus can use.
After all, Gnus is a newsreader, in case you're forgetting.
`nneething' does this in a two-step process.  First, it snoops each
file in question.  If the file looks like an article (i.e., the first
few lines look like headers), it will use this as the head.  If this
is just some arbitrary file without a head (e.g. a C source file),
`nneething' will cobble up a header out of thin air.  It will use file
ownership, name and date and do whatever it can with these elements.

All this should happen automatically for you, and you will be
presented with something that looks very much like a newsgroup.
Totally like a newsgroup, to be precise.  If you select an article, it
will be displayed in the article buffer, just as usual.

If you select a line that represents a directory, Gnus will pop you
into a new summary buffer for this `nneething' group.  And so on.  You
can traverse the entire disk this way, if you feel like, but remember
that Gnus is not dired, really, and does not intend to be, either.

There are two overall modes to this action--ephemeral or solid.  When
doing the ephemeral thing (i.e., `G D' from the group buffer), Gnus
will not store information on what files you have read, and what files
are new, and so on.  If you create a solid `nneething' group the
normal way with `G m', Gnus will store a mapping table between article
numbers and file names, and you can treat this group like any other
groups.  When you activate a solid `nneething' group, you will be told
how many unread articles it contains, etc., etc.

Some variables:

`nneething-map-file-directory'
     All the mapping files for solid `nneething' groups will be stored
     in this directory, which defaults to `~/.nneething/'.

`nneething-exclude-files'
     All files that match this regexp will be ignored.  Nice to use to
     exclude auto-save files and the like, which is what it does by
     default.

`nneething-include-files'
     Regexp saying what files to include in the group.  If this
     variable is non-`nil', only files matching this regexp will be
     included.

`nneething-map-file'
     Name of the map files.




File: gnus, Node: Document Groups, Next: SOUP, Prev: Anything Groups, Up: Other Sources

Document Groups
---------------

`nndoc' is a cute little thing that will let you read a single file as
a newsgroup.  Several files types are supported:

`babyl'
     The Babyl (Rmail) mail box.

`mbox'
     The standard Unix mbox file.

`mmdf'
     The MMDF mail box format.

`news'
     Several news articles appended into a file.

`rnews'
     The rnews batch transport format.

`nsmail'
     Netscape mail boxes.

`mime-parts'
     MIME multipart messages.

`standard-digest'
     The standard (RFC 1153) digest format.

`mime-digest'
     A MIME digest of messages.

`lanl-gov-announce'
     Announcement messages from LANL Gov Announce.

`rfc822-forward'
     A message forwarded according to RFC822.

`outlook'
     The Outlook mail box.

`oe-dbx'
     The Outlook Express dbx mail box.

`exim-bounce'
     A bounce message from the Exim MTA.

`forward'
     A message forwarded according to informal rules.

`rfc934'
     An RFC934-forwarded message.

`mailman'
     A mailman digest.

`clari-briefs'
     A digest of Clarinet brief news items.

`slack-digest'
     Non-standard digest format--matches most things, but does it
     badly.

`mail-in-mail'
     The last resort.

You can also use the special "file type" `guess', which means that
`nndoc' will try to guess what file type it is looking at.  `digest'
means that `nndoc' should guess what digest type the file is.

`nndoc' will not try to change the file or insert any extra headers
into it--it will simply, like, let you use the file as the basis for a
group.  And that's it.

If you have some old archived articles that you want to insert into
your new & spiffy Gnus mail back end, `nndoc' can probably help you
with that.  Say you have an old `RMAIL' file with mail that you now
want to split into your new `nnml' groups.  You look at that file
using `nndoc' (using the `G f' command in the group buffer (*Note
Foreign Groups::)), set the process mark on all the articles in the
buffer (`M P b', for instance), and then re-spool (`B r') using
`nnml'.  If all goes well, all the mail in the `RMAIL' file is now
also stored in lots of `nnml' directories, and you can delete that
pesky `RMAIL' file.  If you have the guts!

Virtual server variables:

`nndoc-article-type'
     This should be one of `mbox', `babyl', `digest',
     `news', `rnews', `mmdf', `forward', `rfc934',
     `rfc822-forward', `mime-parts', `standard-digest',
     `slack-digest', `clari-briefs', `nsmail', `outlook',
     `oe-dbx', `mailman', and `mail-in-mail' or `guess'.

`nndoc-post-type'
     This variable says whether Gnus is to consider the group a news
     group or a mail group.  There are two valid values: `mail' (the
     default) and `news'.

* Menu:

* Document Server Internals::   How to add your own document types.




File: gnus, Node: Document Server Internals, Prev: Document Groups, Up: Document Groups

Document Server Internals
.........................

Adding new document types to be recognized by `nndoc' isn't difficult.
You just have to whip up a definition of what the document looks like,
write a predicate function to recognize that document type, and then
hook into `nndoc'.

First, here's an example document type definition:

     (mmdf
      (article-begin .  "^\^A\^A\^A\^A\n")
      (body-end .  "^\^A\^A\^A\^A\n"))

The definition is simply a unique "name" followed by a series of
regexp pseudo-variable settings.  Below are the possible
variables--don't be daunted by the number of variables; most document
types can be defined with very few settings:

`first-article'
     If present, `nndoc' will skip past all text until it finds
     something that match this regexp.  All text before this will be
     totally ignored.

`article-begin'
     This setting has to be present in all document type definitions.
     It says what the beginning of each article looks like.  To do
     more complicated things that cannot be dealt with a simple
     regexp, you can use `article-begin-function' instead of this.

`article-begin-function'
     If present, this should be a function that moves point to the
     beginning of each article.  This setting overrides
     `article-begin'.

`head-begin'
     If present, this should be a regexp that matches the head of the
     article.  To do more complicated things that cannot be dealt with
     a simple regexp, you can use `head-begin-function' instead of
     this.

`head-begin-function'
     If present, this should be a function that moves point to the
     head of the article.  This setting overrides `head-begin'.

`head-end'
     This should match the end of the head of the article.  It defaults to
     `^$'---the empty line.

`body-begin'
     This should match the beginning of the body of the article.  It
     defaults to `^\n'.  To do more complicated things that cannot be
     dealt with a simple regexp, you can use `body-begin-function'
     instead of this.

`body-begin-function'
     If present, this function should move point to the beginning of
     the body of the article.  This setting overrides `body-begin'.

`body-end'
     If present, this should match the end of the body of the article.
     To do more complicated things that cannot be dealt with a simple
     regexp, you can use `body-end-function' instead of this.

`body-end-function'
     If present, this function should move point to the end of the
     body of the article.  This setting overrides `body-end'.

`file-begin'
     If present, this should match the beginning of the file.  All
     text before this regexp will be totally ignored.

`file-end'
     If present, this should match the end of the file.  All text
     after this regexp will be totally ignored.


So, using these variables `nndoc' is able to dissect a document file
into a series of articles, each with a head and a body.  However, a
few more variables are needed since not all document types are all
that news-like--variables needed to transform the head or the body
into something that's palatable for Gnus:

`prepare-body-function'
     If present, this function will be called when requesting an
     article.  It will be called with point at the start of the body,
     and is useful if the document has encoded some parts of its
     contents.

`article-transform-function'
     If present, this function is called when requesting an article.
     It's meant to be used for more wide-ranging transformation of
     both head and body of the article.

`generate-head-function'
     If present, this function is called to generate a head that Gnus
     can understand.  It is called with the article number as a
     parameter, and is expected to generate a nice head for the
     article in question.  It is called when requesting the headers of
     all articles.

`generate-article-function'
     If present, this function is called to generate an entire article
     that Gnus can understand.  It is called with the article number
     as a parameter when requesting all articles.

`dissection-function'
     If present, this function is called to dissect a document by itself,
     overriding `first-article', `article-begin',
     `article-begin-function', `head-begin',
     `head-begin-function', `head-end', `body-begin',
     `body-begin-function', `body-end', `body-end-function',
     `file-begin', and `file-end'.


Let's look at the most complicated example I can come up
with--standard digests:

     (standard-digest
      (first-article . ,(concat "^" (make-string 70 ?-) "\n\n+"))
      (article-begin . ,(concat "\n\n" (make-string 30 ?-) "\n\n+"))
      (prepare-body-function . nndoc-unquote-dashes)
      (body-end-function . nndoc-digest-body-end)
      (head-end . "^ ?$")
      (body-begin . "^ ?\n")
      (file-end . "^End of .*digest.*[0-9].*\n\\*\\*\\|^End of.*Digest *$")
      (subtype digest guess))

We see that all text before a 70-width line of dashes is ignored; all
text after a line that starts with that `^End of' is also ignored;
each article begins with a 30-width line of dashes; the line
separating the head from the body may contain a single space; and that
the body is run through `nndoc-unquote-dashes' before being delivered.

To hook your own document definition into `nndoc', use the
`nndoc-add-type' function.  It takes two parameters--the first is the
definition itself and the second (optional) parameter says where in
the document type definition alist to put this definition.  The alist
is traversed sequentially, and `nndoc-TYPE-type-p' is called for a
given type TYPE.  So `nndoc-mmdf-type-p' is called to see whether a
document is of `mmdf' type, and so on.  These type predicates should
return `nil' if the document is not of the correct type; `t' if it is
of the correct type; and a number if the document might be of the
correct type.  A high number means high probability; a low number
means low probability with `0' being the lowest valid number.




File: gnus, Node: SOUP, Next: Mail-To-News Gateways, Prev: Document Groups, Up: Other Sources

SOUP
----

In the PC world people often talk about "offline" newsreaders.  These
are thingies that are combined reader/news transport monstrosities.
With built-in modem programs.  Yecchh!

Of course, us Unix Weenie types of human beans use things like `uucp'
and, like, `nntpd' and set up proper news and mail transport things
like Ghod intended.  And then we just use normal newsreaders.

However, it can sometimes be convenient to do something that's a bit
easier on the brain if you have a very slow modem, and you're not
really that interested in doing things properly.

A file format called SOUP has been developed for transporting news and
mail from servers to home machines and back again.  It can be a bit
fiddly.

First some terminology:


"server"
     This is the machine that is connected to the outside world and
     where you get news and/or mail from.

"home machine"
     This is the machine that you want to do the actual reading and
     responding on.  It is typically not connected to the rest of the
     world in any way.

"packet"
     Something that contains messages and/or commands.  There are two
     kinds of packets:

     "message packets"
          These are packets made at the server, and typically contain
          lots of messages for you to read.  These are called
          `SoupoutX.tgz' by default, where X is a number.

     "response packets"
          These are packets made at the home machine, and typically
          contains replies that you've written.  These are called
          `SoupinX.tgz' by default, where X is a number.





  1. You log in on the server and create a SOUP packet.  You can
     either use a dedicated SOUP thingie (like the `awk' program), or
     you can use Gnus to create the packet with its SOUP commands (`O
     s' and/or `G s b'; and then `G s p') (*Note SOUP Commands::).

  2. You transfer the packet home.  Rail, boat, car or modem will do
     fine.

  3. You put the packet in your home directory.

  4. You fire up Gnus on your home machine using the `nnsoup' back end
     as the native or secondary server.

  5. You read articles and mail and answer and followup to the things
     you want (*Note SOUP Replies::).

  6. You do the `G s r' command to pack these replies into a SOUP
     packet.

  7. You transfer this packet to the server.

  8. You use Gnus to mail this packet out with the `G s s' command.

  9. You then repeat until you die.


So you basically have a bipartite system--you use `nnsoup' for reading
and Gnus for packing/sending these SOUP packets.

* Menu:

* SOUP Commands::               Commands for creating and sending SOUP packets
* SOUP Groups::                 A back end for reading SOUP packets.
* SOUP Replies::                How to enable `nnsoup' to take over mail and news.




File: gnus, Node: SOUP Commands, Next: SOUP Groups, Prev: SOUP, Up: SOUP

SOUP Commands
.............

These are commands for creating and manipulating SOUP packets.

`G s b'
     Pack all unread articles in the current group
     (`gnus-group-brew-soup').  This command understands the
     process/prefix convention.

`G s w'
     Save all SOUP data files (`gnus-soup-save-areas').

`G s s'
     Send all replies from the replies packet
     (`gnus-soup-send-replies').

`G s p'
     Pack all files into a SOUP packet (`gnus-soup-pack-packet').

`G s r'
     Pack all replies into a replies packet (`nnsoup-pack-replies').

`O s'
     This summary-mode command adds the current article to a SOUP
     packet (`gnus-soup-add-article').  It understands the
     process/prefix convention (*Note Process/Prefix::).



There are a few variables to customize where Gnus will put all these
thingies:


`gnus-soup-directory'
     Directory where Gnus will save intermediate files while composing
     SOUP packets.  The default is `~/SoupBrew/'.

`gnus-soup-replies-directory'
     This is what Gnus will use as a temporary directory while sending
     our reply packets.  `~/SoupBrew/SoupReplies/' is the default.

`gnus-soup-prefix-file'
     Name of the file where Gnus stores the last used prefix.  The default is
     `gnus-prefix'.

`gnus-soup-packer'
     A format string command for packing a SOUP packet.  The default is
     `tar cf - %s | gzip > $HOME/Soupout%d.tgz'.

`gnus-soup-unpacker'
     Format string command for unpacking a SOUP packet.  The default is
     `gunzip -c %s | tar xvf -'.

`gnus-soup-packet-directory'
     Where Gnus will look for reply packets.  The default is `~/'.

`gnus-soup-packet-regexp'
     Regular expression matching SOUP reply packets in
     `gnus-soup-packet-directory'.





File: gnus, Node: SOUP Groups, Next: SOUP Replies, Prev: SOUP Commands, Up: SOUP

SOUP Groups
...........

`nnsoup' is the back end for reading SOUP packets.  It will read
incoming packets, unpack them, and put them in a directory where you
can read them at leisure.

These are the variables you can use to customize its behavior:


`nnsoup-tmp-directory'
     When `nnsoup' unpacks a SOUP packet, it does it in this
     directory.  (`/tmp/' by default.)

`nnsoup-directory'
     `nnsoup' then moves each message and index file to this
     directory.  The default is `~/SOUP/'.

`nnsoup-replies-directory'
     All replies will be stored in this directory before being packed
     into a reply packet.  The default is `~/SOUP/replies/'.

`nnsoup-replies-format-type'
     The SOUP format of the replies packets.  The default is `?n'
     (rnews), and I don't think you should touch that variable.  I
     probably shouldn't even have documented it.  Drats!  Too late!

`nnsoup-replies-index-type'
     The index type of the replies packet.  The default is `?n', which
     means "none".  Don't fiddle with this one either!

`nnsoup-active-file'
     Where `nnsoup' stores lots of information.  This is not an "active
     file" in the `nntp' sense; it's an Emacs Lisp file.  If you lose
     this file or mess it up in any way, you're dead.  The default is
     `~/SOUP/active'.

`nnsoup-packer'
     Format string command for packing a reply SOUP packet.  The
     default is `tar cf - %s | gzip > $HOME/Soupin%d.tgz'.

`nnsoup-unpacker'
     Format string command for unpacking incoming SOUP packets.  The
     default is `gunzip -c %s | tar xvf -'.

`nnsoup-packet-directory'
     Where `nnsoup' will look for incoming packets.  The default is
     `~/'.

`nnsoup-packet-regexp'
     Regular expression matching incoming SOUP packets.  The default is
     `Soupout'.

`nnsoup-always-save'
     If non-`nil', save the replies buffer after each posted message.





File: gnus, Node: SOUP Replies, Prev: SOUP Groups, Up: SOUP

SOUP Replies
............

Just using `nnsoup' won't mean that your postings and mailings end up
in SOUP reply packets automagically.  You have to work a bit more for
that to happen.

The `nnsoup-set-variables' command will set the appropriate
variables to ensure that all your followups and replies end up in the
SOUP system.

In specific, this is what it does:

     (setq message-send-news-function 'nnsoup-request-post)
     (setq message-send-mail-function 'nnsoup-request-mail)

And that's it, really.  If you only want news to go into the SOUP
system you just use the first line.  If you only want mail to be
SOUPed you use the second.




File: gnus, Node: Mail-To-News Gateways, Prev: SOUP, Up: Other Sources

Mail-To-News Gateways
---------------------

If your local `nntp' server doesn't allow posting, for some reason or
other, you can post using one of the numerous mail-to-news gateways.
The `nngateway' back end provides the interface.

Note that you can't read anything from this back end--it can only be
used to post with.

Server variables:

`nngateway-address'
     This is the address of the mail-to-news gateway.

`nngateway-header-transformation'
     News headers often have to be transformed in some odd way or
     other for the mail-to-news gateway to accept it.  This variable
     says what transformation should be called, and defaults to
     `nngateway-simple-header-transformation'.  The function is called
     narrowed to the headers to be transformed and with one
     parameter--the gateway address.

     This default function just inserts a new `To' header based on the
     `Newsgroups' header and the gateway address.  For instance, an
     article with this `Newsgroups' header:

          Newsgroups: alt.religion.emacs

     will get this `To' header inserted:

          To: alt-religion-emacs@GATEWAY

     The following pre-defined functions exist:


     `nngateway-simple-header-transformation'
          Creates a `To' header that looks like
          NEWSGROUP@`nngateway-address'.


     `nngateway-mail2news-header-transformation'
          Creates a `To' header that looks like
          `nngateway-address'.


Here's an example:

     (setq gnus-post-method
           '(nngateway
             "mail2news@replay.com"
             (nngateway-header-transformation
              nngateway-mail2news-header-transformation)))

So, to use this, simply say something like:

     (setq gnus-post-method '(nngateway "GATEWAY.ADDRESS"))





File: gnus, Node: Combined Groups, Next: Email Based Diary, Prev: Other Sources, Up: Select Methods

Combined Groups
===============

Gnus allows combining a mixture of all the other group types into
bigger groups.

* Menu:

* Virtual Groups::              Combining articles from many groups.
* Kibozed Groups::              Looking through parts of the newsfeed for articles.




File: gnus, Node: Virtual Groups, Next: Kibozed Groups, Prev: Combined Groups, Up: Combined Groups

Virtual Groups
--------------

An "nnvirtual group" is really nothing more than a collection of other
groups.

For instance, if you are tired of reading many small groups, you can
put them all in one big group, and then grow tired of reading one big,
unwieldy group.  The joys of computing!

You specify `nnvirtual' as the method.  The address should be a regexp
to match component groups.

All marks in the virtual group will stick to the articles in the
component groups.  So if you tick an article in a virtual group, the
article will also be ticked in the component group from whence it
came.  (And vice versa--marks from the component groups will also be
shown in the virtual group.).  To create an empty virtual group, run
`G V' (`gnus-group-make-empty-virtual') in the group buffer and edit
the method regexp with `M-e' (`gnus-group-edit-group-method')

Here's an example `nnvirtual' method that collects all Andrea Dworkin
newsgroups into one, big, happy newsgroup:

     (nnvirtual "^alt\\.fan\\.andrea-dworkin$\\|^rec\\.dworkin.*")

The component groups can be native or foreign; everything should work
smoothly, but if your computer explodes, it was probably my fault.

Collecting the same group from several servers might actually be a
good idea if users have set the Distribution header to limit
distribution.  If you would like to read `soc.motss' both from a
server in Japan and a server in Norway, you could use the following as
the group regexp:

     "^nntp\\+server\\.jp:soc\\.motss$\\|^nntp\\+server\\.no:soc\\.motss$"

(Remember, though, that if you're creating the group with `G m', you
shouldn't double the backslashes, and you should leave off the quote
characters at the beginning and the end of the string.)

This should work kinda smoothly--all articles from both groups should
end up in this one, and there should be no duplicates.  Threading (and
the rest) will still work as usual, but there might be problems with
the sequence of articles.  Sorting on date might be an option here
(*Note Selecting a Group::).

One limitation, however--all groups included in a virtual group have
to be alive (i.e., subscribed or unsubscribed).  Killed or zombie
groups can't be component groups for `nnvirtual' groups.

If the `nnvirtual-always-rescan' variable is non-`nil' (which is the
default), `nnvirtual' will always scan groups for unread articles when
entering a virtual group.  If this variable is `nil' and you read
articles in a component group after the virtual group has been
activated, the read articles from the component group will show up
when you enter the virtual group.  You'll also see this effect if you
have two virtual groups that have a component group in common.  If
that's the case, you should set this variable to `t'.  Or you can just
tap `M-g' on the virtual group every time before you enter it--it'll
have much the same effect.

`nnvirtual' can have both mail and news groups as component groups.
When responding to articles in `nnvirtual' groups, `nnvirtual' has to
ask the back end of the component group the article comes from whether
it is a news or mail back end.  However, when you do a `^', there is
typically no sure way for the component back end to know this, and in
that case `nnvirtual' tells Gnus that the article came from a not-news
back end.  (Just to be on the safe side.)

`C-c C-n' in the message buffer will insert the `Newsgroups' line from
the article you respond to in these cases.

`nnvirtual' groups do not inherit anything but articles and marks from
component groups--group parameters, for instance, are not inherited.




File: gnus, Node: Kibozed Groups, Prev: Virtual Groups, Up: Combined Groups

Kibozed Groups
--------------

"Kibozing" is defined by the OED as "grepping through (parts of) the
news feed".  `nnkiboze' is a back end that will do this for you.  Oh
joy!  Now you can grind any NNTP server down to a halt with useless
requests!  Oh happiness!

To create a kibozed group, use the `G k' command in the group buffer.

The address field of the `nnkiboze' method is, as with
`nnvirtual', a regexp to match groups to be "included" in the
`nnkiboze' group.  That's where most similarities between
`nnkiboze' and `nnvirtual' end.

In addition to this regexp detailing component groups, an `nnkiboze'
group must have a score file to say what articles are to be included
in the group (*Note Scoring::).

You must run `M-x nnkiboze-generate-groups' after creating the
`nnkiboze' groups you want to have.  This command will take time.
Lots of time.  Oodles and oodles of time.  Gnus has to fetch the
headers from all the articles in all the component groups and run them
through the scoring process to determine if there are any articles in
the groups that are to be part of the `nnkiboze' groups.

Please limit the number of component groups by using restrictive
regexps.  Otherwise your sysadmin may become annoyed with you, and the
NNTP site may throw you off and never let you back in again.  Stranger
things have happened.

`nnkiboze' component groups do not have to be alive--they can be dead,
and they can be foreign.  No restrictions.

The generation of an `nnkiboze' group means writing two files in
`nnkiboze-directory', which is `~/News/kiboze/' by default.  One
contains the NOV header lines for all the articles in the group, and
the other is an additional `.newsrc' file to store information on what
groups have been searched through to find component articles.

Articles marked as read in the `nnkiboze' group will have their NOV
lines removed from the NOV file.




File: gnus, Node: Email Based Diary, Next: Gnus Unplugged, Prev: Combined Groups, Up: Select Methods

Email Based Diary
=================

This section describes a special mail back end called `nndiary', and
its companion library `gnus-diary'.  It is "special" in the sense that
it is not meant to be one of the standard alternatives for reading
mail with Gnus.  See *Note Choosing a Mail Back End:: for that.
Instead, it is used to treat *some* of your mails in a special way,
namely, as event reminders.

Here is a typical scenario:

   * You've got a date with Andy Mc Dowell or Bruce Willis (select
     according to your sexual preference) in one month.  You don't
     want to forget it.
   * So you send a "reminder" message (actually, a diary one) to
     yourself.
   * You forget all about it and keep on getting and reading new mail,
     as usual.
   * From time to time, as you type `g' in the group buffer and as the
     date is getting closer, the message will pop up again to remind
     you of your appointment, just as if it were new and unread.
   * Read your "new" messages, this one included, and start dreaming
     again of the night you're gonna have.
   * Once the date is over (you actually fell asleep just after
     dinner), the message will be automatically deleted if it is
     marked as expirable.

The Gnus Diary back end has the ability to handle regular appointments
(that wouldn't ever be deleted) as well as punctual ones, operates as
a real mail back end and is configurable in many ways.  All of this is
explained in the sections below.

* Menu:

* The NNDiary Back End::        Basic setup and usage.
* The Gnus Diary Library::      Utility toolkit on top of nndiary.
* Sending or Not Sending::      A final note on sending diary messages.




File: gnus, Node: The NNDiary Back End, Next: The Gnus Diary Library, Prev: Email Based Diary, Up: Email Based Diary

The NNDiary Back End
--------------------

`nndiary' is a back end very similar to `nnml' (*Note Mail Spool::).
Actually, it could appear as a mix of `nnml' and `nndraft'.  If you
know `nnml', you're already familiar with the message storing scheme
of `nndiary': one file per message, one directory per group.

  Before anything, there is one requirement to be able to run
`nndiary' properly: you *must* use the group timestamp feature of
Gnus.  This adds a timestamp to each group's parameters.  *Note Group
Timestamp:: to see how it's done.

* Menu:

* Diary Messages::              What makes a message valid for nndiary.
* Running NNDiary::             NNDiary has two modes of operation.
* Customizing NNDiary::         Bells and whistles.



File: gnus, Node: Diary Messages, Next: Running NNDiary, Prev: The NNDiary Back End, Up: The NNDiary Back End

Diary Messages
..............

`nndiary' messages are just normal ones, except for the mandatory
presence of 7 special headers.  These headers are of the form
`X-Diary-<something>', `<something>' being one of `Minute', `Hour',
`Dom', `Month', `Year', `Time-Zone' and `Dow'.  `Dom' means "Day of
Month", and `dow' means "Day of Week".  These headers actually behave
like crontab specifications and define the event date(s):

   * For all headers except the `Time-Zone' one, a header value is
     either a star (meaning all possible values), or a list of fields
     (separated by a comma).
   * A field is either an integer, or a range.
   * A range is two integers separated by a dash.
   * Possible integer values are 0--59 for `Minute', 0--23 for `Hour',
     1--31 for `Dom', 1--12 for `Month', above 1971 for `Year' and
     0--6 for `Dow' (0 meaning Sunday).
   * As a special case, a star in either `Dom' or `Dow' doesn't mean
     all possible values", but "use only the other field".  Note that
     if both are star'ed, the use of either one gives the same result.
   * The `Time-Zone' header is special in that it can only have one
     value (`GMT', for instance).  A star doesn't mean "all possible
     values" (because it makes no sense), but "the current local time
     zone".  Most of the time, you'll be using a star here.  However, for a
     list of available time zone values, see the variable
     `nndiary-headers'.

As a concrete example, here are the diary headers to add to your
message for specifying "Each Monday and each 1st of month, at 12:00,
20:00, 21:00, 22:00, 23:00 and 24:00, from 1999 to 2010" (I'll let you
find what to do then):

     X-Diary-Minute: 0
     X-Diary-Hour: 12, 20-24
     X-Diary-Dom: 1
     X-Diary-Month: *
     X-Diary-Year: 1999-2010
     X-Diary-Dow: 1
     X-Diary-Time-Zone: *



File: gnus, Node: Running NNDiary, Next: Customizing NNDiary, Prev: Diary Messages, Up: The NNDiary Back End

Running NNDiary
...............

`nndiary' has two modes of operation: "traditional" (the default) and
autonomous".  In traditional mode, `nndiary' does not get new mail by
itself.  You have to move (`B m') or copy (`B c') mails from your
primary mail back end to nndiary groups in order to handle them as
diary messages.  In autonomous mode, `nndiary' retrieves its own mail
and handles it independently from your primary mail back end.

One should note that Gnus is not inherently designed to allow several
master" mail back ends at the same time.  However, this does make
sense with `nndiary': you really want to send and receive diary
messages to your diary groups directly.  So, `nndiary' supports being
sort of a "second primary mail back end" (to my knowledge, it is the
only back end offering this feature).  However, there is a limitation
(which I hope to fix some day): respooling doesn't work in autonomous
mode.

In order to use `nndiary' in autonomous mode, you have several things
to do:

   * Allow `nndiary' to retrieve new mail by itself.  Put the
     following line in your `~/.gnus.el' file:

          (setq nndiary-get-new-mail t)
   * You must arrange for diary messages (those containing `X-Diary-*'
     headers) to be split in a private folder *before* Gnus treat
     them.  Again, this is needed because Gnus cannot (yet ?) properly
     handle multiple primary mail back ends.  Getting those messages
     from a separate source will compensate this misfeature to some
     extent.

     As an example, here's my procmailrc entry to store diary files in
     `~/.nndiary' (the default `nndiary' mail source file):

          :0 HD :
          * ^X-Diary
          .nndiary

Once this is done, you might want to customize the following two
options that affect the diary mail retrieval and splitting processes:

 -- Variable: nndiary-mail-sources
     This is the diary-specific replacement for the standard
     `mail-sources' variable.  It obeys the same syntax, and defaults to
     `(file :path "~/.nndiary")'.

 -- Variable: nndiary-split-methods
     This is the diary-specific replacement for the standard
     `nnmail-split-methods' variable.  It obeys the same syntax.

  Finally, you may add a permanent `nndiary' virtual server
(something like `(nndiary "diary")' should do) to your
`gnus-secondary-select-methods'.

  Hopefully, almost everything (see the TODO section in `nndiary.el')
will work as expected when you restart Gnus: in autonomous mode,
typing `g' and `M-g' in the group buffer, will also get your new diary
mails and split them according to your diary-specific rules, `F' will
find your new diary groups etc.



File: gnus, Node: Customizing NNDiary, Prev: Running NNDiary, Up: The NNDiary Back End

Customizing NNDiary
...................

Now that `nndiary' is up and running, it's time to customize it.  The
custom group is called `nndiary' (no, really ?!).  You should browse
it to figure out which options you'd like to tweak.  The following two
variables are probably the only ones you will want to change:

 -- Variable: nndiary-reminders
     This is the list of times when you want to be reminded of your
     appointments (e.g. 3 weeks before, then 2 days before, then 1
     hour before and that's it).  Remember that "being reminded" means
     that the diary message will pop up as brand new and unread again
     when you get new mail.

 -- Variable: nndiary-week-starts-on-monday
     Rather self-explanatory.  Otherwise, Sunday is assumed (this is
     the default).




File: gnus, Node: The Gnus Diary Library, Next: Sending or Not Sending, Prev: The NNDiary Back End, Up: Email Based Diary

The Gnus Diary Library
----------------------

Using `nndiary' manually (I mean, writing the headers by hand and so
on) would be rather boring.  Fortunately, there is a library called
`gnus-diary' written on top of `nndiary', that does many useful things
for you.

  In order to use it, add the following line to your `~/.gnus.el'
file:

     (require 'gnus-diary)

  Also, you shouldn't use any `gnus-user-format-function-[d|D]' (*Note
Summary Buffer Lines::).  `gnus-diary' provides both of these (sorry
if you used them before).


* Menu:

* Diary Summary Line Format::           A nicer summary buffer line format.
* Diary Articles Sorting::              A nicer way to sort messages.
* Diary Headers Generation::            Not doing it manually.
* Diary Group Parameters::              Not handling them manually.



File: gnus, Node: Diary Summary Line Format, Next: Diary Articles Sorting, Prev: The Gnus Diary Library, Up: The Gnus Diary Library

Diary Summary Line Format
.........................

Displaying diary messages in standard summary line format (usually
something like `From Joe: Subject') is pretty useless.  Most of the
time, you're the one who wrote the message, and you mostly want to see
the event's date.

  `gnus-diary' provides two supplemental user formats to be used in
summary line formats.  `D' corresponds to a formatted time string for
the next occurrence of the event (e.g. "Sat, Sep 22 01, 12:00"), while
`d' corresponds to an approximative remaining time until the next
occurrence of the event (e.g. "in 6 months, 1 week").

  For example, here's how Joe's birthday is displayed in my
`nndiary+diary:birthdays' summary buffer (note that the message is
expirable, but will never be deleted, as it specifies a periodic
event):

        E  Sat, Sep 22 01, 12:00: Joe's birthday (in 6 months, 1 week)

In order to get something like the above, you would normally add the
following line to your diary groups'parameters:

     (gnus-summary-line-format "%U%R%z %uD: %(%s%) (%ud)\n")

However, `gnus-diary' does it automatically (*Note Diary Group
Parameters::).  You can however customize the provided summary line
format with the following user options:

 -- Variable: gnus-diary-summary-line-format
     Defines the summary line format used for diary groups (*Note
     Summary Buffer Lines::).  `gnus-diary' uses it to automatically
     update the diary groups'parameters.

 -- Variable: gnus-diary-time-format
     Defines the format to display dates in diary summary buffers.
     This is used by the `D' user format.  See the docstring for
     details.

 -- Variable: gnus-diary-delay-format-function
     Defines the format function to use for displaying delays
     (remaining times) in diary summary buffers.  This is used by the
     `d' user format.  There are currently built-in functions for
     English and French; you can also define your own.  See the
     docstring for details.



File: gnus, Node: Diary Articles Sorting, Next: Diary Headers Generation, Prev: Diary Summary Line Format, Up: The Gnus Diary Library

Diary Articles Sorting
......................

`gnus-diary' provides new sorting functions (*Note Sorting the Summary
Buffer:: ) called `gnus-summary-sort-by-schedule',
`gnus-thread-sort-by-schedule' and `gnus-article-sort-by-schedule'.
These functions let you organize your diary summary buffers from the
closest event to the farthest one.

`gnus-diary' automatically installs `gnus-summary-sort-by-schedule' as
a menu item in the summary buffer's "sort" menu, and the two others as
the primary (hence default) sorting functions in the group parameters
(*Note Diary Group Parameters::).



File: gnus, Node: Diary Headers Generation, Next: Diary Group Parameters, Prev: Diary Articles Sorting, Up: The Gnus Diary Library

Diary Headers Generation
........................

`gnus-diary' provides a function called `gnus-diary-check-message' to
help you handle the `X-Diary-*' headers.  This function ensures that
the current message contains all the required diary headers, and
prompts you for values or corrections if needed.

  This function is hooked into the `nndiary' back end, so that moving
or copying an article to a diary group will trigger it automatically.
It is also bound to `C-c C-f d' in `message-mode' and
`article-edit-mode' in order to ease the process of converting a usual
mail to a diary one.

  This function takes a prefix argument which will force prompting of
all diary headers, regardless of their presence or validity.  That
way, you can very easily reschedule an already valid diary message,
for instance.



File: gnus, Node: Diary Group Parameters, Prev: Diary Headers Generation, Up: The Gnus Diary Library

Diary Group Parameters
......................

When you create a new diary group, or visit one, `gnus-diary'
automatically checks your group parameters and if needed, sets the
summary line format to the diary-specific value, installs the
diary-specific sorting functions, and also adds the different
`X-Diary-*' headers to the group's posting-style.  It is then easier
to send a diary message, because if you use `C-u a' or `C-u m' on a
diary group to prepare a message, these headers will be inserted
automatically (although not filled with proper values yet).



File: gnus, Node: Sending or Not Sending, Prev: The Gnus Diary Library, Up: Email Based Diary

Sending or Not Sending
----------------------

Well, assuming you've read all of the above, here are two final notes
on mail sending with `nndiary':

   * `nndiary' is a *real* mail back end.  You really send real diary
     messsages for real.  This means for instance that you can give
     appointments to anybody (provided they use Gnus and `nndiary') by
     sending the diary message to them as well.
   * However, since `nndiary' also has a `request-post' method, you
     can also use `C-u a' instead of `C-u m' on a diary group and the
     message won't actually be sent; just stored locally in the
     group. This comes in very handy for private appointments.



File: gnus, Node: Gnus Unplugged, Prev: Email Based Diary, Up: Select Methods

Gnus Unplugged
==============

In olden times (ca. February '88), people used to run their
newsreaders on big machines with permanent connections to the net.
News transport was dealt with by news servers, and all the newsreaders
had to do was to read news.  Believe it or not.

Nowadays most people read news and mail at home, and use some sort of
modem to connect to the net.  To avoid running up huge phone bills, it
would be nice to have a way to slurp down all the news and mail, hang
up the phone, read for several hours, and then upload any responses
you have to make.  And then you repeat the procedure.

Of course, you can use news servers for doing this as well.  I've used
`inn' together with `slurp', `pop' and `sendmail' for some years, but
doing that's a bore.  Moving the news server functionality up to the
newsreader makes sense if you're the only person reading news on a
machine.

Setting up Gnus as an "offline" newsreader is quite simple.  In fact,
you don't have to configure anything as the agent is now enabled by
default (*Note gnus-agent: Agent Variables.).

Of course, to use it as such, you have to learn a few new commands.

* Menu:

* Agent Basics::                How it all is supposed to work.
* Agent Categories::            How to tell the Gnus Agent what to download.
* Agent Commands::              New commands for all the buffers.
* Agent Visuals::               Ways that the agent may effect your summary buffer.
* Agent as Cache::              The Agent is a big cache too.
* Agent Expiry::                How to make old articles go away.
* Agent Regeneration::          How to recover from lost connections and other accidents.
* Agent and flags::             How the Agent maintains flags.
* Agent and IMAP::              How to use the Agent with IMAP.
* Outgoing Messages::           What happens when you post/mail something?
* Agent Variables::             Customizing is fun.
* Example Setup::               An example `~/.gnus.el' file for offline people.
* Batching Agents::             How to fetch news from a `cron' job.
* Agent Caveats::               What you think it'll do and what it does.




File: gnus, Node: Agent Basics, Next: Agent Categories, Prev: Gnus Unplugged, Up: Gnus Unplugged

Agent Basics
------------

First, let's get some terminology out of the way.

The Gnus Agent is said to be "unplugged" when you have severed the
connection to the net (and notified the Agent that this is the case).
When the connection to the net is up again (and Gnus knows this), the
Agent is "plugged".

The "local" machine is the one you're running on, and which isn't
connected to the net continuously.

"Downloading" means fetching things from the net to your local
machine.  "Uploading" is doing the opposite.

You know that Gnus gives you all the opportunity you'd ever want for
shooting yourself in the foot.  Some people call it flexibility.  Gnus
is also customizable to a great extent, which means that the user has
a say on how Gnus behaves.  Other newsreaders might unconditionally
shoot you in your foot, but with Gnus, you have a choice!

Gnus is never really in plugged or unplugged state.  Rather, it
applies that state to each server individually.  This means that some
servers can be plugged while others can be unplugged.  Additionally,
some servers can be ignored by the Agent altogether (which means that
they're kinda like plugged always).

So when you unplug the Agent and then wonder why is Gnus opening a
connection to the Net, the next step to do is to look whether all
servers are agentized.  If there is an unagentized server, you found
the culprit.

Another thing is the "offline" state.  Sometimes, servers aren't
reachable.  When Gnus notices this, it asks you whether you want the
server to be switched to offline state.  If you say yes, then the
server will behave somewhat as if it was unplugged, except that Gnus
will ask you whether you want to switch it back online again.

Let's take a typical Gnus session using the Agent.


   * You start Gnus with `gnus-unplugged'.  This brings up the Gnus
     Agent in a disconnected state.  You can read all the news that
     you have already fetched while in this mode.

   * You then decide to see whether any new news has arrived.  You
     connect your machine to the net (using PPP or whatever), and then
     hit `J j' to make Gnus become "plugged" and use `g' to check for
     new mail as usual.  To check for new mail in unplugged mode
     (*Note Mail Source Specifiers::).

   * You can then read the new news immediately, or you can download
     the news onto your local machine.  If you want to do the latter,
     you press `g' to check if there are any new news and then `J s'
     to fetch all the eligible articles in all the groups.  (To let
     Gnus know which articles you want to download, *Note Agent
     Categories::).

   * After fetching the articles, you press `J j' to make Gnus become
     unplugged again, and you shut down the PPP thing (or whatever).
     And then you read the news offline.

   * And then you go to step 2.

Here are some things you should do the first time (or so) that you use
the Agent.


   * Decide which servers should be covered by the Agent.  If you have a mail
     back end, it would probably be nonsensical to have it covered by the
     Agent.  Go to the server buffer (`^' in the group buffer) and press
     `J a' on the server (or servers) that you wish to have covered by the
     Agent (*Note Server Agent Commands::), or `J r' on automatically
     added servers you do not wish to have covered by the Agent.  By default,
     all `nntp' and `nnimap' servers in `gnus-select-method' and
     `gnus-secondary-select-methods' are agentized.

   * Decide on download policy.  It's fairly simple once you decide
     whether you are going to use agent categories, topic parameters,
     and/or group parameters to implement your policy.  If you're new
     to gnus, it is probably best to start with a category, *Note
     Agent Categories::.

     Both topic parameters (*Note Topic Parameters::) and agent
     categories (*Note Agent Categories::) provide for setting a
     policy that applies to multiple groups.  Which you use is
     entirely up to you.  Topic parameters do override categories so,
     if you mix the two, you'll have to take that into account.  If
     you have a few groups that deviate from your policy, you can use
     group parameters (*Note Group Parameters::) to configure them.

   * Uhm... that's it.




File: gnus, Node: Agent Categories, Next: Agent Commands, Prev: Agent Basics, Up: Gnus Unplugged

Agent Categories
----------------

One of the main reasons to integrate the news transport layer into the
newsreader is to allow greater control over what articles to download.
There's not much point in downloading huge amounts of articles, just
to find out that you're not interested in reading any of them.  It's
better to be somewhat more conservative in choosing what to download,
and then mark the articles for downloading manually if it should turn
out that you're interested in the articles anyway.

One of the more effective methods for controlling what is to be
downloaded is to create a "category" and then assign some (or all)
groups to this category.  Groups that do not belong in any other
category belong to the `default' category.  Gnus has its own buffer
for creating and managing categories.

If you prefer, you can also use group parameters (*Note Group
Parameters::) and topic parameters (*Note Topic Parameters::) for an
alternative approach to controlling the agent.  The only real
difference is that categories are specific to the agent (so there is
less to learn) while group and topic parameters include the kitchen
sink.

Since you can set agent parameters in several different places we have
a rule to decide which source to believe.  This rule specifies that
the parameter sources are checked in the following order: group
parameters, topic parameters, agent category, and finally customizable
variables.  So you can mix all of these sources to produce a wide
range of behavior, just don't blame me if you don't remember where you
put your settings.

* Menu:

* Category Syntax::             What a category looks like.
* Category Buffer::             A buffer for maintaining categories.
* Category Variables::          Customize'r'Us.




File: gnus, Node: Category Syntax, Next: Category Buffer, Prev: Agent Categories, Up: Agent Categories

Category Syntax
...............

A category consists of a name, the list of groups belonging to the
category, and a number of optional parameters that override the
customizable variables.  The complete list of agent parameters are
listed below.

`agent-groups'
     The list of groups that are in this category.

`agent-predicate'
     A predicate which (generally) gives a rough outline of which
     articles are eligible for downloading; and

`agent-score'
     a score rule which (generally) gives you a finer granularity when
     deciding what articles to download.  (Note that this "download
     score" is not necessarily related to normal scores.)

`agent-enable-expiration'
     a boolean indicating whether the agent should expire old articles
     in this group.  Most groups should be expired to conserve disk
     space.  In fact, its probably safe to say that the gnus.*
     hierarchy contains the only groups that should not be expired.

`agent-days-until-old'
     an integer indicating the number of days that the agent should
     wait before deciding that a read article is safe to expire.

`agent-low-score'
     an integer that overrides the value of `gnus-agent-low-score'.

`agent-high-score'
     an integer that overrides the value of `gnus-agent-high-score'.

`agent-short-article'
     an integer that overrides the value of
     `gnus-agent-short-article'.

`agent-long-article'
     an integer that overrides the value of `gnus-agent-long-article'.

`agent-enable-undownloaded-faces'
     a symbol indicating whether the summary buffer should display
     undownloaded articles using the
     `gnus-summary-*-undownloaded-face' faces.  Any symbol other than
     `nil' will enable the use of undownloaded faces.

The name of a category can not be changed once the category has been
created.

Each category maintains a list of groups that are exclusive members of
that category.  The exclusivity rule is automatically enforced, add a
group to a new category and it is automatically removed from its old
category.

A predicate in its simplest form can be a single predicate such as
`true' or `false'.  These two will download every available article or
nothing respectively.  In the case of these two special predicates an
additional score rule is superfluous.

Predicates of `high' or `low' download articles in respect of
their scores in relationship to `gnus-agent-high-score' and
`gnus-agent-low-score' as described below.

To gain even finer control of what is to be regarded eligible for
download a predicate can consist of a number of predicates with
logical operators sprinkled in between.

Perhaps some examples are in order.

Here's a simple predicate.  (It's the default predicate, in fact, used
for all groups that don't belong to any other category.)

     short

Quite simple, eh?  This predicate is true if and only if the article
is short (for some value of "short").

Here's a more complex predicate:

     (or high
         (and
          (not low)
          (not long)))

This means that an article should be downloaded if it has a high
score, or if the score is not low and the article is not long.  You
get the drift.

The available logical operators are `or', `and' and
`not'.  (If you prefer, you can use the more "C"-ish operators
`|', `&' and `!' instead.)

The following predicates are pre-defined, but if none of these fit
what you want to do, you can write your own.

When evaluating each of these predicates, the named constant will be
bound to the value determined by calling `gnus-agent-find-parameter'
on the appropriate parameter.  For example, gnus-agent-short-article
will be bound to `(gnus-agent-find-parameter group
'agent-short-article)'.  This means that you can specify a predicate
in your category then tune that predicate to individual groups.

`short'
     True if the article is shorter than `gnus-agent-short-article'
     lines; default 100.

`long'
     True if the article is longer than `gnus-agent-long-article'
     lines; default 200.

`low'
     True if the article has a download score less than
     `gnus-agent-low-score'; default 0.

`high'
     True if the article has a download score greater than
     `gnus-agent-high-score'; default 0.

`spam'
     True if the Gnus Agent guesses that the article is spam.  The
     heuristics may change over time, but at present it just computes
     a checksum and sees whether articles match.

`true'
     Always true.

`false'
     Always false.

If you want to create your own predicate function, here's what you
have to know: The functions are called with no parameters, but the
`gnus-headers' and `gnus-score' dynamic variables are bound to useful
values.

For example, you could decide that you don't want to download articles
that were posted more than a certain number of days ago (e.g. posted
more than `gnus-agent-expire-days' ago) you might write a function
something along the lines of the following:

     (defun my-article-old-p ()
       "Say whether an article is old."
       (< (time-to-days (date-to-time (mail-header-date gnus-headers)))
          (- (time-to-days (current-time)) gnus-agent-expire-days)))

with the predicate then defined as:

     (not my-article-old-p)

or you could append your predicate to the predefined
`gnus-category-predicate-alist' in your `~/.gnus.el' or wherever.

     (require 'gnus-agent)
     (setq  gnus-category-predicate-alist
       (append gnus-category-predicate-alist
              '((old . my-article-old-p))))

and simply specify your predicate as:

     (not old)

If/when using something like the above, be aware that there are many
misconfigured systems/mailers out there and so an article's date is
not always a reliable indication of when it was posted.  Hell, some
people just don't give a damn.

The above predicates apply to *all* the groups which belong to the
category.  However, if you wish to have a specific predicate for an
individual group within a category, or you're just too lazy to set up
a new category, you can enter a group's individual predicate in its
group parameters like so:

     (agent-predicate . short)

This is the group/topic parameter equivalent of the agent category default.
Note that when specifying a single word predicate like this, the
`agent-predicate' specification must be in dotted pair notation.

The equivalent of the longer example from above would be:

     (agent-predicate or high (and (not low) (not long)))

The outer parenthesis required in the category specification are not
entered here as, not being in dotted pair notation, the value of the
predicate is assumed to be a list.


Now, the syntax of the download score is the same as the syntax of
normal score files, except that all elements that require actually
seeing the article itself are verboten.  This means that only the
following headers can be scored on: `Subject', `From',
`Date', `Message-ID', `References', `Chars',
`Lines', and `Xref'.

As with predicates, the specification of the `download score rule' to
use in respect of a group can be in either the category definition if
it's to be applicable to all groups in therein, or a group's
parameters if it's to be specific to that group.

In both of these places the `download score rule' can take one of
three forms:

  1. Score rule

     This has the same syntax as a normal Gnus score file except only
     a subset of scoring keywords are available as mentioned above.

     example:

        * Category specification

               (("from"
                      ("Lars Ingebrigtsen" 1000000 nil s))
               ("lines"
                      (500 -100 nil <)))

        * Group/Topic Parameter specification

               (agent-score ("from"
                                  ("Lars Ingebrigtsen" 1000000 nil s))
                            ("lines"
                                  (500 -100 nil <)))

          Again, note the omission of the outermost parenthesis here.

  2. Agent score file

     These score files must *only* contain the permitted scoring
     keywords stated above.

     example:

        * Category specification

               ("~/News/agent.SCORE")

          or perhaps

               ("~/News/agent.SCORE" "~/News/agent.group.SCORE")

        * Group Parameter specification

               (agent-score "~/News/agent.SCORE")

          Additional score files can be specified as above.  Need I
          say anything about parenthesis?

  3. Use `normal' score files

     If you don't want to maintain two sets of scoring rules for a group, and
     your desired `downloading' criteria for a group are the same as your
     `reading' criteria then you can tell the agent to refer to your
     `normal' score files when deciding what to download.

     These directives in either the category definition or a group's
     parameters will cause the agent to read in all the applicable
     score files for a group, *filtering out* those sections that do
     not relate to one of the permitted subset of scoring keywords.

        * Category Specification

               file

        * Group Parameter specification

               (agent-score . file)



File: gnus, Node: Category Buffer, Next: Category Variables, Prev: Category Syntax, Up: Agent Categories

Category Buffer
...............

You'd normally do all category maintenance from the category buffer.
When you enter it for the first time (with the `J c' command from the
group buffer), you'll only see the `default' category.

The following commands are available in this buffer:

`q'
     Return to the group buffer (`gnus-category-exit').

`e'
     Use a customization buffer to set all of the selected category's
     parameters at one time (`gnus-category-customize-category').

`k'
     Kill the current category (`gnus-category-kill').

`c'
     Copy the current category (`gnus-category-copy').

`a'
     Add a new category (`gnus-category-add').

`p'
     Edit the predicate of the current category
     (`gnus-category-edit-predicate').

`g'
     Edit the list of groups belonging to the current category
     (`gnus-category-edit-groups').

`s'
     Edit the download score rule of the current category
     (`gnus-category-edit-score').

`l'
     List all the categories (`gnus-category-list').




File: gnus, Node: Category Variables, Prev: Category Buffer, Up: Agent Categories

Category Variables
..................

`gnus-category-mode-hook'
     Hook run in category buffers.

`gnus-category-line-format'
     Format of the lines in the category buffer (*Note Formatting
     Variables::).  Valid elements are:

     `c'
          The name of the category.

     `g'
          The number of groups in the category.

`gnus-category-mode-line-format'
     Format of the category mode line (*Note Mode Line Formatting::).

`gnus-agent-short-article'
     Articles that have fewer lines than this are short.  Default 100.

`gnus-agent-long-article'
     Articles that have more lines than this are long.  Default 200.

`gnus-agent-low-score'
     Articles that have a score lower than this have a low score.
     Default 0.

`gnus-agent-high-score'
     Articles that have a score higher than this have a high score.
     Default 0.

`gnus-agent-expire-days'
     The number of days that a `read' article must stay in the agent's
     local disk before becoming eligible for expiration (While the
     name is the same, this doesn't mean expiring the article on the
     server.  It just means deleting the local copy of the article).
     What is also important to understand is that the counter starts
     with the time the article was written to the local disk and not
     the time the article was read.  Default 7.

`gnus-agent-enable-expiration'
     Determines whether articles in a group are, by default, expired
     or retained indefinitely.  The default is `ENABLE' which means
     that you'll have to disable expiration when desired.  On the
     other hand, you could set this to `DISABLE'.  In that case, you
     would then have to enable expiration in selected groups.





File: gnus, Node: Agent Commands, Next: Agent Visuals, Prev: Agent Categories, Up: Gnus Unplugged

Agent Commands
--------------

All the Gnus Agent commands are on the `J' submap.  The `J j'
(`gnus-agent-toggle-plugged') command works in all modes, and toggles
the plugged/unplugged state of the Gnus Agent.


* Menu:

* Group Agent Commands::        Configure groups and fetch their contents.
* Summary Agent Commands::      Manually select then fetch specific articles.
* Server Agent Commands::       Select the servers that are supported by the agent.






File: gnus, Node: Group Agent Commands, Next: Summary Agent Commands, Prev: Agent Commands, Up: Agent Commands

Group Agent Commands
....................

`J u'
     Fetch all eligible articles in the current group
     (`gnus-agent-fetch-groups').

`J c'
     Enter the Agent category buffer (`gnus-enter-category-buffer').

`J s'
     Fetch all eligible articles in all groups
     (`gnus-agent-fetch-session').

`J S'
     Send all sendable messages in the queue group
     (`gnus-group-send-queue').  *Note Drafts::.

`J a'
     Add the current group to an Agent category
     (`gnus-agent-add-group').  This command understands the
     process/prefix convention (*Note Process/Prefix::).

`J r'
     Remove the current group from its category, if any
     (`gnus-agent-remove-group').  This command understands the
     process/prefix convention (*Note Process/Prefix::).

`J Y'
     Synchronize flags changed while unplugged with remote server, if
     any.






File: gnus, Node: Summary Agent Commands, Next: Server Agent Commands, Prev: Group Agent Commands, Up: Agent Commands

Summary Agent Commands
......................

`J #'
     Mark the article for downloading (`gnus-agent-mark-article').

`J M-#'
     Remove the downloading mark from the article
     (`gnus-agent-unmark-article').

`@'
     Toggle whether to download the article
     (`gnus-agent-toggle-mark').  The download mark is `%' by default.

`J c'
     Mark all articles as read (`gnus-agent-catchup') that are neither
     cached, downloaded, nor downloadable.

`J S'
     Download all eligible (*Note Agent Categories::) articles in this
     group.  (`gnus-agent-fetch-group').

`J s'
     Download all processable articles in this group.
     (`gnus-agent-summary-fetch-series').

`J u'
     Download all downloadable articles in the current group
     (`gnus-agent-summary-fetch-group').





File: gnus, Node: Server Agent Commands, Prev: Summary Agent Commands, Up: Agent Commands

Server Agent Commands
.....................

`J a'
     Add the current server to the list of servers covered by the Gnus
     Agent (`gnus-agent-add-server').

`J r'
     Remove the current server from the list of servers covered by the
     Gnus Agent (`gnus-agent-remove-server').





File: gnus, Node: Agent Visuals, Next: Agent as Cache, Prev: Agent Commands, Up: Gnus Unplugged

Agent Visuals
-------------

If you open a summary while unplugged and, Gnus knows from the group's
active range that there are more articles than the headers currently
stored in the Agent, you may see some articles whose subject looks
something like `[Undownloaded article #####]'.  These are placeholders
for the missing headers.  Aside from setting a mark, there is not much
that can be done with one of these placeholders.  When Gnus finally
gets a chance to fetch the group's headers, the placeholders will
automatically be replaced by the actual headers.  You can configure
the summary buffer's maneuvering to skip over the placeholders if you
care (See `gnus-auto-goto-ignores').

While it may be obvious to all, the only headers and articles
available while unplugged are those headers and articles that were
fetched into the Agent while previously plugged.  To put it another
way, "If you forget to fetch something while plugged, you might have a
less than satisfying unplugged session".  For this reason, the Agent
adds two visual effects to your summary buffer.  These effects display
the download status of each article so that you always know which
articles will be available when unplugged.

The first visual effect is the `%O' spec.  If you customize
`gnus-summary-line-format' to include this specifier, you will add a
single character field that indicates an article's download status.
Articles that have been fetched into either the Agent or the Cache,
will display `gnus-downloaded-mark' (defaults to `+').  All other
articles will display `gnus-undownloaded-mark' (defaults to `-').  If
you open a group that has not been agentized, a space (` ') will be
displayed.

The second visual effect are the undownloaded faces.  The faces, there
are three indicating the article's score (low, normal, high), seem to
result in a love/hate response from many Gnus users.  The problem is
that the face selection is controlled by a list of condition tests and
face names (See `gnus-summary-highlight').  Each condition is tested
in the order in which it appears in the list so early conditions have
precedence over later conditions.  All of this means that, if you tick
an undownloaded article, the article will continue to be displayed in
the undownloaded face rather than the ticked face.

If you use the Agent as a cache (to avoid downloading the same article
each time you visit it or to minimize your connection time), the
undownloaded face will probably seem like a good idea.  The reason
being that you do all of our work (marking, reading, deleting) with
downloaded articles so the normal faces always appear.  For those
users using the agent to improve online performance by caching the NOV
database (most users since 5.10.2), the undownloaded faces may appear
to be an absolutely horrible idea.  The issue being that, since none
of their articles have been fetched into the Agent, all of the normal
faces will be obscured by the undownloaded faces.

If you would like to use the undownloaded faces, you must enable the
undownloaded faces by setting the `agent-enable-undownloaded-faces'
group parameter to `t'.  This parameter, like all other agent
parameters, may be set on an Agent Category (*Note Agent
Categories::), a Group Topic (*Note Topic Parameters::), or an
individual group (*Note Group Parameters::).

The one problem common to all users using the agent is how quickly it
can consume disk space.  If you using the agent on many groups, it is
even more difficult to effectively recover disk space.  One solution
is the `%F' format available in `gnus-group-line-format'.  This format
will display the actual disk space used by articles fetched into both
the agent and cache.  By knowing which groups use the most space,
users know where to focus their efforts when "agent expiring"
articles.



File: gnus, Node: Agent as Cache, Next: Agent Expiry, Prev: Agent Visuals, Up: Gnus Unplugged

Agent as Cache
--------------

When Gnus is plugged, it is not efficient to download headers or
articles from the server again, if they are already stored in the
Agent.  So, Gnus normally only downloads headers once, and stores them
in the Agent.  These headers are later used when generating the
summary buffer, regardless of whether you are plugged or unplugged.
Articles are not cached in the Agent by default though (that would
potentially consume lots of disk space), but if you have already
downloaded an article into the Agent, Gnus will not download the
article from the server again but use the locally stored copy instead.

If you so desire, you can configure the agent (see `gnus-agent-cache'
*Note Agent Variables::) to always download headers and articles while
plugged.  Gnus will almost certainly be slower, but it will be kept
synchronized with the server.  That last point probably won't make any
sense if you are using a nntp or nnimap back end.



File: gnus, Node: Agent Expiry, Next: Agent Regeneration, Prev: Agent as Cache, Up: Gnus Unplugged

Agent Expiry
------------


The Agent back end, `nnagent', doesn't handle expiry.  Well, at
least it doesn't handle it like other back ends.  Instead, there are
special `gnus-agent-expire' and `gnus-agent-expire-group'
commands that will expire all read articles that are older than
`gnus-agent-expire-days' days.  They can be run whenever you feel
that you're running out of space.  Neither are particularly fast or
efficient, and it's not a particularly good idea to interrupt them (with
`C-g' or anything else) once you've started one of them.

Note that other functions, e.g. `gnus-request-expire-articles', might
run `gnus-agent-expire' for you to keep the agent synchronized with
the group.

The agent parameter `agent-enable-expiration' may be used to prevent
expiration in selected groups.

If `gnus-agent-expire-all' is non-`nil', the agent expiration commands
will expire all articles--unread, read, ticked and dormant.  If `nil'
(which is the default), only read articles are eligible for expiry,
and unread, ticked and dormant articles will be kept indefinitely.

If you find that some articles eligible for expiry are never expired,
perhaps some Gnus Agent files are corrupted.  There's are special
commands, `gnus-agent-regenerate' and
`gnus-agent-regenerate-group', to fix possible problems.



File: gnus, Node: Agent Regeneration, Next: Agent and flags, Prev: Agent Expiry, Up: Gnus Unplugged

Agent Regeneration
------------------


The local data structures used by `nnagent' may become corrupted due
to certain exceptional conditions.  When this happens, `nnagent'
functionality may degrade or even fail.  The solution to this problem
is to repair the local data structures by removing all internal
inconsistencies.

For example, if your connection to your server is lost while
downloaded articles into the agent, the local data structures will not
know about articles successfully downloaded prior to the connection
failure.  Running `gnus-agent-regenerate' or
`gnus-agent-regenerate-group' will update the data structures such
that you don't need to download these articles a second time.

The command `gnus-agent-regenerate' will perform
`gnus-agent-regenerate-group' on every agentized group.  While you can
run `gnus-agent-regenerate' in any buffer, it is strongly recommended
that you first close all summary buffers.

The command `gnus-agent-regenerate-group' uses the local copies of
individual articles to repair the local NOV(header) database.  It then
updates the internal data structures that document which articles are
stored locally.  An optional argument will mark articles in the agent
as unread.



File: gnus, Node: Agent and flags, Next: Agent and IMAP, Prev: Agent Regeneration, Up: Gnus Unplugged

Agent and flags
---------------

The Agent works with any Gnus back end including those, such as
nnimap, that store flags (read, ticked, etc) on the server.  Sadly,
the Agent does not actually know which backends keep their flags in
the backend server rather than in `.newsrc'.  This means that the
Agent, while unplugged or disconnected, will always record all changes
to the flags in its own files.

When you plug back in, Gnus will then check to see if you have any
changed any flags and ask if you wish to synchronize these with the
server.  This behavior is customizable by
`gnus-agent-synchronize-flags'.

If `gnus-agent-synchronize-flags' is `nil', the Agent will never
automatically synchronize flags.  If it is `ask', which is the
default, the Agent will check if you made any changes and if so ask if
you wish to synchronize these when you re-connect.  If it has any
other value, all flags will be synchronized automatically.

If you do not wish to synchronize flags automatically when you
re-connect, you can do it manually with the
`gnus-agent-synchronize-flags' command that is bound to `J Y' in the
group buffer.

Technical note: the synchronization algorithm does not work by
pushing" all local flags to the server, but rather by incrementally
updated the server view of flags by changing only those flags that
were changed by the user.  Thus, if you set one flag on an article,
quit the group then re-select the group and remove the flag; the flag
will be set and removed from the server when you "synchronize".  The
queued flag operations can be found in the per-server `flags' file in
the Agent directory.  It's emptied when you synchronize flags.



File: gnus, Node: Agent and IMAP, Next: Outgoing Messages, Prev: Agent and flags, Up: Gnus Unplugged

Agent and IMAP
--------------

The Agent works with any Gnus back end, including nnimap.  However,
since there are some conceptual differences between NNTP and IMAP,
this section (should) provide you with some information to make Gnus
Agent work smoother as a IMAP Disconnected Mode client.

Some things are currently not implemented in the Agent that you'd
might expect from a disconnected IMAP client, including:


   * Copying/moving articles into nnimap groups when unplugged.

   * Creating/deleting nnimap groups when unplugged.




File: gnus, Node: Outgoing Messages, Next: Agent Variables, Prev: Agent and IMAP, Up: Gnus Unplugged

Outgoing Messages
-----------------

By default, when Gnus is unplugged, all outgoing messages (both mail
and news) are stored in the draft group "queue" (*Note Drafts::).  You
can view them there after posting, and edit them at will.

You can control the circumstances under which outgoing mail is queued
(see `gnus-agent-queue-mail', *Note Agent Variables::).  Outgoing news
is always queued when Gnus is unplugged, and never otherwise.

You can send the messages either from the draft group with the special
commands available there, or you can use the `J S' command in the
group buffer to send all the sendable messages in the draft group.
Posting news will only work when Gnus is plugged, but you can send
mail at any time.

If sending mail while unplugged does not work for you and you worry
about hitting `J S' by accident when unplugged, you can have Gnus
ask you to confirm your action (see
`gnus-agent-prompt-send-queue', *Note Agent Variables::).



File: gnus, Node: Agent Variables, Next: Example Setup, Prev: Outgoing Messages, Up: Gnus Unplugged

Agent Variables
---------------

`gnus-agent'
     Is the agent enabled?  The default is `t'.  When first enabled,
     the agent will use `gnus-agent-auto-agentize-methods' to
     automatically mark some back ends as agentized.  You may change
     which back ends are agentized using the agent commands in the
     server buffer.

     To enter the server buffer, use the `^'
     (`gnus-group-enter-server-mode') command in the group buffer.


`gnus-agent-directory'
     Where the Gnus Agent will store its files.  The default is
     `~/News/agent/'.

`gnus-agent-handle-level'
     Groups on levels (*Note Group Levels::) higher than this variable
     will be ignored by the Agent.  The default is
     `gnus-level-subscribed', which means that only subscribed group
     will be considered by the Agent by default.

`gnus-agent-plugged-hook'
     Hook run when connecting to the network.

`gnus-agent-unplugged-hook'
     Hook run when disconnecting from the network.

`gnus-agent-fetched-hook'
     Hook run when finished fetching articles.

`gnus-agent-cache'
     Variable to control whether use the locally stored NOV and
     articles when plugged, e.g. essentially using the Agent as a
     cache.  The default is non-`nil', which means to use the Agent as
     a cache.

`gnus-agent-go-online'
     If `gnus-agent-go-online' is `nil', the Agent will never
     automatically switch offline servers into online status.  If it
     is `ask', the default, the Agent will ask if you wish to switch
     offline servers into online status when you re-connect.  If it
     has any other value, all offline servers will be automatically
     switched into online status.

`gnus-agent-mark-unread-after-downloaded'
     If `gnus-agent-mark-unread-after-downloaded' is non-`nil', mark
     articles as unread after downloading.  This is usually a safe
     thing to do as the newly downloaded article has obviously not
     been read.  The default is `t'.

`gnus-agent-synchronize-flags'
     If `gnus-agent-synchronize-flags' is `nil', the Agent will never
     automatically synchronize flags.  If it is `ask', which is the
     default, the Agent will check if you made any changes and if so
     ask if you wish to synchronize these when you re-connect.  If it
     has any other value, all flags will be synchronized
     automatically.

`gnus-agent-consider-all-articles'
     If `gnus-agent-consider-all-articles' is non-`nil', the agent
     will let the agent predicate decide whether articles need to be
     downloaded or not, for all articles.  When `nil', the default,
     the agent will only let the predicate decide whether unread
     articles are downloaded or not.  If you enable this, you may also
     want to look into the agent expiry settings (*Note Category
     Variables::), so that the agent doesn't download articles which
     the agent will later expire, over and over again.

`gnus-agent-max-fetch-size'
     The agent fetches articles into a temporary buffer prior to
     parsing them into individual files.  To avoid exceeding the
     max. buffer size, the agent alternates between fetching and
     parsing until all articles have been fetched.
     `gnus-agent-max-fetch-size' provides a size limit to control how
     often the cycling occurs.  A large value improves performance.  A
     small value minimizes the time lost should the connection be lost
     while fetching (You may need to run `gnus-agent-regenerate-group'
     to update the group's state.  However, all articles parsed prior
     to loosing the connection will be available while unplugged).
     The default is 10M so it is unusual to see any cycling.

`gnus-server-unopen-status'
     Perhaps not an Agent variable, but closely related to the Agent,
     this variable says what will happen if Gnus cannot open a server.
     If the Agent is enabled, the default, `nil', makes Gnus ask the
     user whether to deny the server or whether to unplug the agent.
     If the Agent is disabled, Gnus always simply deny the server.
     Other choices for this variable include `denied' and `offline'
     the latter is only valid if the Agent is used.

`gnus-auto-goto-ignores'
     Another variable that isn't an Agent variable, yet so closely
     related that most will look for it here, this variable tells the
     summary buffer how to maneuver around undownloaded (only headers
     stored in the agent) and unfetched (neither article nor headers
     stored) articles.

     The valid values are `nil' (maneuver to any article),
     `undownloaded' (maneuvering while unplugged ignores articles that
     have not been fetched), `always-undownloaded' (maneuvering always
     ignores articles that have not been fetched), `unfetched'
     (maneuvering ignores articles whose headers have not been
     fetched).

`gnus-agent-queue-mail'
     When `gnus-agent-queue-mail' is `always', Gnus will always queue
     mail rather than sending it straight away.  When `t', Gnus will
     queue mail when unplugged only.  When `nil', never queue mail.
     The default is `t'.

`gnus-agent-prompt-send-queue'
     When `gnus-agent-prompt-send-queue' is non-`nil' Gnus will
     prompt you to confirm that you really wish to proceed if you hit
     `J S' while unplugged.  The default is `nil'.

`gnus-agent-auto-agentize-methods'
     If you have never used the Agent before (or more technically, if
     `~/News/agent/lib/servers' does not exist), Gnus will
     automatically agentize a few servers for you.  This variable
     control which back ends should be auto-agentized.  It is
     typically only useful to agentize remote back ends.  The
     auto-agentizing has the same effect as running `J a' on the
     servers (*Note Server Agent Commands::).  If the file exist, you
     must manage the servers manually by adding or removing them, this
     variable is only applicable the first time you start Gnus.  The
     default is `(nntp nnimap)'.





File: gnus, Node: Example Setup, Next: Batching Agents, Prev: Agent Variables, Up: Gnus Unplugged

Example Setup
-------------

If you don't want to read this manual, and you have a fairly standard
setup, you may be able to use something like the following as your
`~/.gnus.el' file to get started.

     ;; Define how Gnus is to fetch news.  We do this over NNTP
     ;; from your ISP's server.
     (setq gnus-select-method '(nntp "news.your-isp.com"))

     ;; Define how Gnus is to read your mail.  We read mail from
     ;; your ISP's POP server.
     (setq mail-sources '((pop :server "pop.your-isp.com")))

     ;; Say how Gnus is to store the mail.  We use nnml groups.
     (setq gnus-secondary-select-methods '((nnml "")))

     ;; Make Gnus into an offline newsreader.
     ;; (gnus-agentize) ; The obsolete setting.
     ;; (setq gnus-agent t) ; Now the default.

That should be it, basically.  Put that in your `~/.gnus.el' file,
edit to suit your needs, start up PPP (or whatever), and type `M-x
gnus'.

If this is the first time you've run Gnus, you will be subscribed
automatically to a few default newsgroups.  You'll probably want to
subscribe to more groups, and to do that, you have to query the NNTP
server for a complete list of groups with the `A A' command.  This
usually takes quite a while, but you only have to do it once.

After reading and parsing a while, you'll be presented with a list of
groups.  Subscribe to the ones you want to read with the `u' command.
`l' to make all the killed groups disappear after you've subscribe to
all the groups you want to read.  (`A k' will bring back all the
killed groups.)

You can now read the groups at once, or you can download the articles
with the `J s' command.  And then read the rest of this manual to find
out which of the other gazillion things you want to customize.




File: gnus, Node: Batching Agents, Next: Agent Caveats, Prev: Example Setup, Up: Gnus Unplugged

Batching Agents
---------------

Having the Gnus Agent fetch articles (and post whatever messages
you've written) is quite easy once you've gotten things set up
properly.  The following shell script will do everything that is
necessary:

You can run a complete batch command from the command line with the
following incantation:

     #!/bin/sh
     emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-agent-batch >/dev/null 2>&1




File: gnus, Node: Agent Caveats, Prev: Batching Agents, Up: Gnus Unplugged

Agent Caveats
-------------

The Gnus Agent doesn't seem to work like most other offline
newsreaders.  Here are some common questions that some imaginary
people may ask:

"If I read an article while plugged, do they get entered into the Agent?"

     *No*.  If you want this behavior, add
     `gnus-agent-fetch-selected-article' to
     `gnus-select-article-hook'.

"If I read an article while plugged, and the article already exists in"
     the Agent, will it get downloaded once more?

     *No*, unless `gnus-agent-cache' is `nil'.


In short, when Gnus is unplugged, it only looks into the locally
stored articles; when it's plugged, it talks to your ISP and may also
use the locally stored articles.




File: gnus, Node: Scoring, Next: Various, Prev: Select Methods, Up: Top

Scoring
*******

Other people use "kill files", but we here at Gnus Towers like scoring
better than killing, so we'd rather switch than fight.  They do
something completely different as well, so sit up straight and pay
attention!

All articles have a default score (`gnus-summary-default-score'),
which is 0 by default.  This score may be raised or lowered either
interactively or by score files.  Articles that have a score lower than
`gnus-summary-mark-below' are marked as read.

Gnus will read any "score files" that apply to the current group
before generating the summary buffer.

There are several commands in the summary buffer that insert score
entries based on the current article.  You can, for instance, ask Gnus
to lower or increase the score of all articles with a certain subject.

There are two sorts of scoring entries: Permanent and temporary.
Temporary score entries are self-expiring entries.  Any entries that
are temporary and have not been used for, say, a week, will be removed
silently to help keep the sizes of the score files down.

* Menu:

* Summary Score Commands::      Adding score entries for the current group.
* Group Score Commands::        General score commands.
* Score Variables::             Customize your scoring.  (My, what terminology).
* Score File Format::           What a score file may contain.
* Score File Editing::          You can edit score files by hand as well.
* Adaptive Scoring::            Big Sister Gnus knows what you read.
* Home Score File::             How to say where new score entries are to go.
* Followups To Yourself::       Having Gnus notice when people answer you.
* Scoring On Other Headers::    Scoring on non-standard headers.
* Scoring Tips::                How to score effectively.
* Reverse Scoring::             That problem child of old is not problem.
* Global Score Files::          Earth-spanning, ear-splitting score files.
* Kill Files::                  They are still here, but they can be ignored.
* Converting Kill Files::       Translating kill files to score files.
* Advanced Scoring::            Using logical expressions to build score rules.
* Score Decays::                It can be useful to let scores wither away.




File: gnus, Node: Summary Score Commands, Next: Group Score Commands, Prev: Scoring, Up: Scoring

Summary Score Commands
======================

The score commands that alter score entries do not actually modify
real score files.  That would be too inefficient.  Gnus maintains a
cache of previously loaded score files, one of which is considered the
current score file alist".  The score commands simply insert entries
into this list, and upon group exit, this list is saved.

The current score file is by default the group's local score file,
even if no such score file actually exists.  To insert score commands
into some other score file (e.g. `all.SCORE'), you must first make
this score file the current one.

General score commands that don't actually change the score file:


`V s'
     Set the score of the current article (`gnus-summary-set-score').

`V S'
     Display the score of the current article
     (`gnus-summary-current-score').

`V t'
     Display all score rules that have been used on the current
     article (`gnus-score-find-trace').  In the `*Score Trace*'
     buffer, you may type `e' to edit score file corresponding to the
     score rule on current line and `f' to format
     (`gnus-score-pretty-print') the score file and edit it.

`V w'
     List words used in scoring (`gnus-score-find-favourite-words').

`V R'
     Run the current summary through the scoring process
     (`gnus-summary-rescore').  This might be useful if you're playing
     around with your score files behind Gnus' back and want to see
     the effect you're having.

`V c'
     Make a different score file the current
     (`gnus-score-change-score-file').

`V e'
     Edit the current score file (`gnus-score-edit-current-scores').
     You will be popped into a `gnus-score-mode' buffer (*Note Score
     File Editing::).

`V f'
     Edit a score file and make this score file the current one
     (`gnus-score-edit-file').

`V F'
     Flush the score cache (`gnus-score-flush-cache').  This is useful
     after editing score files.

`V C'
     Customize a score file in a visually pleasing manner
     (`gnus-score-customize').


The rest of these commands modify the local score file.


`V m'
     Prompt for a score, and mark all articles with a score below this
     as read (`gnus-score-set-mark-below').

`V x'
     Prompt for a score, and add a score rule to the current score
     file to expunge all articles below this score
     (`gnus-score-set-expunge-below').

The keystrokes for actually making score entries follow a very regular
pattern, so there's no need to list all the commands.  (Hundreds of
them.)


  1. The first key is either `I' (upper case i) for increasing the
     score or `L' for lowering the score.
  2. The second key says what header you want to score on.  The
     following keys are available:

     `a'
          Score on the author name.

     `s'
          Score on the subject line.

     `x'
          Score on the `Xref' line--i.e., the cross-posting line.

     `r'
          Score on the `References' line.

     `d'
          Score on the date.

     `l'
          Score on the number of lines.

     `i'
          Score on the `Message-ID' header.

     `e'
          Score on an "extra" header, that is, one of those in
          gnus-extra-headers, if your NNTP server tracks additional
          header data in overviews.

     `f'
          Score on followups--this matches the author name, and adds scores to
          the followups to this author.  (Using this key leads to the creation of
          `ADAPT' files.)

     `b'
          Score on the body.

     `h'
          Score on the head.

     `t'
          Score on thread.  (Using this key leads to the creation of
          `ADAPT' files.)


  3. The third key is the match type.  Which match types are valid
     depends on what headers you are scoring on.


     `strings'


          `e'
               Exact matching.

          `s'
               Substring matching.

          `f'
               Fuzzy matching (*Note Fuzzy Matching::).

          `r'
               Regexp matching

     `date'

          `b'
               Before date.

          `a'
               After date.

          `n'
               This date.

     `number'

          `<'
               Less than number.

          `='
               Equal to number.

          `>'
               Greater than number.

  4. The fourth and usually final key says whether this is a temporary
     (i.e., expiring) score entry, or a permanent (i.e., non-expiring)
     score entry, or whether it is to be done immediately, without
     adding to the score file.

     `t'
          Temporary score entry.

     `p'
          Permanent score entry.

     `i'
          Immediately scoring.

  5. If you are scoring on `e' (extra) headers, you will then be
     prompted for the header name on which you wish to score.  This
     must be a header named in gnus-extra-headers, and `TAB'
     completion is available.


So, let's say you want to increase the score on the current author
with exact matching permanently: `I a e p'.  If you want to lower the
score based on the subject line, using substring matching, and make a
temporary score entry: `L s s t'.  Pretty easy.

To make things a bit more complicated, there are shortcuts.  If you
use a capital letter on either the second or third keys, Gnus will use
defaults for the remaining one or two keystrokes.  The defaults are
substring" and "temporary".  So `I A' is the same as `I a s t', and `I
a R' is the same as `I a r t'.

These functions take both the numerical prefix and the symbolic prefix
(*Note Symbolic Prefixes::).  A numerical prefix says how much to
lower (or increase) the score of the article.  A symbolic prefix of
`a' says to use the `all.SCORE' file for the command instead of the
current score file.

The `gnus-score-mimic-keymap' says whether these commands will pretend
they are keymaps or not.




File: gnus, Node: Group Score Commands, Next: Score Variables, Prev: Summary Score Commands, Up: Scoring

Group Score Commands
====================

There aren't many of these as yet, I'm afraid.


`W e'
     Edit the apply-to-all-groups all.SCORE file.  You will be popped
     into a `gnus-score-mode' buffer (*Note Score File Editing::).

`W f'
     Gnus maintains a cache of score alists to avoid having to reload
     them all the time.  This command will flush the cache
     (`gnus-score-flush-cache').


You can do scoring from the command line by saying something like:

     $ emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-batch-score




File: gnus, Node: Score Variables, Next: Score File Format, Prev: Group Score Commands, Up: Scoring

Score Variables
===============


`gnus-use-scoring'
     If `nil', Gnus will not check for score files, and will not, in
     general, do any score-related work.  This is `t' by default.

`gnus-kill-killed'
     If this variable is `nil', Gnus will never apply score files to
     articles that have already been through the kill process.  While
     this may save you lots of time, it also means that if you apply a
     kill file to a group, and then change the kill file and want to
     run it over you group again to kill more articles, it won't work.
     You have to set this variable to `t' to do that.  (It is `t' by
     default.)

`gnus-kill-files-directory'
     All kill and score files will be stored in this directory, which
     is initialized from the `SAVEDIR' environment variable by
     default.  This is `~/News/' by default.

`gnus-score-file-suffix'
     Suffix to add to the group name to arrive at the score file name
     (`SCORE' by default.)

`gnus-score-uncacheable-files'
     All score files are normally cached to avoid excessive re-loading
     of score files.  However, this might make your Emacs grow big and
     bloated, so this regexp can be used to weed out score files
     unlikely to be needed again.  It would be a bad idea to deny
     caching of `all.SCORE', while it might be a good idea to not
     cache `comp.infosystems.www.authoring.misc.ADAPT'.  In fact, this
     variable is `ADAPT$' by default, so no adaptive score files will
     be cached.

`gnus-save-score'
     If you have really complicated score files, and do lots of batch
     scoring, then you might set this variable to `t'.  This will make
     Gnus save the scores into the `.newsrc.eld' file.

     If you do not set this to `t', then manual scores (like those set
     with `V s' (`gnus-summary-set-score')) will not be preserved
     across group visits.

`gnus-score-interactive-default-score'
     Score used by all the interactive raise/lower commands to
     raise/lower score with.  Default is 1000, which may seem
     excessive, but this is to ensure that the adaptive scoring scheme
     gets enough room to play with.  We don't want the small changes
     from the adaptive scoring to overwrite manually entered data.

`gnus-summary-default-score'
     Default score of an article, which is 0 by default.

`gnus-summary-expunge-below'
     Don't display the summary lines of articles that have scores
     lower than this variable.  This is `nil' by default, which means
     that no articles will be hidden.  This variable is local to the
     summary buffers, and has to be set from `gnus-summary-mode-hook'.

`gnus-score-over-mark'
     Mark (in the third column) used for articles with a score over
     the default.  Default is `+'.

`gnus-score-below-mark'
     Mark (in the third column) used for articles with a score below
     the default.  Default is `-'.

`gnus-score-find-score-files-function'
     Function used to find score files for the current group.  This
     function is called with the name of the group as the argument.

     Predefined functions available are:

     `gnus-score-find-single'
          Only apply the group's own score file.

     `gnus-score-find-bnews'
          Apply all score files that match, using bnews syntax.  This
          is the default.  If the current group is `gnu.emacs.gnus',
          for instance, `all.emacs.all.SCORE', `not.alt.all.SCORE' and
          `gnu.all.SCORE' would all apply.  In short, the instances of
          `all' in the score file names are translated into `.*', and
          then a regexp match is done.

          This means that if you have some score entries that you want
          to apply to all groups, then you put those entries in the
          `all.SCORE' file.

          The score files are applied in a semi-random order, although
          Gnus will try to apply the more general score files before
          the more specific score files.  It does this by looking at
          the number of elements in the score file names--discarding
          the `all' elements.

     `gnus-score-find-hierarchical'
          Apply all score files from all the parent groups.  This
          means that you can't have score files like `all.SCORE', but
          you can have `SCORE', `comp.SCORE' and `comp.emacs.SCORE'
          for each server.

     This variable can also be a list of functions.  In that case, all
     these functions will be called with the group name as argument,
     and all the returned lists of score files will be applied.  These
     functions can also return lists of lists of score alists
     directly.  In that case, the functions that return these non-file
     score alists should probably be placed before the "real" score
     file functions, to ensure that the last score file returned is
     the local score file.  Phu.

     For example, to do hierarchical scoring but use a
     non-server-specific overall score file, you could use the value
          (list (lambda (group) ("all.SCORE"))
                'gnus-score-find-hierarchical)

`gnus-score-expiry-days'
     This variable says how many days should pass before an unused
     score file entry is expired.  If this variable is `nil', no score
     file entries are expired.  It's 7 by default.

`gnus-update-score-entry-dates'
     If this variable is non-`nil', temporary score entries that have
     been triggered (matched) will have their dates updated.  (This is
     how Gnus controls expiry--all non-matched-entries will become too
     old while matched entries will stay fresh and young.)  However,
     if you set this variable to `nil', even matched entries will grow
     old and will have to face that oh-so grim reaper.

`gnus-score-after-write-file-function'
     Function called with the name of the score file just written.

`gnus-score-thread-simplify'
     If this variable is non-`nil', article subjects will be
     simplified for subject scoring purposes in the same manner as
     with threading--according to the current value of
     `gnus-simplify-subject-functions'.  If the scoring entry uses
     `substring' or `exact' matching, the match will also be
     simplified in this manner.





File: gnus, Node: Score File Format, Next: Score File Editing, Prev: Score Variables, Up: Scoring

Score File Format
=================

A score file is an `emacs-lisp' file that normally contains just a
single form.  Casual users are not expected to edit these files;
everything can be changed from the summary buffer.

Anyway, if you'd like to dig into it yourself, here's an example:

     (("from"
       ("Lars Ingebrigtsen" -10000)
       ("Per Abrahamsen")
       ("larsi\\|lmi" -50000 nil R))
      ("subject"
       ("Ding is Badd" nil 728373))
      ("xref"
       ("alt.politics" -1000 728372 s))
      ("lines"
       (2 -100 nil <))
      (mark 0)
      (expunge -1000)
      (mark-and-expunge -10)
      (read-only nil)
      (orphan -10)
      (adapt t)
      (files "/hom/larsi/News/gnu.SCORE")
      (exclude-files "all.SCORE")
      (local (gnus-newsgroup-auto-expire t)
             (gnus-summary-make-false-root empty))
      (eval (ding)))

This example demonstrates most score file elements.  *Note Advanced
Scoring::, for a different approach.

Even though this looks much like Lisp code, nothing here is actually
`eval'ed.  The Lisp reader is used to read this form, though, so it
has to be valid syntactically, if not semantically.

Six keys are supported by this alist:


`STRING'
     If the key is a string, it is the name of the header to perform
     the match on.  Scoring can only be performed on these eight
     headers: `From', `Subject', `References', `Message-ID', `Xref',
     `Lines', `Chars' and `Date'.  In addition to these headers, there
     are three strings to tell Gnus to fetch the entire article and do
     the match on larger parts of the article: `Body' will perform the
     match on the body of the article, `Head' will perform the match
     on the head of the article, and `All' will perform the match on
     the entire article.  Note that using any of these last three keys
     will slow down group entry *considerably*.  The final "header"
     you can score on is `Followup'.  These score entries will result
     in new score entries being added for all follow-ups to articles
     that matches these score entries.

     Following this key is an arbitrary number of score entries, where
     each score entry has one to four elements.

       1. The first element is the "match element".  On most headers
          this will be a string, but on the Lines and Chars headers,
          this must be an integer.

       2. If the second element is present, it should be a number--the
          score element".  This number should be an integer in the
          neginf to posinf interval.  This number is added to the
          score of the article if the match is successful.  If this
          element is not present, the
          `gnus-score-interactive-default-score' number will be used
          instead.  This is 1000 by default.

       3. If the third element is present, it should be a number--the
          date element".  This date says when the last time this score
          entry matched, which provides a mechanism for expiring the
          score entries.  It this element is not present, the score
          entry is permanent.  The date is represented by the number
          of days since December 31, 1 BCE.

       4. If the fourth element is present, it should be a symbol--the
          type element".  This element specifies what function should
          be used to see whether this score entry matches the article.
          What match types that can be used depends on what header you
          wish to perform the match on.

          "From, Subject, References, Xref, Message-ID"
               For most header types, there are the `r' and `R'
               (regexp), as well as `s' and `S' (substring) types, and
               `e' and `E' (exact match), and `w' (word match) types.
               If this element is not present, Gnus will assume that
               substring matching should be used.  `R', `S', and `E'
               differ from the others in that the matches will be done
               in a case-sensitive manner.  All these one-letter types
               are really just abbreviations for the `regexp',
               `string', `exact', and `word' types, which you can use
               instead, if you feel like.

          "Extra"
               Just as for the standard string overview headers, if
               you are using gnus-extra-headers, you can score on
               these headers' values.  In this case, there is a 5th
               element in the score entry, being the name of the
               header to be scored.  The following entry is useful in
               your `all.SCORE' file in case of spam attacks from a
               single origin host, if your NNTP server tracks
               `NNTP-Posting-Host' in overviews:

                    ("111.222.333.444" -1000 nil s
                     "NNTP-Posting-Host")

          "Lines, Chars"
               These two headers use different match types: `<', `>',
               `=', `>=' and `<='.

               These predicates are true if

                    (PREDICATE HEADER MATCH)

               evaluates to non-`nil'.  For instance, the advanced
               match `("lines" 4 <)' (*Note Advanced Scoring::) will
               result in the following form:

                    (< header-value 4)

               Or to put it another way: When using `<' on `Lines'
               with 4 as the match, we get the score added if the
               article has less than 4 lines.  (It's easy to get
               confused and think it's the other way around.  But it's
               not.  I think.)

               When matching on `Lines', be careful because some back
               ends (like `nndir') do not generate `Lines' header, so
               every article ends up being marked as having 0 lines.
               This can lead to strange results if you happen to lower
               score of the articles with few lines.

          "Date"
               For the Date header we have three kinda silly match
               types: `before', `at' and `after'.  I can't really
               imagine this ever being useful, but, like, it would
               feel kinda silly not to provide this function.  Just in
               case.  You never know.  Better safe than sorry.  Once
               burnt, twice shy.  Don't judge a book by its cover.
               Never not have sex on a first date.  (I have been told
               that at least one person, and I quote, "found this
               function indispensable", however.)

               A more useful match type is `regexp'.  With it, you can
               match the date string using a regular expression.  The
               date is normalized to ISO8601 compact format
               first---YYYYMMDD`T'HHMMSS.  If you want to match all
               articles that have been posted on April 1st in every
               year, you could use `....0401.........' as a match
               string, for instance.  (Note that the date is kept in
               its original time zone, so this will match articles
               that were posted when it was April 1st where the
               article was posted from.  Time zones are such wholesome
               fun for the whole family, eh?)

          "Head, Body, All"
               These three match keys use the same match types as the
               `From' (etc) header uses.

          "Followup"
               This match key is somewhat special, in that it will
               match the `From' header, and affect the score of not
               only the matching articles, but also all followups to
               the matching articles.  This allows you e.g. increase
               the score of followups to your own articles, or
               decrease the score of followups to the articles of some
               known trouble-maker.  Uses the same match types as the
               `From' header uses.  (Using this match key will lead to
               creation of `ADAPT' files.)

          "Thread"
               This match key works along the same lines as the
               `Followup' match key.  If you say that you want to
               score on a (sub-)thread started by an article with a
               `Message-ID' X, then you add a `thread' match.  This
               will add a new `thread' match for each article that has
               X in its `References' header.  (These new `thread'
               matches will use the `Message-ID's of these matching
               articles.)  This will ensure that you can raise/lower
               the score of an entire thread, even though some
               articles in the thread may not have complete
               `References' headers.  Note that using this may lead to
               undeterministic scores of the articles in the thread.
               (Using this match key will lead to creation of `ADAPT'
               files.)

`mark'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be marked as read.

`expunge'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be removed from the summary
     buffer.

`mark-and-expunge'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be marked as read and removed
     from the summary buffer.

`thread-mark-and-expunge'
     The value of this entry should be a number.  All articles that
     belong to a thread that has a total score below this number will
     be marked as read and removed from the summary buffer.
     `gnus-thread-score-function' says how to compute the total score
     for a thread.

`files'
     The value of this entry should be any number of file names.
     These files are assumed to be score files as well, and will be
     loaded the same way this one was.

`exclude-files'
     The clue of this entry should be any number of files.  These
     files will not be loaded, even though they would normally be so,
     for some reason or other.

`eval'
     The value of this entry will be `eval'el.  This element will be
     ignored when handling global score files.

`read-only'
     Read-only score files will not be updated or saved.  Global score
     files should feature this atom (*Note Global Score Files::).
     (Note: "Global" here really means "global"; not your personal
     apply-to-all-groups score files.)

`orphan'
     The value of this entry should be a number.  Articles that do not
     have parents will get this number added to their scores.  Imagine
     you follow some high-volume newsgroup, like `comp.lang.c'.  Most
     likely you will only follow a few of the threads, also want to
     see any new threads.

     You can do this with the following two score file entries:

                  (orphan -500)
                  (mark-and-expunge -100)

     When you enter the group the first time, you will only see the
     new threads.  You then raise the score of the threads that you
     find interesting (with `I T' or `I S'), and ignore (`C y') the
     rest.  Next time you enter the group, you will see new articles
     in the interesting threads, plus any new threads.

     I.e.---the orphan score atom is for high-volume groups where a
     few interesting threads which can't be found automatically by
     ordinary scoring rules exist.

`adapt'
     This entry controls the adaptive scoring.  If it is `t', the
     default adaptive scoring rules will be used.  If it is `ignore',
     no adaptive scoring will be performed on this group.  If it is a
     list, this list will be used as the adaptive scoring rules.  If
     it isn't present, or is something other than `t' or `ignore', the
     default adaptive scoring rules will be used.  If you want to use
     adaptive scoring on most groups, you'd set
     `gnus-use-adaptive-scoring' to `t', and insert an `(adapt
     ignore)' in the groups where you do not want adaptive scoring.
     If you only want adaptive scoring in a few groups, you'd set
     `gnus-use-adaptive-scoring' to `nil', and insert `(adapt t)' in
     the score files of the groups where you want it.

`adapt-file'
     All adaptive score entries will go to the file named by this
     entry.  It will also be applied when entering the group.  This
     atom might be handy if you want to adapt on several groups at
     once, using the same adaptive file for a number of groups.

`local'
     The value of this entry should be a list of `(VAR VALUE)' pairs.
     Each VAR will be made buffer-local to the current summary buffer,
     and set to the value specified.  This is a convenient, if
     somewhat strange, way of setting variables in some groups if you
     don't like hooks much.  Note that the VALUE won't be evaluated.




File: gnus, Node: Score File Editing, Next: Adaptive Scoring, Prev: Score File Format, Up: Scoring

Score File Editing
==================

You normally enter all scoring commands from the summary buffer, but
you might feel the urge to edit them by hand as well, so we've
supplied you with a mode for that.

It's simply a slightly customized `emacs-lisp' mode, with these
additional commands:


`C-c C-c'
     Save the changes you have made and return to the summary buffer
     (`gnus-score-edit-exit').

`C-c C-d'
     Insert the current date in numerical format
     (`gnus-score-edit-insert-date').  This is really the day number,
     if you were wondering.

`C-c C-p'
     The adaptive score files are saved in an unformatted fashion.  If
     you intend to read one of these files, you want to "pretty print"
     it first.  This command (`gnus-score-pretty-print') does that for
     you.


Type `M-x gnus-score-mode' to use this mode.

`gnus-score-menu-hook' is run in score mode buffers.

In the summary buffer you can use commands like `V f', `V e' and
`V t' to begin editing score files.




File: gnus, Node: Adaptive Scoring, Next: Home Score File, Prev: Score File Editing, Up: Scoring

Adaptive Scoring
================

If all this scoring is getting you down, Gnus has a way of making it
all happen automatically--as if by magic.  Or rather, as if by
artificial stupidity, to be precise.

When you read an article, or mark an article as read, or kill an
article, you leave marks behind.  On exit from the group, Gnus can
sniff these marks and add score elements depending on what marks it
finds.  You turn on this ability by setting
`gnus-use-adaptive-scoring' to `t' or `(line)'.  If you want score
adaptively on separate words appearing in the subjects, you should set
this variable to `(word)'.  If you want to use both adaptive methods,
set this variable to `(word line)'.

To give you complete control over the scoring process, you can
customize the `gnus-default-adaptive-score-alist' variable.  For
instance, it might look something like this:

     (setq gnus-default-adaptive-score-alist
       '((gnus-unread-mark)
         (gnus-ticked-mark (from 4))
         (gnus-dormant-mark (from 5))
         (gnus-del-mark (from -4) (subject -1))
         (gnus-read-mark (from 4) (subject 2))
         (gnus-expirable-mark (from -1) (subject -1))
         (gnus-killed-mark (from -1) (subject -3))
         (gnus-kill-file-mark)
         (gnus-ancient-mark)
         (gnus-low-score-mark)
         (gnus-catchup-mark (from -1) (subject -1))))

As you see, each element in this alist has a mark as a key (either a
variable name or a "real" mark--a character).  Following this key is a
arbitrary number of header/score pairs.  If there are no header/score
pairs following the key, no adaptive scoring will be done on articles
that have that key as the article mark.  For instance, articles with
`gnus-unread-mark' in the example above will not get adaptive score
entries.

Each article can have only one mark, so just a single of these rules
will be applied to each article.

To take `gnus-del-mark' as an example--this alist says that all
articles that have that mark (i.e., are marked with `e') will have a
score entry added to lower based on the `From' header by -4, and
lowered by `Subject' by -1.  Change this to fit your prejudices.

If you have marked 10 articles with the same subject with
`gnus-del-mark', the rule for that mark will be applied ten times.
That means that that subject will get a score of ten times -1, which
should be, unless I'm much mistaken, -10.

If you have auto-expirable (mail) groups (*Note Expiring Mail::), all
the read articles will be marked with the `E' mark.  This'll probably
make adaptive scoring slightly impossible, so auto-expiring and
adaptive scoring doesn't really mix very well.

The headers you can score on are `from', `subject', `message-id',
`references', `xref', `lines', `chars' and `date'.  In addition, you
can score on `followup', which will create an adaptive score entry
that matches on the `References' header using the `Message-ID' of the
current article, thereby matching the following thread.

If you use this scheme, you should set the score file atom `mark' to
something small--like -300, perhaps, to avoid having small random
changes result in articles getting marked as read.

After using adaptive scoring for a week or so, Gnus should start to
become properly trained and enhance the authors you like best, and
kill the authors you like least, without you having to say so
explicitly.

You can control what groups the adaptive scoring is to be performed on
by using the score files (*Note Score File Format::).  This will also
let you use different rules in different groups.

The adaptive score entries will be put into a file where the name is
the group name with `gnus-adaptive-file-suffix' appended.  The default
is `ADAPT'.

Adaptive score files can get huge and are not meant to be edited by
human hands.  If `gnus-adaptive-pretty-print' is `nil' (the deafult)
those files will not be written in a human readable way.

When doing adaptive scoring, substring or fuzzy matching would
probably give you the best results in most cases.  However, if the
header one matches is short, the possibility for false positives is
great, so if the length of the match is less than
`gnus-score-exact-adapt-limit', exact matching will be used.  If this
variable is `nil', exact matching will always be used to avoid this
problem.

As mentioned above, you can adapt either on individual words or entire
headers.  If you adapt on words, the
`gnus-default-adaptive-word-score-alist' variable says what score each
instance of a word should add given a mark.

     (setq gnus-default-adaptive-word-score-alist
           `((,gnus-read-mark . 30)
             (,gnus-catchup-mark . -10)
             (,gnus-killed-mark . -20)
             (,gnus-del-mark . -15)))

This is the default value.  If you have adaption on words enabled,
every word that appears in subjects of articles marked with
`gnus-read-mark' will result in a score rule that increase the score
with 30 points.

Words that appear in the `gnus-default-ignored-adaptive-words' list
will be ignored.  If you wish to add more words to be ignored, use the
`gnus-ignored-adaptive-words' list instead.

Some may feel that short words shouldn't count when doing adaptive
scoring.  If so, you may set `gnus-adaptive-word-length-limit' to an
integer.  Words shorter than this number will be ignored.  This
variable defaults to `nil'.

When the scoring is done, `gnus-adaptive-word-syntax-table' is the
syntax table in effect.  It is similar to the standard syntax table,
but it considers numbers to be non-word-constituent characters.

If `gnus-adaptive-word-minimum' is set to a number, the adaptive word
scoring process will never bring down the score of an article to below
this number.  The default is `nil'.

If `gnus-adaptive-word-no-group-words' is set to `t', gnus won't
adaptively word score any of the words in the group name.  Useful for
groups like `comp.editors.emacs', where most of the subject lines
contain the word `emacs'.

After using this scheme for a while, it might be nice to write a
`gnus-psychoanalyze-user' command to go through the rules and see what
words you like and what words you don't like.  Or perhaps not.

Note that the adaptive word scoring thing is highly experimental and
is likely to change in the future.  Initial impressions seem to
indicate that it's totally useless as it stands.  Some more work
(involving more rigorous statistical methods) will have to be done to
make this useful.




File: gnus, Node: Home Score File, Next: Followups To Yourself, Prev: Adaptive Scoring, Up: Scoring

Home Score File
===============

The score file where new score file entries will go is called the
"home score file".  This is normally (and by default) the score file
for the group itself.  For instance, the home score file for
`gnu.emacs.gnus' is `gnu.emacs.gnus.SCORE'.

However, this may not be what you want.  It is often convenient to
share a common home score file among many groups--all `emacs' groups
could perhaps use the same home score file.

The variable that controls this is `gnus-home-score-file'.  It can be:

  1. A string.  Then this file will be used as the home score file for
     all groups.

  2. A function.  The result of this function will be used as the home
     score file.  The function will be called with the name of the
     group as the parameter.

  3. A list.  The elements in this list can be:

       1. `(REGEXP FILE-NAME)'.  If the REGEXP matches the group name,
          the FILE-NAME will be used as the home score file.

       2. A function.  If the function returns non-`nil', the result
          will be used as the home score file.  The function will be
          called with the name of the group as the parameter.

       3. A string.  Use the string as the home score file.

     The list will be traversed from the beginning towards the end
     looking for matches.


So, if you want to use just a single score file, you could say:

     (setq gnus-home-score-file
           "my-total-score-file.SCORE")

If you want to use `gnu.SCORE' for all `gnu' groups and
`rec.SCORE' for all `rec' groups (and so on), you can say:

     (setq gnus-home-score-file
           'gnus-hierarchial-home-score-file)

This is a ready-made function provided for your convenience.  Other
functions include

`gnus-current-home-score-file'
     Return the "current" regular score file.  This will make scoring
     commands add entry to the "innermost" matching score file.


If you want to have one score file for the `emacs' groups and another
for the `comp' groups, while letting all other groups use their own
home score files:

     (setq gnus-home-score-file
           ;; All groups that match the regexp `"\\.emacs"'
           '(("\\.emacs" "emacs.SCORE")
             ;; All the comp groups in one score file
             ("^comp" "comp.SCORE")))

`gnus-home-adapt-file' works exactly the same way as
`gnus-home-score-file', but says what the home adaptive score file is
instead.  All new adaptive file entries will go into the file
specified by this variable, and the same syntax is allowed.

In addition to using `gnus-home-score-file' and
`gnus-home-adapt-file', you can also use group parameters (*Note Group
Parameters::) and topic parameters (*Note Topic Parameters::) to
achieve much the same.  Group and topic parameters take precedence
over this variable.




File: gnus, Node: Followups To Yourself, Next: Scoring On Other Headers, Prev: Home Score File, Up: Scoring

Followups To Yourself
=====================

Gnus offers two commands for picking out the `Message-ID' header in
the current buffer.  Gnus will then add a score rule that scores using
this `Message-ID' on the `References' header of other articles.  This
will, in effect, increase the score of all articles that respond to
the article in the current buffer.  Quite useful if you want to easily
note when people answer what you've said.


`gnus-score-followup-article'
     This will add a score to articles that directly follow up your
     own article.

`gnus-score-followup-thread'
     This will add a score to all articles that appear in a thread
     below" your own article.

These two functions are both primarily meant to be used in hooks like
`message-sent-hook', like this:
     (add-hook 'message-sent-hook 'gnus-score-followup-thread)


If you look closely at your own `Message-ID', you'll notice that the
first two or three characters are always the same.  Here's two of
mine:

     <x6u3u47icf.fsf@eyesore.no>
     <x6sp9o7ibw.fsf@eyesore.no>

So "my" ident on this machine is `x6'.  This can be exploited--the
following rule will raise the score on all followups to myself:

     ("references"
      ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@.*eyesore\\.no>"
       1000 nil r))

Whether it's the first two or first three characters that are "yours"
is system-dependent.




File: gnus, Node: Scoring On Other Headers, Next: Scoring Tips, Prev: Followups To Yourself, Up: Scoring

Scoring On Other Headers
========================

Gnus is quite fast when scoring the "traditional" headers---`From',
`Subject' and so on.  However, scoring other headers requires writing
a `head' scoring rule, which means that Gnus has to request every
single article from the back end to find matches.  This takes a long
time in big groups.

Now, there's not much you can do about this for news groups, but for
mail groups, you have greater control.  In *Note To From Newsgroups::,
it's explained in greater detail what this mechanism does, but here's
a cookbook example for `nnml' on how to allow scoring on the
`To' and `Cc' headers.

Put the following in your `~/.gnus.el' file.

     (setq gnus-extra-headers '(To Cc Newsgroups Keywords)
           nnmail-extra-headers gnus-extra-headers)

Restart Gnus and rebuild your `nnml' overview files with the `M-x
nnml-generate-nov-databases' command.  This will take a long time if
you have much mail.

Now you can score on `To' and `Cc' as "extra headers" like so: `I e s
p To RET <your name> RET'.

See?  Simple.

You can inhibit scoring the slow scoring on headers or body by setting
the variable `gnus-inhibit-slow-scoring'.  If
`gnus-inhibit-slow-scoring' is regexp, slow scoring is inhibited if
the group matches the regexp.  If it is t, slow scoring on it is
inhibited for all groups.




File: gnus, Node: Scoring Tips, Next: Reverse Scoring, Prev: Scoring On Other Headers, Up: Scoring

Scoring Tips
============


"Crossposts"
     If you want to lower the score of crossposts, the line to match
     on is the `Xref' header.
          ("xref" (" talk.politics.misc:" -1000))

"Multiple crossposts"
     If you want to lower the score of articles that have been
     crossposted to more than, say, 3 groups:
          ("xref"
            ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+"
             -1000 nil r))

"Matching on the body"
     This is generally not a very good idea--it takes a very long
     time.  Gnus actually has to fetch each individual article from
     the server.  But you might want to anyway, I guess.  Even though
     there are three match keys (`Head', `Body' and `All'), you should
     choose one and stick with it in each score file.  If you use any
     two, each article will be fetched *twice*.  If you want to match
     a bit on the `Head' and a bit on the `Body', just use `All' for
     all the matches.

"Marking as read"
     You will probably want to mark articles that have scores below a
     certain number as read.  This is most easily achieved by putting
     the following in your `all.SCORE' file: ((mark -100)) You may
     also consider doing something similar with `expunge'.

"Negated character classes"
     If you say stuff like `[^abcd]*', you may get unexpected results.
     That will match newlines, which might lead to, well, The Unknown.  Say
     `[^abcd\n]*' instead.




File: gnus, Node: Reverse Scoring, Next: Global Score Files, Prev: Scoring Tips, Up: Scoring

Reverse Scoring
===============

If you want to keep just articles that have `Sex with Emacs' in the
subject header, and expunge all other articles, you could put
something like this in your score file:

     (("subject"
       ("Sex with Emacs" 2))
      (mark 1)
      (expunge 1))

So, you raise all articles that match `Sex with Emacs' and mark the
rest as read, and expunge them to boot.




File: gnus, Node: Global Score Files, Next: Kill Files, Prev: Reverse Scoring, Up: Scoring

Global Score Files
==================

Sure, other newsreaders have "global kill files".  These are usually
nothing more than a single kill file that applies to all groups,
stored in the user's home directory.  Bah!  Puny, weak newsreaders!

What I'm talking about here are Global Score Files.  Score files from
all over the world, from users everywhere, uniting all nations in one
big, happy score file union!  Ange-score!  New and untested!

All you have to do to use other people's score files is to set the
`gnus-global-score-files' variable.  One entry for each score file, or
each score file directory.  Gnus will decide by itself what score
files are applicable to which group.

To use the score file
`/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE' and all
score files in the `/ftp@ftp.some-where:/pub/score' directory, say
this:

     (setq gnus-global-score-files
           '("/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
             "/ftp@ftp.some-where:/pub/score/"))

Simple, eh?  Directory names must end with a `/'.  These directories
are typically scanned only once during each Gnus session.  If you feel
the need to manually re-scan the remote directories, you can use the
`gnus-score-search-global-directories' command.

Note that, at present, using this option will slow down group entry
somewhat.  (That is--a lot.)

If you want to start maintaining score files for other people to use,
just put your score file up for anonymous ftp and announce it to the
world.  Become a retro-moderator!  Participate in the retro-moderator
wars sure to ensue, where retro-moderators battle it out for the
sympathy of the people, luring them to use their score files on false
premises!  Yay!  The net is saved!

Here are some tips for the would-be retro-moderator, off the top of my
head:


   * Articles heavily crossposted are probably junk.
   * To lower a single inappropriate article, lower by `Message-ID'.
   * Particularly brilliant authors can be raised on a permanent
     basis.
   * Authors that repeatedly post off-charter for the group can safely
     be lowered out of existence.
   * Set the `mark' and `expunge' atoms to obliterate the nastiest
     articles completely.

   * Use expiring score entries to keep the size of the file down.
     You should probably have a long expiry period, though, as some
     sites keep old articles for a long time.

... I wonder whether other newsreaders will support global score files
in the future.  *Snicker*.  Yup, any day now, newsreaders like Blue
Wave, xrn and 1stReader are bound to implement scoring.  Should we
start holding our breath yet?




File: gnus, Node: Kill Files, Next: Converting Kill Files, Prev: Global Score Files, Up: Scoring

Kill Files
==========

Gnus still supports those pesky old kill files.  In fact, the kill
file entries can now be expiring, which is something I wrote before
Daniel Quinlan thought of doing score files, so I've left the code in
there.

In short, kill processing is a lot slower (and I do mean *a lot*) than
score processing, so it might be a good idea to rewrite your kill
files into score files.

Anyway, a kill file is a normal `emacs-lisp' file.  You can put any
forms into this file, which means that you can use kill files as some
sort of primitive hook function to be run on group entry, even though
that isn't a very good idea.

Normal kill files look like this:

     (gnus-kill "From" "Lars Ingebrigtsen")
     (gnus-kill "Subject" "ding")
     (gnus-expunge "X")

This will mark every article written by me as read, and remove the
marked articles from the summary buffer.  Very useful, you'll agree.

Other programs use a totally different kill file syntax.  If Gnus
encounters what looks like a `rn' kill file, it will take a stab at
interpreting it.

Two summary functions for editing a GNUS kill file:


`M-k'
     Edit this group's kill file (`gnus-summary-edit-local-kill').

`M-K'
     Edit the general kill file (`gnus-summary-edit-global-kill').

Two group mode functions for editing the kill files:


`M-k'
     Edit this group's kill file (`gnus-group-edit-local-kill').

`M-K'
     Edit the general kill file (`gnus-group-edit-global-kill').

Kill file variables:

`gnus-kill-file-name'
     A kill file for the group `soc.motss' is normally called
     `soc.motss.KILL'.  The suffix appended to the group name to get
     this file name is detailed by the `gnus-kill-file-name' variable.
     The "global" kill file (not in the score file sense of "global",
     of course) is just called `KILL'.

`gnus-kill-save-kill-file'
     If this variable is non-`nil', Gnus will save the kill file after
     processing, which is necessary if you use expiring kills.

`gnus-apply-kill-hook'
     A hook called to apply kill files to a group.  It is
     `(gnus-apply-kill-file)' by default.  If you want to ignore the
     kill file if you have a score file for the same group, you can
     set this hook to `(gnus-apply-kill-file-unless-scored)'.  If you
     don't want kill files to be processed, you should set this
     variable to `nil'.

`gnus-kill-file-mode-hook'
     A hook called in kill-file mode buffers.





File: gnus, Node: Converting Kill Files, Next: Advanced Scoring, Prev: Kill Files, Up: Scoring

Converting Kill Files
=====================

If you have loads of old kill files, you may want to convert them into
score files.  If they are "regular", you can use the
`gnus-kill-to-score.el' package; if not, you'll have to do it by hand.

The kill to score conversion package isn't included in Gnus by default.
You can fetch it from
`http://www.stud.ifi.uio.no/~larsi/ding-various/gnus-kill-to-score.el'.

If your old kill files are very complex--if they contain more
non-`gnus-kill' forms than not, you'll have to convert them by hand.
Or just let them be as they are.  Gnus will still use them as before.




File: gnus, Node: Advanced Scoring, Next: Score Decays, Prev: Converting Kill Files, Up: Scoring

Advanced Scoring
================

Scoring on Subjects and From headers is nice enough, but what if
you're really interested in what a person has to say only when she's
talking about a particular subject?  Or what if you really don't want
to read what person A has to say when she's following up to person B,
but want to read what she says when she's following up to person C?

By using advanced scoring rules you may create arbitrarily complex
scoring patterns.

* Menu:

* Advanced Scoring Syntax::     A definition.
* Advanced Scoring Examples::   What they look like.
* Advanced Scoring Tips::       Getting the most out of it.




File: gnus, Node: Advanced Scoring Syntax, Next: Advanced Scoring Examples, Prev: Advanced Scoring, Up: Advanced Scoring

Advanced Scoring Syntax
-----------------------

Ordinary scoring rules have a string as the first element in the rule.
Advanced scoring rules have a list as the first element.  The second
element is the score to be applied if the first element evaluated to a
non-`nil' value.

These lists may consist of three logical operators, one redirection
operator, and various match operators.

Logical operators:

`&'
`and'
     This logical operator will evaluate each of its arguments until it finds
     one that evaluates to `false', and then it'll stop.  If all arguments
     evaluate to `true' values, then this operator will return
     `true'.

`|'
`or'
     This logical operator will evaluate each of its arguments until
     it finds one that evaluates to `true'.  If no arguments are
     `true', then this operator will return `false'.

`!'
`not'
`'
     This logical operator only takes a single argument.  It returns
     the logical negation of the value of its argument.


There is an "indirection operator" that will make its arguments apply
to the ancestors of the current article being scored.  For instance,
`1-' will make score rules apply to the parent of the current article.
`2-' will make score rules apply to the grandparent of the current
article.  Alternatively, you can write `^^', where the number of `^'s
(carets) says how far back into the ancestry you want to go.

Finally, we have the match operators.  These are the ones that do the
real work.  Match operators are header name strings followed by a
match and a match type.  A typical match operator looks like `("from"
Lars Ingebrigtsen" s)'.  The header names are the same as when using
simple scoring, and the match types are also the same.




File: gnus, Node: Advanced Scoring Examples, Next: Advanced Scoring Tips, Prev: Advanced Scoring Syntax, Up: Advanced Scoring

Advanced Scoring Examples
-------------------------

Please note that the following examples are score file rules.  To make
a complete score file from them, surround them with another pair of
parentheses.

Let's say you want to increase the score of articles written by Lars
when he's talking about Gnus:

     ((&
       ("from" "Lars Ingebrigtsen")
       ("subject" "Gnus"))
      1000)

Quite simple, huh?

When he writes long articles, he sometimes has something nice to say:

     ((&
       ("from" "Lars Ingebrigtsen")
       (|
        ("subject" "Gnus")
        ("lines" 100 >)))
      1000)

However, when he responds to things written by Reig Eigil Logge, you
really don't want to read what he's written:

     ((&
       ("from" "Lars Ingebrigtsen")
       (1- ("from" "Reig Eigil Logge")))
      -100000)

Everybody that follows up Redmondo when he writes about disappearing
socks should have their scores raised, but only when they talk about
white socks.  However, when Lars talks about socks, it's usually not
very interesting:

     ((&
       (1-
        (&
         ("from" "redmondo@.*no" r)
         ("body" "disappearing.*socks" t)))
       (! ("from" "Lars Ingebrigtsen"))
       ("body" "white.*socks"))
      1000)

Suppose you're reading a high volume group and you're only interested
in replies. The plan is to score down all articles that don't have
subject that begin with "Re:", "Fw:" or "Fwd:" and then score up all
parents of articles that have subjects that begin with reply marks.

     ((! ("subject" "re:\\|fwd?:" r))
       -200)
     ((1- ("subject" "re:\\|fwd?:" r))
       200)

The possibilities are endless.



File: gnus, Node: Advanced Scoring Tips, Prev: Advanced Scoring Examples, Up: Advanced Scoring

Advanced Scoring Tips
---------------------

The `&' and `|' logical operators do short-circuit logic.
That is, they stop processing their arguments when it's clear what the
result of the operation will be.  For instance, if one of the arguments
of an `&' evaluates to `false', there's no point in evaluating
the rest of the arguments.  This means that you should put slow matches
(`body', `header') last and quick matches (`from',
`subject') first.

The indirection arguments (`1-' and so on) will make their arguments
work on previous generations of the thread.  If you say something
like:

     ...
     (1-
      (1-
       ("from" "lars")))
     ...

Then that means "score on the from header of the grandparent of the
current article".  An indirection is quite fast, but it's better to
say:

     (1-
      (&
       ("from" "Lars")
       ("subject" "Gnus")))

than it is to say:

     (&
      (1- ("from" "Lars"))
      (1- ("subject" "Gnus")))




File: gnus, Node: Score Decays, Prev: Advanced Scoring, Up: Scoring

Score Decays
============

You may find that your scores have a tendency to grow without bounds,
especially if you're using adaptive scoring.  If scores get too big,
they lose all meaning--they simply max out and it's difficult to use
them in any sensible way.

Gnus provides a mechanism for decaying scores to help with this
problem.  When score files are loaded and `gnus-decay-scores' is
non-`nil', Gnus will run the score files through the decaying
mechanism thereby lowering the scores of all non-permanent score
rules.  If `gnus-decay-scores' is a regexp, only score files matching
this regexp are treated.  E.g. you may set it to `\\.ADAPT\\'' if only
*adaptive* score files should be decayed.  The decay itself if
performed by the `gnus-decay-score-function' function, which is
`gnus-decay-score' by default.  Here's the definition of that
function:

     (defun gnus-decay-score (score)
       "Decay SCORE according to `gnus-score-decay-constant'
     and `gnus-score-decay-scale'."
       (let ((n (- score
                   (* (if (< score 0) -1 1)
                      (min (abs score)
                           (max gnus-score-decay-constant
                                (* (abs score)
                                   gnus-score-decay-scale)))))))
         (if (and (featurep 'xemacs)
                  ;; XEmacs' floor can handle only the floating point
                  ;; number below the half of the maximum integer.
                  (> (abs n) (lsh -1 -2)))
             (string-to-number
              (car (split-string (number-to-string n) "\\.")))
           (floor n))))

`gnus-score-decay-constant' is 3 by default and
`gnus-score-decay-scale' is 0.05.  This should cause the following:

  1. Scores between -3 and 3 will be set to 0 when this function is
     called.

  2. Scores with magnitudes between 3 and 60 will be shrunk by 3.

  3. Scores with magnitudes greater than 60 will be shrunk by 5% of
     the score.

If you don't like this decay function, write your own.  It is called
with the score to be decayed as its only parameter, and it should
return the new score, which should be an integer.

Gnus will try to decay scores once a day.  If you haven't run Gnus for
four days, Gnus will decay the scores four times, for instance.




File: gnus, Node: Various, Next: The End, Prev: Scoring, Up: Top

Various
*******

* Menu:

* Process/Prefix::              A convention used by many treatment commands.
* Interactive::                 Making Gnus ask you many questions.
* Symbolic Prefixes::           How to supply some Gnus functions with options.
* Formatting Variables::        You can specify what buffers should look like.
* Window Layout::               Configuring the Gnus buffer windows.
* Faces and Fonts::             How to change how faces look.
* Compilation::                 How to speed Gnus up.
* Mode Lines::                  Displaying information in the mode lines.
* Highlighting and Menus::      Making buffers look all nice and cozy.
* Buttons::                     Get tendinitis in ten easy steps!
* Daemons::                     Gnus can do things behind your back.
* NoCeM::                       How to avoid spam and other fatty foods.
* Undo::                        Some actions can be undone.
* Predicate Specifiers::        Specifying predicates.
* Moderation::                  What to do if you're a moderator.
* Fetching a Group::            Starting Gnus just to read a group.
* Image Enhancements::          Modern versions of Emacs/XEmacs can display images.
* Fuzzy Matching::              What's the big fuzz?
* Thwarting Email Spam::        Simple ways to avoid unsolicited commercial email.
* Spam Package::                A package for filtering and processing spam.
* Other modes::                 Interaction with other modes.
* Various Various::             Things that are really various.




File: gnus, Node: Process/Prefix, Next: Interactive, Prev: Various, Up: Various

Process/Prefix
==============

Many functions, among them functions for moving, decoding and saving
articles, use what is known as the "Process/Prefix convention".

This is a method for figuring out what articles the user wants the
command to be performed on.

It goes like this:

If the numeric prefix is N, perform the operation on the next N
articles, starting with the current one.  If the numeric prefix is
negative, perform the operation on the previous N articles, starting
with the current one.

If `transient-mark-mode' in non-`nil' and the region is active, all
articles in the region will be worked upon.

If there is no numeric prefix, but some articles are marked with the
process mark, perform the operation on the articles marked with the
process mark.

If there is neither a numeric prefix nor any articles marked with the
process mark, just perform the operation on the current article.

Quite simple, really, but it needs to be made clear so that surprises
are avoided.

Commands that react to the process mark will push the current list of
process marked articles onto a stack and will then clear all process
marked articles.  You can restore the previous configuration with the
`M P y' command (*Note Setting Process Marks::).

One thing that seems to shock & horrify lots of people is that, for
instance, `3 d' does exactly the same as `d' `d' `d'.
Since each `d' (which marks the current article as read) by default
goes to the next unread article after marking, this means that `3 d'
will mark the next three unread articles as read, no matter what the
summary buffer looks like.  Set `gnus-summary-goto-unread' to
`nil' for a more straightforward action.

Many commands do not use the process/prefix convention.  All commands
that do explicitly say so in this manual.  To apply the process/prefix
convention to commands that do not use it, you can use the `M-&'
command.  For instance, to mark all the articles in the group as
expirable, you could say `M P b M-& E'.




File: gnus, Node: Interactive, Next: Symbolic Prefixes, Prev: Process/Prefix, Up: Various

Interactive
===========


`gnus-novice-user'
     If this variable is non-`nil', you are either a newcomer to the
     World of Usenet, or you are very cautious, which is a nice thing
     to be, really.  You will be given questions of the type "Are you
     sure you want to do this?" before doing anything dangerous.  This
     is `t' by default.

`gnus-expert-user'
     If this variable is non-`nil', you will seldom be asked any
     questions by Gnus.  It will simply assume you know what you're
     doing, no matter how strange.

`gnus-interactive-catchup'
     Require confirmation before catching up a group if non-`nil'.  It
     is `t' by default.

`gnus-interactive-exit'
     Require confirmation before exiting Gnus.  This variable is `t'
     by default.




File: gnus, Node: Symbolic Prefixes, Next: Formatting Variables, Prev: Interactive, Up: Various

Symbolic Prefixes
=================

Quite a lot of Emacs commands react to the (numeric) prefix.  For
instance, `C-u 4 C-f' moves point four characters forward, and `C-u 9
0 0 I s s p' adds a permanent `Subject' substring score rule of 900 to
the current article.

This is all nice and well, but what if you want to give a command some
additional information?  Well, what most commands do is interpret the
raw" prefix in some special way.  `C-u 0 C-x C-s' means that one
doesn't want a backup file to be created when saving the current
buffer, for instance.  But what if you want to save without making a
backup file, and you want Emacs to flash lights and play a nice tune
at the same time?  You can't, and you're probably perfectly happy that
way.

I'm not, so I've added a second prefix--the "symbolic prefix".  The
prefix key is `M-i' (`gnus-symbolic-argument'), and the next
character typed in is the value.  You can stack as many `M-i'
prefixes as you want.  `M-i a C-M-u' means "feed the `C-M-u'
command the symbolic prefix `a'".  `M-i a M-i b C-M-u' means
"feed the `C-M-u' command the symbolic prefixes `a' and
`b'".  You get the drift.

Typing in symbolic prefixes to commands that don't accept them doesn't
hurt, but it doesn't do any good either.  Currently not many Gnus
functions make use of the symbolic prefix.

If you're interested in how Gnus implements this, *Note Extended
Interactive::.




File: gnus, Node: Formatting Variables, Next: Window Layout, Prev: Symbolic Prefixes, Up: Various

Formatting Variables
====================

Throughout this manual you've probably noticed lots of variables
called things like `gnus-group-line-format' and
`gnus-summary-mode-line-format'.  These control how Gnus is to output
lines in the various buffers.  There's quite a lot of them.
Fortunately, they all use the same syntax, so there's not that much to
be annoyed by.

Here's an example format spec (from the group buffer): `%M%S%5y:
%(%g%)\n'.  We see that it is indeed extremely ugly, and that there
are lots of percentages everywhere.

* Menu:

* Formatting Basics::           A formatting variable is basically a format string.
* Mode Line Formatting::        Some rules about mode line formatting variables.
* Advanced Formatting::         Modifying output in various ways.
* User-Defined Specs::          Having Gnus call your own functions.
* Formatting Fonts::            Making the formatting look colorful and nice.
* Positioning Point::           Moving point to a position after an operation.
* Tabulation::                  Tabulating your output.
* Wide Characters::             Dealing with wide characters.

Currently Gnus uses the following formatting variables:
`gnus-group-line-format', `gnus-summary-line-format',
`gnus-server-line-format', `gnus-topic-line-format',
`gnus-group-mode-line-format',
`gnus-summary-mode-line-format',
`gnus-article-mode-line-format',
`gnus-server-mode-line-format', and
`gnus-summary-pick-line-format'.

All these format variables can also be arbitrary elisp forms.  In that
case, they will be `eval'ed to insert the required lines.

Gnus includes a command to help you while creating your own format
specs.  `M-x gnus-update-format' will `eval' the current form, update
the spec in question and pop you to a buffer where you can examine the
resulting Lisp code to be run to generate the line.





File: gnus, Node: Formatting Basics, Next: Mode Line Formatting, Prev: Formatting Variables, Up: Formatting Variables

Formatting Basics
-----------------

Each `%' element will be replaced by some string or other when the
buffer in question is generated.  `%5y' means "insert the `y' spec,
and pad with spaces to get a 5-character field".

As with normal C and Emacs Lisp formatting strings, the numerical
modifier between the `%' and the formatting type character will "pad"
the output so that it is always at least that long.  `%5y' will make
the field always (at least) five characters wide by padding with
spaces to the left.  If you say `%-5y', it will pad to the right
instead.

You may also wish to limit the length of the field to protect against
particularly wide values.  For that you can say `%4,6y', which means
that the field will never be more than 6 characters wide and never
less than 4 characters wide.

Also Gnus supports some extended format specifications, such as
`%&user-date;'.




File: gnus, Node: Mode Line Formatting, Next: Advanced Formatting, Prev: Formatting Basics, Up: Formatting Variables

Mode Line Formatting
--------------------

Mode line formatting variables (e.g., `gnus-summary-mode-line-format')
follow the same rules as other, buffer line oriented formatting
variables (*Note Formatting Basics::) with the following two
differences:


  1. There must be no newline (`\n') at the end.

  2. The special `%%b' spec can be used to display the buffer name.
     Well, it's no spec at all, really---`%%' is just a way to quote
     `%' to allow it to pass through the formatting machinery unmangled,
     so that Emacs receives `%b', which is something the Emacs mode line
     display interprets to mean "show the buffer name".  For a full list of
     mode line specs Emacs understands, see the documentation of the
     `mode-line-format' variable.





File: gnus, Node: Advanced Formatting, Next: User-Defined Specs, Prev: Mode Line Formatting, Up: Formatting Variables

Advanced Formatting
-------------------

It is frequently useful to post-process the fields in some way.
Padding, limiting, cutting off parts and suppressing certain values
can be achieved by using "tilde modifiers".  A typical tilde spec
might look like `%~(cut 3)~(ignore "0")y'.

These are the valid modifiers:

`pad'
`pad-left'
     Pad the field to the left with spaces until it reaches the
     required length.

`pad-right'
     Pad the field to the right with spaces until it reaches the
     required length.

`max'
`max-left'
     Cut off characters from the left until it reaches the specified
     length.

`max-right'
     Cut off characters from the right until it reaches the specified
     length.

`cut'
`cut-left'
     Cut off the specified number of characters from the left.

`cut-right'
     Cut off the specified number of characters from the right.

`ignore'
     Return an empty string if the field is equal to the specified
     value.

`form'
     Use the specified form as the field value when the `@' spec is
     used.

     Here's an example:

          "~(form (current-time-string))@"


Let's take an example.  The `%o' spec in the summary mode lines will
return a date in compact ISO8601 format---`19960809T230410'.  This is
quite a mouthful, so we want to shave off the century number and the
time, leaving us with a six-character date.  That would be
`%~(cut-left 2)~(max-right 6)~(pad 6)o'.  (Cutting is done before
maxing, and we need the padding to ensure that the date is never less
than 6 characters to make it look nice in columns.)

Ignoring is done first; then cutting; then maxing; and then as the
very last operation, padding.

If you use lots of these advanced thingies, you'll find that Gnus gets
quite slow.  This can be helped enormously by running `M-x
gnus-compile' when you are satisfied with the look of your lines.
*Note Compilation::.




File: gnus, Node: User-Defined Specs, Next: Formatting Fonts, Prev: Advanced Formatting, Up: Formatting Variables

User-Defined Specs
------------------

All the specs allow for inserting user defined specifiers---`u'.  The
next character in the format string should be a letter.  Gnus will
call the function `gnus-user-format-function-'`X', where `X' is the
letter following `%u'.  The function will be passed a single
parameter--what the parameter means depends on what buffer it's being
called from.  The function should return a string, which will be
inserted into the buffer just like information from any other
specifier.  This function may also be called with dummy values, so it
should protect against that.

Also Gnus supports extended user-defined specs, such as `%u&foo;'.
Gnus will call the function `gnus-user-format-function-'`foo'.

You can also use tilde modifiers (*Note Advanced Formatting:: to
achieve much the same without defining new functions.  Here's an
example: `%~(form (count-lines (point-min) (point)))@'.  The form
given here will be evaluated to yield the current line number, and
then inserted.




File: gnus, Node: Formatting Fonts, Next: Positioning Point, Prev: User-Defined Specs, Up: Formatting Variables

Formatting Fonts
----------------

There are specs for highlighting, and these are shared by all the
format variables.  Text inside the `%(' and `%)' specifiers will get
the special `mouse-face' property set, which means that it will be
highlighted (with `gnus-mouse-face') when you put the mouse pointer
over it.

Text inside the `%{' and `%}' specifiers will have their
normal faces set using `gnus-face-0', which is `bold' by
default.  If you say `%1{', you'll get `gnus-face-1' instead,
and so on.  Create as many faces as you wish.  The same goes for the
`mouse-face' specs--you can say `%3(hello%)' to have
`hello' mouse-highlighted with `gnus-mouse-face-3'.

Text inside the `%<<' and `%>>' specifiers will get the special
`balloon-help' property set to `gnus-balloon-face-0'.  If you say
`%1<<', you'll get `gnus-balloon-face-1' and so on.  The
`gnus-balloon-face-*' variables should be either strings or symbols
naming functions that return a string.  When the mouse passes over
text with this property set, a balloon window will appear and display
the string.  Please refer to *Note Tooltips: (emacs)Tooltips, (in GNU
Emacs) or the doc string of `balloon-help-mode' (in XEmacs) for more
information on this.  (For technical reasons, the guillemets have been
approximated as `<<' and `>>' in this paragraph.)

Here's an alternative recipe for the group buffer:

     ;; Create three face types.
     (setq gnus-face-1 'bold)
     (setq gnus-face-3 'italic)

     ;; We want the article count to be in
     ;; a bold and green face.  So we create
     ;; a new face called `my-green-bold'.
     (copy-face 'bold 'my-green-bold)
     ;; Set the color.
     (set-face-foreground 'my-green-bold "ForestGreen")
     (setq gnus-face-2 'my-green-bold)

     ;; Set the new & fancy format.
     (setq gnus-group-line-format
           "%M%S%3{%5y%}%2[:%] %(%1{%g%}%)\n")

I'm sure you'll be able to use this scheme to create totally
unreadable and extremely vulgar displays.  Have fun!

Note that the `%(' specs (and friends) do not make any sense on the
mode-line variables.



File: gnus, Node: Positioning Point, Next: Tabulation, Prev: Formatting Fonts, Up: Formatting Variables

Positioning Point
-----------------

Gnus usually moves point to a pre-defined place on each line in most
buffers.  By default, point move to the first colon character on the
line.  You can customize this behavior in three different ways.

You can move the colon character to somewhere else on the line.

You can redefine the function that moves the point to the colon.  The
function is called `gnus-goto-colon'.

But perhaps the most convenient way to deal with this, if you don't
want to have a colon in your line, is to use the `%*' specifier.  If
you put a `%*' somewhere in your format line definition, Gnus will
place point there.




File: gnus, Node: Tabulation, Next: Wide Characters, Prev: Positioning Point, Up: Formatting Variables

Tabulation
----------

You can usually line up your displays by padding and cutting your
strings.  However, when combining various strings of different size,
it can often be more convenient to just output the strings, and then
worry about lining up the following text afterwards.

To do that, Gnus supplies tabulator specs---`%='.  There are two
different types---"hard tabulators" and "soft tabulators".

`%50=' will insert space characters to pad the line up to column 50.
If the text is already past column 50, nothing will be inserted.  This
is the soft tabulator.

`%-50=' will insert space characters to pad the line up to column 50.
If the text is already past column 50, the excess text past column 50
will be removed.  This is the hard tabulator.




File: gnus, Node: Wide Characters, Prev: Tabulation, Up: Formatting Variables

Wide Characters
---------------

Fixed width fonts in most countries have characters of the same width.
Some countries, however, use Latin characters mixed with wider
characters--most notable East Asian countries.

The problem is that when formatting, Gnus assumes that if a string is
10 characters wide, it'll be 10 Latin characters wide on the screen.
In these countries, that's not true.

To help fix this, you can set `gnus-use-correct-string-widths' to `t'.
This makes buffer generation slower, but the results will be prettier.
The default value under XEmacs is `t' but `nil' for Emacs.




File: gnus, Node: Window Layout, Next: Faces and Fonts, Prev: Formatting Variables, Up: Various

Window Layout
=============

No, there's nothing here about X, so be quiet.

If `gnus-use-full-window' non-`nil', Gnus will delete all
other windows and occupy the entire Emacs screen by itself.  It is
`t' by default.

Setting this variable to `nil' kinda works, but there are glitches.
Use at your own peril.

`gnus-buffer-configuration' describes how much space each Gnus buffer
should be given.  Here's an excerpt of this variable:

     ((group (vertical 1.0 (group 1.0 point)
                           (if gnus-carpal (group-carpal 4))))
      (article (vertical 1.0 (summary 0.25 point)
                             (article 1.0))))

This is an alist.  The "key" is a symbol that names some action or
other.  For instance, when displaying the group buffer, the window
configuration function will use `group' as the key.  A full list of
possible names is listed below.

The "value" (i.e., the "split") says how much space each buffer should
occupy.  To take the `article' split as an example -

     (article (vertical 1.0 (summary 0.25 point)
                            (article 1.0)))

This "split" says that the summary buffer should occupy 25% of upper
half of the screen, and that it is placed over the article buffer.  As
you may have noticed, 100% + 25% is actually 125% (yup, I saw y'all
reaching for that calculator there).  However, the special number
`1.0' is used to signal that this buffer should soak up all the rest
of the space available after the rest of the buffers have taken
whatever they need.  There should be only one buffer with the `1.0'
size spec per split.

Point will be put in the buffer that has the optional third element
`point'.  In a `frame' split, the last subsplit having a leaf split
where the tag `frame-focus' is a member (i.e. is the third or fourth
element in the list, depending on whether the `point' tag is present)
gets focus.

Here's a more complicated example:

     (article (vertical 1.0 (group 4)
                            (summary 0.25 point)
                            (if gnus-carpal (summary-carpal 4))
                            (article 1.0)))

If the size spec is an integer instead of a floating point number,
then that number will be used to say how many lines a buffer should
occupy, not a percentage.

If the "split" looks like something that can be `eval'ed (to be
precise--if the `car' of the split is a function or a subr), this
split will be `eval'ed.  If the result is non-`nil', it will be used
as a split.  This means that there will be three buffers if
`gnus-carpal' is `nil', and four buffers if `gnus-carpal' is
non-`nil'.

Not complicated enough for you?  Well, try this on for size:

     (article (horizontal 1.0
                  (vertical 0.5
                      (group 1.0)
                      (gnus-carpal 4))
                  (vertical 1.0
                      (summary 0.25 point)
                      (summary-carpal 4)
                      (article 1.0))))

Whoops.  Two buffers with the mystery 100% tag.  And what's that
`horizontal' thingie?

If the first element in one of the split is `horizontal', Gnus will
split the window horizontally, giving you two windows side-by-side.
Inside each of these strips you may carry on all you like in the
normal fashion.  The number following `horizontal' says what
percentage of the screen is to be given to this strip.

For each split, there *must* be one element that has the 100% tag.
The splitting is never accurate, and this buffer will eat any leftover
lines from the splits.

To be slightly more formal, here's a definition of what a valid split
may look like:

     split      = frame | horizontal | vertical | buffer | form
     frame      = "(frame " size *split ")"
     horizontal = "(horizontal " size *split ")"
     vertical   = "(vertical " size *split ")"
     buffer     = "(" buf-name " " size *[ "point" ] *[ "frame-focus"] ")"
     size       = number | frame-params
     buf-name   = group | article | summary ...

The limitations are that the `frame' split can only appear as the
top-level split.  FORM should be an Emacs Lisp form that should return
a valid split.  We see that each split is fully recursive, and may
contain any number of `vertical' and `horizontal' splits.

Finding the right sizes can be a bit complicated.  No window may be
less than `gnus-window-min-height' (default 1) characters high, and
all windows must be at least `gnus-window-min-width' (default 1)
characters wide.  Gnus will try to enforce this before applying the
splits.  If you want to use the normal Emacs window width/height
limit, you can just set these two variables to `nil'.

If you're not familiar with Emacs terminology, `horizontal' and
`vertical' splits may work the opposite way of what you'd expect.
Windows inside a `horizontal' split are shown side-by-side, and
windows within a `vertical' split are shown above each other.

If you want to experiment with window placement, a good tip is to call
`gnus-configure-frame' directly with a split.  This is the function
that does all the real work when splitting buffers.  Below is a pretty
nonsensical configuration with 5 windows; two for the group buffer and
three for the article buffer.  (I said it was nonsensical.)  If you
`eval' the statement below, you can get an idea of how that would look
straight away, without going through the normal Gnus channels.  Play
with it until you're satisfied, and then use `gnus-add-configuration'
to add your new creation to the buffer configuration list.

     (gnus-configure-frame
      '(horizontal 1.0
         (vertical 10
           (group 1.0)
           (article 0.3 point))
         (vertical 1.0
           (article 1.0)
           (horizontal 4
             (group 1.0)
             (article 10)))))

You might want to have several frames as well.  No prob--just use the
`frame' split:

     (gnus-configure-frame
      '(frame 1.0
              (vertical 1.0
                        (summary 0.25 point frame-focus)
                        (article 1.0))
              (vertical ((height . 5) (width . 15)
                         (user-position . t)
                         (left . -1) (top . 1))
                        (picon 1.0))))


This split will result in the familiar summary/article window
configuration in the first (or "main") frame, while a small additional
frame will be created where picons will be shown.  As you can see,
instead of the normal `1.0' top-level spec, each additional split
should have a frame parameter alist as the size spec.  *Note Frame
Parameters: (elisp)Frame Parameters.  Under XEmacs, a frame property
list will be accepted, too--for instance, `(height 5 width 15 left -1
top 1)' is such a plist.  The list of all possible keys for
`gnus-buffer-configuration' can be found in its default value.

Note that the `message' key is used for both `gnus-group-mail' and
`gnus-summary-mail-other-window'.  If it is desirable to distinguish
between the two, something like this might be used:

     (message (horizontal 1.0
                          (vertical 1.0 (message 1.0 point))
                          (vertical 0.24
                                    (if (buffer-live-p gnus-summary-buffer)
                                        '(summary 0.5))
                                    (group 1.0))))

One common desire for a multiple frame split is to have a separate
frame for composing mail and news while leaving the original frame
intact.  To accomplish that, something like the following can be done:

     (message
       (frame 1.0
              (if (not (buffer-live-p gnus-summary-buffer))
                  (car (cdr (assoc 'group gnus-buffer-configuration)))
                (car (cdr (assoc 'summary gnus-buffer-configuration))))
              (vertical ((user-position . t) (top . 1) (left . 1)
                         (name . "Message"))
                        (message 1.0 point))))

Since the `gnus-buffer-configuration' variable is so long and
complicated, there's a function you can use to ease changing the
config of a single setting: `gnus-add-configuration'.  If, for
instance, you want to change the `article' setting, you could say:

     (gnus-add-configuration
      '(article (vertical 1.0
                    (group 4)
                    (summary .25 point)
                    (article 1.0))))

You'd typically stick these `gnus-add-configuration' calls in your
`~/.gnus.el' file or in some startup hook--they should be run after
Gnus has been loaded.

If all windows mentioned in the configuration are already visible, Gnus
won't change the window configuration.  If you always want to force the
"right" window configuration, you can set
`gnus-always-force-window-configuration' to non-`nil'.

If you're using tree displays (*Note Tree Display::), and the tree
window is displayed vertically next to another window, you may also
want to fiddle with `gnus-tree-minimize-window' to avoid having the
windows resized.


Example Window Configurations
-----------------------------

   * Narrow left hand side occupied by group buffer.  Right hand side
     split between summary buffer (top one-sixth) and article buffer
     (bottom).

          +---+---------+
          | G | Summary |
          | r +---------+
          | o |         |
          | u | Article |
          | p |         |
          +---+---------+

          (gnus-add-configuration
           '(article
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0
                                   (summary 0.16 point)
                                   (article 1.0)))))

          (gnus-add-configuration
           '(summary
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0 (summary 1.0 point)))))





File: gnus, Node: Faces and Fonts, Next: Compilation, Prev: Window Layout, Up: Various

Faces and Fonts
===============

Fiddling with fonts and faces used to be very difficult, but these
days it is very simple.  You simply say `M-x customize-face', pick out
the face you want to alter, and alter it via the standard Customize
interface.




File: gnus, Node: Compilation, Next: Mode Lines, Prev: Faces and Fonts, Up: Various

Compilation
===========


Remember all those line format specification variables?
`gnus-summary-line-format', `gnus-group-line-format', and so on.  Now,
Gnus will of course heed whatever these variables are, but,
unfortunately, changing them will mean a quite significant slow-down.
(The default values of these variables have byte-compiled functions
associated with them, while the user-generated versions do not, of
course.)

To help with this, you can run `M-x gnus-compile' after you've fiddled
around with the variables and feel that you're (kind of) satisfied.
This will result in the new specs being byte-compiled, and you'll get
top speed again.  Gnus will save these compiled specs in the
`.newsrc.eld' file.  (User-defined functions aren't compiled by this
function, though--you should compile them yourself by sticking them
into the `~/.gnus.el' file and byte-compiling that file.)




File: gnus, Node: Mode Lines, Next: Highlighting and Menus, Prev: Compilation, Up: Various

Mode Lines
==========

`gnus-updated-mode-lines' says what buffers should keep their mode
lines updated.  It is a list of symbols.  Supported symbols include
`group', `article', `summary', `server', `browse', and `tree'.  If the
corresponding symbol is present, Gnus will keep that mode line updated
with information that may be pertinent.  If this variable is `nil',
screen refresh may be quicker.


By default, Gnus displays information on the current article in the
mode lines of the summary and article buffers.  The information Gnus
wishes to display (e.g. the subject of the article) is often longer
than the mode lines, and therefore have to be cut off at some point.
The `gnus-mode-non-string-length' variable says how long the other
elements on the line is (i.e., the non-info part).  If you put
additional elements on the mode line (e.g. a clock), you should modify
this variable:

     (add-hook 'display-time-hook
               (lambda () (setq gnus-mode-non-string-length
                                (+ 21
                                   (if line-number-mode 5 0)
                                   (if column-number-mode 4 0)
                                   (length display-time-string)))))

If this variable is `nil' (which is the default), the mode line
strings won't be chopped off, and they won't be padded either.  Note
that the default is unlikely to be desirable, as even the percentage
complete in the buffer may be crowded off the mode line; the user
should configure this variable appropriately for her configuration.




File: gnus, Node: Highlighting and Menus, Next: Buttons, Prev: Mode Lines, Up: Various

Highlighting and Menus
======================

The `gnus-visual' variable controls most of the Gnus-prettifying
aspects.  If `nil', Gnus won't attempt to create menus or use fancy
colors or fonts.  This will also inhibit loading the `gnus-vis.el'
file.

This variable can be a list of visual properties that are enabled.
The following elements are valid, and are all included by default:

`group-highlight'
     Do highlights in the group buffer.
`summary-highlight'
     Do highlights in the summary buffer.
`article-highlight'
     Do highlights in the article buffer.
`highlight'
     Turn on highlighting in all buffers.
`group-menu'
     Create menus in the group buffer.
`summary-menu'
     Create menus in the summary buffers.
`article-menu'
     Create menus in the article buffer.
`browse-menu'
     Create menus in the browse buffer.
`server-menu'
     Create menus in the server buffer.
`score-menu'
     Create menus in the score buffers.
`menu'
     Create menus in all buffers.

So if you only want highlighting in the article buffer and menus in
all buffers, you could say something like:

     (setq gnus-visual '(article-highlight menu))

If you want highlighting only and no menus whatsoever, you'd say:

     (setq gnus-visual '(highlight))

If `gnus-visual' is `t', highlighting and menus will be used in all
Gnus buffers.

Other general variables that influence the look of all buffers
include:

`gnus-mouse-face'
     This is the face (i.e., font) used for mouse highlighting in
     Gnus.  No mouse highlights will be done if `gnus-visual' is
     `nil'.


There are hooks associated with the creation of all the different
menus:


`gnus-article-menu-hook'
     Hook called after creating the article mode menu.

`gnus-group-menu-hook'
     Hook called after creating the group mode menu.

`gnus-summary-menu-hook'
     Hook called after creating the summary mode menu.

`gnus-server-menu-hook'
     Hook called after creating the server mode menu.

`gnus-browse-menu-hook'
     Hook called after creating the browse mode menu.

`gnus-score-menu-hook'
     Hook called after creating the score mode menu.





File: gnus, Node: Buttons, Next: Daemons, Prev: Highlighting and Menus, Up: Various

Buttons
=======

Those new-fangled "mouse" contraptions is very popular with the young,
hep kids who don't want to learn the proper way to do things these
days.  Why, I remember way back in the summer of '89, when I was using
Emacs on a Tops 20 system.  Three hundred users on one single machine,
and every user was running Simula compilers.  Bah!

Right.

Well, you can make Gnus display bufferfuls of buttons you can click to
do anything by setting `gnus-carpal' to `t'.  Pretty simple, really.
Tell the chiropractor I sent you.



`gnus-carpal-mode-hook'
     Hook run in all carpal mode buffers.

`gnus-carpal-button-face'
     Face used on buttons.

`gnus-carpal-header-face'
     Face used on carpal buffer headers.

`gnus-carpal-group-buffer-buttons'
     Buttons in the group buffer.

`gnus-carpal-summary-buffer-buttons'
     Buttons in the summary buffer.

`gnus-carpal-server-buffer-buttons'
     Buttons in the server buffer.

`gnus-carpal-browse-buffer-buttons'
     Buttons in the browse buffer.

All the `buttons' variables are lists.  The elements in these list are
either cons cells where the `car' contains a text to be displayed and
the `cdr' contains a function symbol, or a simple string.




File: gnus, Node: Daemons, Next: NoCeM, Prev: Buttons, Up: Various

Daemons
=======

Gnus, being larger than any program ever written (allegedly), does
lots of strange stuff that you may wish to have done while you're not
present.  For instance, you may want it to check for new mail once in
a while.  Or you may want it to close down all connections to all
servers when you leave Emacs idle.  And stuff like that.

Gnus will let you do stuff like that by defining various
"handlers".  Each handler consists of three elements:  A
FUNCTION, a TIME, and an IDLE parameter.

Here's an example of a handler that closes connections when Emacs has
been idle for thirty minutes:

     (gnus-demon-close-connections nil 30)

Here's a handler that scans for PGP headers every hour when Emacs is
idle:

     (gnus-demon-scan-pgp 60 t)

This TIME parameter and that IDLE parameter work together
in a strange, but wonderful fashion.  Basically, if IDLE is
`nil', then the function will be called every TIME minutes.

If IDLE is `t', then the function will be called after TIME minutes
only if Emacs is idle.  So if Emacs is never idle, the function will
never be called.  But once Emacs goes idle, the function will be
called every TIME minutes.

If IDLE is a number and TIME is a number, the function will
be called every TIME minutes only when Emacs has been idle for
IDLE minutes.

If IDLE is a number and TIME is `nil', the function will be called
once every time Emacs has been idle for IDLE minutes.

And if TIME is a string, it should look like `07:31', and the function
will then be called once every day somewhere near that time.  Modified
by the IDLE parameter, of course.

(When I say "minute" here, I really mean `gnus-demon-timestep'
seconds.  This is 60 by default.  If you change that variable, all the
timings in the handlers will be affected.)

So, if you want to add a handler, you could put something like this in
your `~/.gnus.el' file:

     (gnus-demon-add-handler 'gnus-demon-close-connections 30 t)

Some ready-made functions to do this have been created:
`gnus-demon-add-nocem', `gnus-demon-add-disconnection',
`gnus-demon-add-nntp-close-connection',
`gnus-demon-add-scan-timestamps', `gnus-demon-add-rescan', and
`gnus-demon-add-scanmail'.  Just put those functions in your
`~/.gnus.el' if you want those abilities.

If you add handlers to `gnus-demon-handlers' directly, you should run
`gnus-demon-init' to make the changes take hold.  To cancel all
daemons, you can use the `gnus-demon-cancel' function.

Note that adding daemons can be pretty naughty if you over do it.
Adding functions that scan all news and mail from all servers every
two seconds is a sure-fire way of getting booted off any respectable
system.  So behave.




File: gnus, Node: NoCeM, Next: Undo, Prev: Daemons, Up: Various

NoCeM
=====

"Spamming" is posting the same article lots and lots of times.
Spamming is bad.  Spamming is evil.

Spamming is usually canceled within a day or so by various
anti-spamming agencies.  These agencies usually also send out "NoCeM"
messages.  NoCeM is pronounced "no see-'em", and means what the name
implies--these are messages that make the offending articles, like, go
away.

What use are these NoCeM messages if the articles are canceled anyway?
Some sites do not honor cancel messages and some sites just honor
cancels from a select few people.  Then you may wish to make use of
the NoCeM messages, which are distributed in the `alt.nocem.misc'
newsgroup.

Gnus can read and parse the messages in this group automatically, and
this will make spam disappear.

There are some variables to customize, of course:

`gnus-use-nocem'
     Set this variable to `t' to set the ball rolling.  It is `nil' by
     default.

     You can also set this variable to a positive number as a group
     level.  In that case, Gnus scans NoCeM messages when checking new
     news if this value is not exceeding a group level that you
     specify as the prefix argument to some commands, e.g. `gnus',
     `gnus-group-get-new-news', etc.  Otherwise, Gnus does not scan
     NoCeM messages if you specify a group level to those commands.
     For example, if you use 1 or 2 on the mail groups and the levels
     on the news groups remain the default, 3 is the best choice.

`gnus-nocem-groups'
     Gnus will look for NoCeM messages in the groups in this list.
     The default is
          ("news.lists.filters" "news.admin.net-abuse.bulletins"
           "alt.nocem.misc" "news.admin.net-abuse.announce")

`gnus-nocem-issuers'
     There are many people issuing NoCeM messages.  This list says
     what people you want to listen to.  The default is ("Automoose-1"
     clewis@ferret.ocunix.on.ca" "cosmo.roadkill" "SpamHippo"
     hweede@snafu.de") fine, upstanding citizens all of them.

     Known despammers that you can put in this list are listed at
     `http://www.xs4all.nl/~rosalind/nocemreg/nocemreg.html'.

     You do not have to heed NoCeM messages from all these people--just the
     ones you want to listen to.  You also don't have to accept all NoCeM
     messages from the people you like.  Each NoCeM message has a "type"
     header that gives the message a (more or less, usually less) rigorous
     definition.  Common types are `spam', `spew', `mmf',
     `binary', and `troll'.  To specify this, you have to use
     `(ISSUER CONDITIONS ...)' elements in the list.
     Each condition is either a string (which is a regexp that matches types
     you want to use) or a list on the form `(not STRING)', where
     STRING is a regexp that matches types you don't want to use.

     For instance, if you want all NoCeM messages from Chris Lewis except his
     `troll' messages, you'd say:

          ("clewis@ferret.ocunix.on.ca" ".*" (not "troll"))

     On the other hand, if you just want nothing but his `spam' and
     `spew' messages, you'd say:

          ("clewis@ferret.ocunix.on.ca" (not ".*") "spew" "spam")

     The specs are applied left-to-right.


`gnus-nocem-verifyer'
     This should be a function for verifying that the NoCeM issuer is
     who she says she is.  The default is `pgg-verify', which returns
     non-`nil' if the verification is successful, otherwise (including
     the case the NoCeM message was not signed) returns `nil'.  If
     this is too slow and you don't care for verification (which may
     be dangerous), you can set this variable to `nil'.

     Formerly the default was `mc-verify', which is a Mailcrypt
     function.  While you can still use it, you can change it into
     `pgg-verify' running with GnuPG if you are willing to add the
     PGP public keys to GnuPG's keyring.

`gnus-nocem-directory'
     This is where Gnus will store its NoCeM cache files.  The default is
     `~/News/NoCeM/'.

`gnus-nocem-expiry-wait'
     The number of days before removing old NoCeM entries from the
     cache.  The default is 15.  If you make it shorter Gnus will be
     faster, but you might then see old spam.

`gnus-nocem-check-from'
     Non-`nil' means check for valid issuers in message bodies.
     Otherwise don't bother fetching articles unless their author
     matches a valid issuer; that is much faster if you are selective
     about the issuers.

`gnus-nocem-check-article-limit'
     If non-`nil', the maximum number of articles to check in any
     NoCeM group.  NoCeM groups can be huge and very slow to process.


Using NoCeM could potentially be a memory hog.  If you have many
living (i. e., subscribed or unsubscribed groups), your Emacs process
will grow big.  If this is a problem, you should kill off all (or
most) of your unsubscribed groups (*Note Subscription Commands::).




File: gnus, Node: Undo, Next: Predicate Specifiers, Prev: NoCeM, Up: Various

Undo
====

It is very useful to be able to undo actions one has done.  In normal
Emacs buffers, it's easy enough--you just push the `undo' button.  In
Gnus buffers, however, it isn't that simple.

The things Gnus displays in its buffer is of no value whatsoever to
Gnus--it's all just data designed to look nice to the user.
Killing a group in the group buffer with `C-k' makes the line
disappear, but that's just a side-effect of the real action--the
removal of the group in question from the internal Gnus structures.
Undoing something like that can't be done by the normal Emacs
`undo' function.

Gnus tries to remedy this somewhat by keeping track of what the user
does and coming up with actions that would reverse the actions the
user takes.  When the user then presses the `undo' key, Gnus will run
the code to reverse the previous action, or the previous actions.
However, not all actions are easily reversible, so Gnus currently
offers a few key functions to be undoable.  These include killing
groups, yanking groups, and changing the list of read articles of
groups.  That's it, really.  More functions may be added in the
future, but each added function means an increase in data to be
stored, so Gnus will never be totally undoable.

The undoability is provided by the `gnus-undo-mode' minor mode.  It is
used if `gnus-use-undo' is non-`nil', which is the default.  The
`C-M-_' key performs the `gnus-undo' command, which should feel kinda
like the normal Emacs `undo' command.




File: gnus, Node: Predicate Specifiers, Next: Moderation, Prev: Undo, Up: Various

Predicate Specifiers
====================

Some Gnus variables are "predicate specifiers".  This is a special
form that allows flexible specification of predicates without having
to type all that much.

These specifiers are lists consisting of functions, symbols and lists.

Here's an example:

     (or gnus-article-unseen-p
         gnus-article-unread-p)

The available symbols are `or', `and' and `not'.  The functions all
take one parameter.

Internally, Gnus calls `gnus-make-predicate' on these specifiers to
create a function that can be called.  This input parameter to this
function will be passed along to all the functions in the predicate
specifier.




File: gnus, Node: Moderation, Next: Fetching a Group, Prev: Predicate Specifiers, Up: Various

Moderation
==========

If you are a moderator, you can use the `gnus-mdrtn.el' package.  It
is not included in the standard Gnus package.  Write a mail to
`larsi@gnus.org' and state what group you moderate, and you'll get a
copy.

The moderation package is implemented as a minor mode for summary
buffers.  Put

     (add-hook 'gnus-summary-mode-hook 'gnus-moderate)

in your `~/.gnus.el' file.

If you are the moderator of `rec.zoofle', this is how it's supposed to
work:

  1. You split your incoming mail by matching on
     `Newsgroups:.*rec.zoofle', which will put all the to-be-posted
     articles in some mail group--for instance, `nnml:rec.zoofle'.

  2. You enter that group once in a while and post articles using the
     `e' (edit-and-post) or `s' (just send unedited) commands.

  3. If, while reading the `rec.zoofle' newsgroup, you happen upon some
     articles that weren't approved by you, you can cancel them with the
     `c' command.

To use moderation mode in these two groups, say:

     (setq gnus-moderated-list
           "^nnml:rec.zoofle$\\|^rec.zoofle$")




File: gnus, Node: Fetching a Group, Next: Image Enhancements, Prev: Moderation, Up: Various

Fetching a Group
================

It is sometimes convenient to be able to just say "I want to read this
group and I don't care whether Gnus has been started or not".  This is
perhaps more useful for people who write code than for users, but the
command `gnus-fetch-group' provides this functionality in any case.
It takes the group name as a parameter.




File: gnus, Node: Image Enhancements, Next: Fuzzy Matching, Prev: Fetching a Group, Up: Various

Image Enhancements
==================

XEmacs, as well as Emacs 21 (1) (*Note Image Enhancements-Footnotes::)
and up, are able to display pictures and stuff, so Gnus has taken
advantage of that.

* Menu:

* X-Face::                      Display a funky, teensy black-and-white image.
* Face::                        Display a funkier, teensier colored image.
* Smileys::                     Show all those happy faces the way they were meant to be shown.
* Picons::                      How to display pictures of what you're reading.
* XVarious::                    Other XEmacsy Gnusey variables.



File: gnus  Node: Image Enhancements-Footnotes, Up: Image Enhancements

(1) Emacs 21 on MS Windows doesn't support images, Emacs 22 does.



File: gnus, Node: X-Face, Next: Face, Prev: Image Enhancements, Up: Image Enhancements

X-Face
------

`X-Face' headers describe a 48x48 pixel black-and-white (1 bit depth)
image that's supposed to represent the author of the message.  It
seems to be supported by an ever-growing number of mail and news
readers.


Viewing an `X-Face' header either requires an Emacs that has
`compface' support (which most XEmacs versions have), or that you
have suitable conversion or display programs installed.  If your Emacs
has image support the default action is to display the face before the
`From' header.  If there's no native `X-Face' support, Gnus
will try to convert the `X-Face' header using external programs
from the `pbmplus' package and friends, see below.  For XEmacs it's
faster if XEmacs has been compiled with `X-Face' support.  The
default action under Emacs without image support is to fork off the
`display' program.

On a GNU/Linux system, the `display' program is included in the
ImageMagick package.  For external conversion programs look for packages
with names like `netpbm', `libgr-progs' and `compface'.
On Windows, you may use the packages `netpbm' and `compface'
from `http://gnuwin32.sourceforge.net'.  You need to add the
`bin' directory to your `PATH' environment variable.

The variable `gnus-article-x-face-command' controls which programs
are used to display the `X-Face' header.  If this variable is a
string, this string will be executed in a sub-shell.  If it is a
function, this function will be called with the face as the argument.
If `gnus-article-x-face-too-ugly' (which is a regexp) matches the
`From' header, the face will not be shown.

(Note: `x-face' is used in the variable/function names, not
`xface').

Face and variable:

`gnus-x-face'
     Face to show X-Face.  The colors from this face are used as the
     foreground and background colors of the displayed X-Faces.  The
     default colors are black and white.

`gnus-face-properties-alist'
     Alist of image types and properties applied to Face (*Note
     Face::) and X-Face images.  The default value is `((pbm . (:face
     gnus-x-face)) (png . nil))' for Emacs or `((xface . (:face
     gnus-x-face)))' for XEmacs.  Here are examples:

          ;; Specify the altitude of Face and X-Face images in the From header.
          (setq gnus-face-properties-alist
                '((pbm . (:face gnus-x-face :ascent 80))
                  (png . (:ascent 80))))

          ;; Show Face and X-Face images as pressed buttons.
          (setq gnus-face-properties-alist
                '((pbm . (:face gnus-x-face :relief -2))
                  (png . (:relief -2))))

     *Note Image Descriptors: (elisp)Image Descriptors. for the valid properties for various image types.
     Currently, `pbm' is used for X-Face images and `png' is used
     for Face images in Emacs.  Only the `:face' property is effective
     on the `xface' image type in XEmacs if it is built with the
     `libcompface' library.

If you use posting styles, you can use an `x-face-file' entry in
`gnus-posting-styles', *Note Posting Styles::.  If you don't, Gnus
provides a few convenience functions and variables to allow easier
insertion of X-Face headers in outgoing messages.  You also need the
above mentioned ImageMagick, netpbm or other image conversion packages
(depending the values of the variables below) for these functions.

`gnus-random-x-face' goes through all the `pbm' files in
`gnus-x-face-directory' and picks one at random, and then converts it
to the X-Face format by using the `gnus-convert-pbm-to-x-face-command'
shell command.  The `pbm' files should be 48x48 pixels big.  It
returns the X-Face header data as a string.

`gnus-insert-random-x-face-header' calls `gnus-random-x-face' and
inserts a `X-Face' header with the randomly generated data.

`gnus-x-face-from-file' takes a GIF file as the parameter, and then
converts the file to X-Face format by using the
`gnus-convert-image-to-x-face-command' shell command.

Here's how you would typically use the first function.  Put something
like the following in your `~/.gnus.el' file:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(X-Face . gnus-random-x-face))))

Using the last function would be something like this:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(X-Face . (lambda ()
                                     (gnus-x-face-from-file
                                      "~/My-face.gif"))))))




File: gnus, Node: Face, Next: Smileys, Prev: X-Face, Up: Image Enhancements

Face
----


`Face' headers are essentially a funkier version of `X-Face'
ones. They describe a 48x48 pixel colored image that's supposed to
represent the author of the message.

The contents of a `Face' header must be a base64 encoded PNG image.
See `http://quimby.gnus.org/circus/face/' for the precise
specifications.

The `gnus-face-properties-alist' variable affects the appearance of
displayed Face images.  *Note X-Face::.

Viewing an `Face' header requires an Emacs that is able to display PNG
images.

Gnus provides a few convenience functions and variables to allow
easier insertion of Face headers in outgoing messages.

`gnus-convert-png-to-face' takes a 48x48 PNG image, no longer than 726
bytes long, and converts it to a face.

`gnus-face-from-file' takes a JPEG file as the parameter, and then
converts the file to Face format by using the
`gnus-convert-image-to-face-command' shell command.

Here's how you would typically use this function. Put something like
the following in your `~/.gnus.el' file:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(Face . (lambda ()
                                   (gnus-face-from-file "~/face.jpg"))))))




File: gnus, Node: Smileys, Next: Picons, Prev: Face, Up: Image Enhancements

Smileys
-------


"Smiley" is a package separate from Gnus, but since Gnus is currently
the only package that uses Smiley, it is documented here.

In short--to use Smiley in Gnus, put the following in your
`~/.gnus.el' file:

     (setq gnus-treat-display-smileys t)

Smiley maps text smiley faces---`:-)', `8-)', `:-(' and the like--to
pictures and displays those instead of the text smiley faces.  The
conversion is controlled by a list of regexps that matches text and
maps that to file names.

The alist used is specified by the `smiley-regexp-alist' variable.
The first item in each element is the regexp to be matched; the second
element is the regexp match group that is to be replaced by the
picture; and the third element is the name of the file to be
displayed.

The following variables customize the appearance of the smileys:


`smiley-style'
     Specifies the smiley style.  Predefined smiley styles include
     `low-color' (small 13x14 pixel, three-color images), `medium'
     (more colorful images, 16x16 pixel), and `grayscale' (grayscale
     images, 14x14 pixel).  The default depends on the height of the
     default face.

`smiley-data-directory'
     Where Smiley will look for smiley faces files.  You shouldn't set
     this variable anymore.  Customize `smiley-style' instead.

`gnus-smiley-file-types'
     List of suffixes on smiley file names to try.





File: gnus, Node: Picons, Next: XVarious, Prev: Smileys, Up: Image Enhancements

Picons
------


So...  You want to slow down your news reader even more!  This is a
good way to do so.  It's also a great way to impress people staring
over your shoulder as you read news.

What are Picons?  To quote directly from the Picons Web site:


     "Picons" is short for "personal icons".  They're small,
     constrained images used to represent users and domains on the net,
     organized into databases so that the appropriate image for a given
     e-mail address can be found.  Besides users and domains, there are picon
     databases for Usenet newsgroups and weather forecasts.  The picons are
     in either monochrome `XBM' format or color `XPM' and
     `GIF' formats.

For instructions on obtaining and installing the picons databases,
point your Web browser at
`http://www.cs.indiana.edu/picons/ftp/index.html'.

If you are using Debian GNU/Linux, saying `apt-get install picons.*'
will install the picons where Gnus can find them.

To enable displaying picons, simply make sure that
`gnus-picon-databases' points to the directory containing the Picons
databases.

The variable `gnus-picon-style' controls how picons are displayed.
If `inline', the textual representation is replaced.  If
`right', picons are added right to the textual representation.

The following variables offer control over where things are located.


`gnus-picon-databases'
     The location of the picons database.  This is a list of
     directories containing the `news', `domains', `users' (and so on)
     subdirectories.  Defaults to `("/usr/lib/picon"
     /usr/local/faces")'.

`gnus-picon-news-directories'
     List of subdirectories to search in `gnus-picon-databases' for
     newsgroups faces.  `("news")' is the default.

`gnus-picon-user-directories'
     List of subdirectories to search in `gnus-picon-databases' for
     user faces.  `("users" "usenix" "local" "misc")' is the default.

`gnus-picon-domain-directories'
     List of subdirectories to search in `gnus-picon-databases' for
     domain name faces.  Defaults to `("domains")'.  Some people may
     want to add `"unknown"' to this list.

`gnus-picon-file-types'
     Ordered list of suffixes on picon file names to try.  Defaults to
     `("xpm" "gif" "xbm")' minus those not built-in your Emacs.





File: gnus, Node: XVarious, Prev: Picons, Up: Image Enhancements

Various XEmacs Variables
------------------------

`gnus-xmas-glyph-directory'
     This is where Gnus will look for pictures.  Gnus will normally
     auto-detect this directory, but you may set it manually if you
     have an unusual directory structure.

`gnus-xmas-modeline-glyph'
     A glyph displayed in all Gnus mode lines.  It is a tiny gnu head
     by default.



Toolbar
.......


`gnus-use-toolbar'
     This variable specifies the position to display the toolbar.  If
     `nil', don't display toolbars.  If it is non-`nil', it should be
     one of the symbols `default', `top', `bottom', `right', and
     `left'.  `default' means to use the default toolbar, the rest
     mean to display the toolbar on the place which those names show.
     The default is `default'.

`gnus-toolbar-thickness'
     Cons of the height and the width specifying the thickness of a
     toolbar.  The height is used for the toolbar displayed on the top
     or the bottom, the width is used for the toolbar displayed on the
     right or the left.  The default is that of the default toolbar.

`gnus-group-toolbar'
     The toolbar in the group buffer.

`gnus-summary-toolbar'
     The toolbar in the summary buffer.

`gnus-summary-mail-toolbar'
     The toolbar in the summary buffer of mail groups.






File: gnus, Node: Fuzzy Matching, Next: Thwarting Email Spam, Prev: Image Enhancements, Up: Various

Fuzzy Matching
==============

Gnus provides "fuzzy matching" of `Subject' lines when doing things
like scoring, thread gathering and thread comparison.

As opposed to regular expression matching, fuzzy matching is very
fuzzy.  It's so fuzzy that there's not even a definition of what
fuzziness" means, and the implementation has changed over time.

Basically, it tries to remove all noise from lines before comparing.
`Re: ', parenthetical remarks, white space, and so on, are filtered
out of the strings before comparing the results.  This often leads to
adequate results--even when faced with strings generated by text
manglers masquerading as newsreaders.




File: gnus, Node: Thwarting Email Spam, Next: Spam Package, Prev: Fuzzy Matching, Up: Various

Thwarting Email Spam
====================

In these last days of the Usenet, commercial vultures are hanging
about and grepping through news like crazy to find email addresses
they can foist off their scams and products to.  As a reaction to
this, many people have started putting nonsense addresses into their
`From' lines.  I think this is counterproductive--it makes it
difficult for people to send you legitimate mail in response to things
you write, as well as making it difficult to see who wrote what.  This
rewriting may perhaps be a bigger menace than the unsolicited
commercial email itself in the end.

The biggest problem I have with email spam is that it comes in under
false pretenses.  I press `g' and Gnus merrily informs me that I have
10 new emails.  I say "Golly gee!  Happy is me!" and select the mail
group, only to find two pyramid schemes, seven advertisements ("New!
Miracle tonic for growing full, lustrous hair on your toes!")  and one
mail asking me to repent and find some god.

This is annoying.  Here's what you can do about it.

* Menu:

* The problem of spam::         Some background, and some solutions
* Anti-Spam Basics::            Simple steps to reduce the amount of spam.
* SpamAssassin::                How to use external anti-spam tools.
* Hashcash::                    Reduce spam by burning CPU time.



File: gnus, Node: The problem of spam, Next: Anti-Spam Basics, Prev: Thwarting Email Spam, Up: Thwarting Email Spam

The problem of spam
-------------------

First, some background on spam.

If you have access to e-mail, you are familiar with spam (technically
termed UCE, Unsolicited Commercial E-mail).  Simply put, it
exists because e-mail delivery is very cheap compared to paper mail,
so only a very small percentage of people need to respond to an UCE to
make it worthwhile to the advertiser.  Ironically, one of the most
common spams is the one offering a database of e-mail addresses for
further spamming.  Senders of spam are usually called *spammers*,
but terms like *vermin*, *scum*, *sociopaths*, and
*morons* are in common use as well.

Spam comes from a wide variety of sources.  It is simply impossible to
dispose of all spam without discarding useful messages.  A good
example is the TMDA system, which requires senders unknown to you to
confirm themselves as legitimate senders before their e-mail can reach
you.  Without getting into the technical side of TMDA, a downside is
clearly that e-mail from legitimate sources may be discarded if those
sources can't or won't confirm themselves through the TMDA system.
Another problem with TMDA is that it requires its users to have a
basic understanding of e-mail delivery and processing.

The simplest approach to filtering spam is filtering, at the mail
server or when you sort through incoming mail.  If you get 200 spam
messages per day from `random-address@vmadmin.com', you block
`vmadmin.com'.  If you get 200 messages about `VIAGRA', you discard
all messages with `VIAGRA' in the message.  If you get lots of spam
from Bulgaria, for example, you try to filter all mail from Bulgarian
IPs.

This, unfortunately, is a great way to discard legitimate e-mail.  The
risks of blocking a whole country (Bulgaria, Norway, Nigeria, China,
etc.) or even a continent (Asia, Africa, Europe, etc.) from contacting
you should be obvious, so don't do it if you have the choice.

In another instance, the very informative and useful RISKS digest has
been blocked by overzealous mail filters because it *contained* words
that were common in spam messages.  Nevertheless, in isolated cases,
with great care, direct filtering of mail can be useful.

Another approach to filtering e-mail is the distributed spam
processing, for instance DCC implements such a system.  In essence, N
systems around the world agree that a machine X in Ghana, Estonia, or
California is sending out spam e-mail, and these N systems enter X or
the spam e-mail from X into a database.  The criteria for spam
detection vary--it may be the number of messages sent, the content of
the messages, and so on.  When a user of the distributed processing
system wants to find out if a message is spam, he consults one of
those N systems.

Distributed spam processing works very well against spammers that send
a large number of messages at once, but it requires the user to set up
fairly complicated checks.  There are commercial and free distributed
spam processing systems.  Distributed spam processing has its risks as
well.  For instance legitimate e-mail senders have been accused of
sending spam, and their web sites and mailing lists have been shut
down for some time because of the incident.

The statistical approach to spam filtering is also popular.  It is
based on a statistical analysis of previous spam messages.  Usually
the analysis is a simple word frequency count, with perhaps pairs of
words or 3-word combinations thrown into the mix.  Statistical
analysis of spam works very well in most of the cases, but it can
classify legitimate e-mail as spam in some cases.  It takes time to
run the analysis, the full message must be analyzed, and the user has
to store the database of spam analysis.  Statistical analysis on the
server is gaining popularity.  This has the advantage of letting the
user Just Read Mail, but has the disadvantage that it's harder to tell
the server that it has misclassified mail.

Fighting spam is not easy, no matter what anyone says.  There is no
magic switch that will distinguish Viagra ads from Mom's e-mails.
Even people are having a hard time telling spam apart from non-spam,
because spammers are actively looking to fool us into thinking they
are Mom, essentially.  Spamming is irritating, irresponsible, and
idiotic behavior from a bunch of people who think the world owes them
a favor.  We hope the following sections will help you in fighting the
spam plague.



File: gnus, Node: Anti-Spam Basics, Next: SpamAssassin, Prev: The problem of spam, Up: Thwarting Email Spam

Anti-Spam Basics
----------------

One way of dealing with spam is having Gnus split out all spam into a
`spam' mail group (*Note Splitting Mail::).

First, pick one (1) valid mail address that you can be reached at, and
put it in your `From' header of all your news articles.  (I've chosen
`larsi@trym.ifi.uio.no', but for many addresses on the form
`larsi+usenet@ifi.uio.no' will be a better choice.  Ask your sysadmin
whether your sendmail installation accepts keywords in the local part
of the mail address.)

     (setq message-default-news-headers
           "From: Lars Magne Ingebrigtsen <larsi@trym.ifi.uio.no>\n")

Then put the following split rule in `nnmail-split-fancy' (*Note Fancy
Mail Splitting::):

     (...
      (to "larsi@trym.ifi.uio.no"
          (| ("subject" "re:.*" "misc")
             ("references" ".*@.*" "misc")
             "spam"))
      ...)

This says that all mail to this address is suspect, but if it has a
`Subject' that starts with a `Re:' or has a `References' header, it's
probably ok.  All the rest goes to the `spam' group.  (This idea
probably comes from Tim Pierce.)

In addition, many mail spammers talk directly to your SMTP server and
do not include your email address explicitly in the `To' header.  Why
they do this is unknown--perhaps it's to thwart this thwarting scheme?
In any case, this is trivial to deal with--you just put anything not
addressed to you in the `spam' group by ending your fancy split rule
in this way:

     (
      ...
      (to "larsi" "misc")
      "spam")

In my experience, this will sort virtually everything into the right
group.  You still have to check the `spam' group from time to time to
check for legitimate mail, though.  If you feel like being a good net
citizen, you can even send off complaints to the proper authorities on
each unsolicited commercial email--at your leisure.

This works for me.  It allows people an easy way to contact me (they
can just press `r' in the usual way), and I'm not bothered at all with
spam.  It's a win-win situation.  Forging `From' headers to point to
non-existent domains is yucky, in my opinion.

Be careful with this approach.  Spammers are wise to it.




File: gnus, Node: SpamAssassin, Next: Hashcash, Prev: Anti-Spam Basics, Up: Thwarting Email Spam

SpamAssassin, Vipul's Razor, DCC, etc
-------------------------------------

The days where the hints in the previous section were sufficient in
avoiding spam are coming to an end.  There are many tools out there
that claim to reduce the amount of spam you get.  This section could
easily become outdated fast, as new products replace old, but
fortunately most of these tools seem to have similar interfaces.  Even
though this section will use SpamAssassin as an example, it should be
easy to adapt it to most other tools.

Note that this section does not involve the `spam.el' package, which
is discussed in the next section.  If you don't care for all the
features of `spam.el', you can make do with these simple recipes.

If the tool you are using is not installed on the mail server, you
need to invoke it yourself.  Ideas on how to use the `:postscript'
mail source parameter (*Note Mail Source Specifiers::) follow.

     (setq mail-sources
           '((file :prescript "formail -bs spamassassin < /var/mail/%u")
             (pop :user "jrl"
                  :server "pophost"
                  :postscript
                  "mv %t /tmp/foo; formail -bs spamc < /tmp/foo > %t")))

Once you manage to process your incoming spool somehow, thus making
the mail contain e.g. a header indicating it is spam, you are ready to
filter it out.  Using normal split methods (*Note Splitting Mail::):

     (setq nnmail-split-methods '(("spam"  "^X-Spam-Flag: YES")
                                  ...))

Or using fancy split methods (*Note Fancy Mail Splitting::):

     (setq nnmail-split-methods 'nnmail-split-fancy
           nnmail-split-fancy '(| ("X-Spam-Flag" "YES" "spam")
                                  ...))

Some people might not like the idea of piping the mail through various
programs using a `:prescript' (if some program is buggy, you might
lose all mail).  If you are one of them, another solution is to call
the external tools during splitting.  Example fancy split method:

     (setq nnmail-split-fancy '(| (: kevin-spamassassin)
                                  ...))
     (defun kevin-spamassassin ()
       (save-excursion
         (save-restriction
           (widen)
           (if (eq 1 (call-process-region (point-min) (point-max)
                                          "spamc" nil nil nil "-c"))
               "spam"))))

Note that with the nnimap back end, message bodies will not be
downloaded by default.  You need to set `nnimap-split-download-body'
to `t' to do that (*Note Splitting in IMAP::).

That is about it.  As some spam is likely to get through anyway, you
might want to have a nifty function to call when you happen to read
spam.  And here is the nifty function:

      (defun my-gnus-raze-spam ()
       "Submit SPAM to Vipul's Razor, then mark it as expirable."
       (interactive)
       (gnus-summary-show-raw-article)
       (gnus-summary-save-in-pipe "razor-report -f -d")
       (gnus-summary-mark-as-expirable 1))



File: gnus, Node: Hashcash, Prev: SpamAssassin, Up: Thwarting Email Spam

Hashcash
--------

A novel technique to fight spam is to require senders to do something
costly and demonstrably unique for each message they send.  This has
the obvious drawback that you cannot rely on everyone in the world
using this technique, since it is not part of the Internet standards,
but it may be useful in smaller communities.

While the tools in the previous section work well in practice, they
work only because the tools are constantly maintained and updated as
new form of spam appears.  This means that a small percentage of spam
will always get through.  It also means that somewhere, someone needs
to read lots of spam to update these tools.  Hashcash avoids that, but
instead prefers that everyone you contact through e-mail supports the
scheme.  You can view the two approaches as pragmatic vs dogmatic.
The approaches have their own advantages and disadvantages, but as
often in the real world, a combination of them is stronger than either
one of them separately.

The "something costly" is to burn CPU time, more specifically to
compute a hash collision up to a certain number of bits.  The
resulting hashcash cookie is inserted in a `X-Hashcash:' header.  For
more details, and for the external application `hashcash' you need to
install to use this feature, see `http://www.hashcash.org/'.  Even
more information can be found at `http://www.camram.org/'.

If you wish to generate hashcash for each message you send, you can
customize `message-generate-hashcash' (*Note Mail Headers:
(message)Mail Headers.), as in:

     (setq message-generate-hashcash t)

You will need to set up some additional variables as well:


`hashcash-default-payment'
     This variable indicates the default number of bits the hash
     collision should consist of.  By default this is 20.  Suggested
     useful values include 17 to 29.

`hashcash-payment-alist'
     Some receivers may require you to spend burn more CPU time than
     the default.  This variable contains a list of `(ADDR AMOUNT)'
     cells, where ADDR is the receiver (email address or newsgroup)
     and AMOUNT is the number of bits in the collision that is needed.
     It can also contain `(ADDR STRING AMOUNT)' cells, where the
     STRING is the string to use (normally the email address or
     newsgroup name is used).

`hashcash-path'
     Where the `hashcash' binary is installed.  This variable should
     be automatically set by `executable-find', but if it's `nil'
     (usually because the `hashcash' binary is not in your path)
     you'll get a warning when you check hashcash payments and an
     error when you generate hashcash payments.


Gnus can verify hashcash cookies, although this can also be done by
hand customized mail filtering scripts.  To verify a hashcash cookie
in a message, use the `mail-check-payment' function in the
`hashcash.el' library.  You can also use the `spam.el' package with
the `spam-use-hashcash' back end to validate hashcash cookies in
incoming mail and filter mail accordingly (*Note Anti-spam Hashcash
Payments::).



File: gnus, Node: Spam Package, Next: Other modes, Prev: Thwarting Email Spam, Up: Various

Spam Package
============

The Spam package provides Gnus with a centralized mechanism for
detecting and filtering spam.  It filters new mail, and processes
messages according to whether they are spam or ham.  ("Ham" is the
name used throughout this manual to indicate non-spam messages.)

* Menu:

* Spam Package Introduction::
* Filtering Incoming Mail::
* Detecting Spam in Groups::
* Spam and Ham Processors::
* Spam Package Configuration Examples::
* Spam Back Ends::
* Extending the Spam package::
* Spam Statistics Package::



File: gnus, Node: Spam Package Introduction, Next: Filtering Incoming Mail, Prev: Spam Package, Up: Spam Package

Spam Package Introduction
-------------------------

You must read this section to understand how the Spam package works.
Do not skip, speed-read, or glance through this section.

Make sure you read the section on the `spam.el' sequence of events.
See *Note Extending the Spam package::.

To use the Spam package, you *must* first run the function
`spam-initialize':

     (spam-initialize)

This autoloads `spam.el' and installs the various hooks necessary to
let the Spam package do its job.  In order to make use of the Spam
package, you have to set up certain group parameters and variables,
which we will describe below.  All of the variables controlling the
Spam package can be found in the `spam' customization group.

There are two "contact points" between the Spam package and the rest
of Gnus: checking new mail for spam, and leaving a group.

Checking new mail for spam is done in one of two ways: while splitting
incoming mail, or when you enter a group.

The first way, checking for spam while splitting incoming mail, is
suited to mail back ends such as `nnml' or `nnimap', where new mail
appears in a single spool file.  The Spam package processes incoming
mail, and sends mail considered to be spam to a designated "spam"
group.  *Note Filtering Incoming Mail::.

The second way is suited to back ends such as `nntp', which have no
incoming mail spool, or back ends where the server is in charge of
splitting incoming mail.  In this case, when you enter a Gnus group,
the unseen or unread messages in that group are checked for spam.
Detected spam messages are marked as spam.  *Note Detecting Spam in
Groups::.

In either case, you have to tell the Spam package what method to use
to detect spam messages.  There are several methods, or "spam back
ends" (not to be confused with Gnus back ends!) to choose from: spam
blacklists" and "whitelists", dictionary-based filters, and so forth.
*Note Spam Back Ends::.

In the Gnus summary buffer, messages that have been identified as spam
always appear with a `$' symbol.

The Spam package divides Gnus groups into three categories: ham
groups, spam groups, and unclassified groups.  You should mark each of
the groups you subscribe to as either a ham group or a spam group,
using the `spam-contents' group parameter (*Note Group Parameters::).
Spam groups have a special property: when you enter a spam group, all
unseen articles are marked as spam.  Thus, mail split into a spam
group is automatically marked as spam.

Identifying spam messages is only half of the Spam package's job.  The
second half comes into play whenever you exit a group buffer.  At this
point, the Spam package does several things:

First, it calls "spam and ham processors" to process the articles
according to whether they are spam or ham.  There is a pair of spam
and ham processors associated with each spam back end, and what the
processors do depends on the back end.  At present, the main role of
spam and ham processors is for dictionary-based spam filters: they add
the contents of the messages in the group to the filter's dictionary,
to improve its ability to detect future spam.  The `spam-process'
group parameter specifies what spam processors to use.  *Note Spam and
Ham Processors::.

If the spam filter failed to mark a spam message, you can mark it
yourself, so that the message is processed as spam when you exit the
group:

`M-d'
`M s x'
`S x'
     Mark current article as spam, showing it with the `$' mark
     (`gnus-summary-mark-as-spam').

Similarly, you can unmark an article if it has been erroneously marked
as spam.  *Note Setting Marks::.

Normally, a ham message found in a non-ham group is not processed as
ham--the rationale is that it should be moved into a ham group for
further processing (see below).  However, you can force these articles
to be processed as ham by setting
`spam-process-ham-in-spam-groups' and
`spam-process-ham-in-nonham-groups'.

The second thing that the Spam package does when you exit a group is
to move ham articles out of spam groups, and spam articles out of ham
groups.  Ham in a spam group is moved to the group specified by the
variable `gnus-ham-process-destinations', or the group parameter
`ham-process-destination'.  Spam in a ham group is moved to the group
specified by the variable `gnus-spam-process-destinations', or the
group parameter `spam-process-destination'.  If these variables are
not set, the articles are left in their current group.  If an article
cannot be moved (e.g., with a read-only backend such as NNTP), it is
copied.

If an article is moved to another group, it is processed again when
you visit the new group.  Normally, this is not a problem, but if you
want each article to be processed only once, load the
`gnus-registry.el' package and set the variable `spam-log-to-registry'
to `t'.  *Note Spam Package Configuration Examples::.

Normally, spam groups ignore `gnus-spam-process-destinations'.
However, if you set `spam-move-spam-nonspam-groups-only' to `nil',
spam will also be moved out of spam groups, depending on the
`spam-process-destination' parameter.

The final thing the Spam package does is to mark spam articles as
expired, which is usually the right thing to do.

If all this seems confusing, don't worry.  Soon it will be as natural
as typing Lisp one-liners on a neural interface... err, sorry, that's
50 years in the future yet.  Just trust us, it's not so bad.



File: gnus, Node: Filtering Incoming Mail, Next: Detecting Spam in Groups, Prev: Spam Package Introduction, Up: Spam Package

Filtering Incoming Mail
-----------------------

To use the Spam package to filter incoming mail, you must first set up
fancy mail splitting.  *Note Fancy Mail Splitting::.  The Spam package
defines a special splitting function that you can add to your fancy
split variable (either `nnmail-split-fancy' or
`nnimap-split-fancy', depending on your mail back end):

     (: spam-split)

The `spam-split' function scans incoming mail according to your
chosen spam back end(s), and sends messages identified as spam to a
spam group.  By default, the spam group is a group named `spam',
but you can change this by customizing `spam-split-group'.  Make
sure the contents of `spam-split-group' are an unqualified group
name.  For instance, in an `nnimap' server `your-server',
the value `spam' means `nnimap+your-server:spam'.  The value
`nnimap+server:spam' is therefore wrong--it gives the group
`nnimap+your-server:nnimap+server:spam'.

`spam-split' does not modify the contents of messages in any way.

Note for IMAP users: if you use the `spam-check-bogofilter',
`spam-check-ifile', and `spam-check-stat' spam back ends, you should
also set set the variable `nnimap-split-download-body' to `t'.  These
spam back ends are most useful when they can "scan" the full message
body.  By default, the nnimap back end only retrieves the message
headers; `nnimap-split-download-body' tells it to retrieve the message
bodies as well.  We don't set this by default because it will slow
IMAP down, and that is not an appropriate decision to make on behalf
of the user.  *Note Splitting in IMAP::.

You have to specify one or more spam back ends for `spam-split' to
use, by setting the `spam-use-*' variables.  *Note Spam Back Ends::.
Normally, `spam-split' simply uses all the spam back ends you enabled
in this way.  However, you can tell `spam-split' to use only some of
them.  Why this is useful?  Suppose you are using the
`spam-use-regex-headers' and `spam-use-blackholes' spam back ends, and
the following split rule:

      nnimap-split-fancy '(|
                           (any "ding" "ding")
                           (: spam-split)
                           ;; default mailbox
                           "mail")

The problem is that you want all ding messages to make it to the ding
folder.  But that will let obvious spam (for example, spam detected by
SpamAssassin, and `spam-use-regex-headers') through, when it's sent to
the ding list.  On the other hand, some messages to the ding list are
from a mail server in the blackhole list, so the invocation of
`spam-split' can't be before the ding rule.

The solution is to let SpamAssassin headers supersede ding rules, and
perform the other `spam-split' rules (including a second invocation of
the regex-headers check) after the ding rule.  This is done by passing
a parameter to `spam-split':

     nnimap-split-fancy
           '(|
             ;; spam detected by `spam-use-regex-headers' goes to `regex-spam'
             (: spam-split "regex-spam" 'spam-use-regex-headers)
             (any "ding" "ding")
             ;; all other spam detected by spam-split goes to `spam-split-group'
             (: spam-split)
             ;; default mailbox
             "mail")

This lets you invoke specific `spam-split' checks depending on your
particular needs, and target the results of those checks to a
particular spam group.  You don't have to throw all mail into all the
spam tests.  Another reason why this is nice is that messages to
mailing lists you have rules for don't have to have resource-intensive
blackhole checks performed on them.  You could also specify different
spam checks for your nnmail split vs. your nnimap split.  Go crazy.

You should set the `spam-use-*' variables for whatever spam back
ends you intend to use.  The reason is that when loading
`spam.el', some conditional loading is done depending on what
`spam-use-xyz' variables you have set.  *Note Spam Back Ends::.




File: gnus, Node: Detecting Spam in Groups, Next: Spam and Ham Processors, Prev: Filtering Incoming Mail, Up: Spam Package

Detecting Spam in Groups
------------------------

To detect spam when visiting a group, set the group's
`spam-autodetect' and `spam-autodetect-methods' group parameters.
These are accessible with `G c' or `G p', as usual (*Note Group
Parameters::).

You should set the `spam-use-*' variables for whatever spam back
ends you intend to use.  The reason is that when loading
`spam.el', some conditional loading is done depending on what
`spam-use-xyz' variables you have set.

By default, only unseen articles are processed for spam.  You can
force Gnus to recheck all messages in the group by setting the
variable `spam-autodetect-recheck-messages' to `t'.

If you use the `spam-autodetect' method of checking for spam, you can
specify different spam detection methods for different groups.  For
instance, the `ding' group may have `spam-use-BBDB' as the
autodetection method, while the `suspect' group may have the
`spam-use-blacklist' and `spam-use-bogofilter' methods enabled.
Unlike with `spam-split', you don't have any control over the
*sequence* of checks, but this is probably unimportant.



