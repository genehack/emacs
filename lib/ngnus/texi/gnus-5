Info file: gnus,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License" in the Emacs manual.

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding
     a copy of the license to the document, as described in section 6
     of the license.



INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus: (gnus).         The newsreader Gnus.
END-INFO-DIR-ENTRY








File: gnus, Node: Filling In Threads, Next: More Threading, Prev: Loose Threads, Up: Customizing Threading

Filling In Threads
..................

`gnus-fetch-old-headers'
     If non-`nil', Gnus will attempt to build old threads by fetching
     more old headers--headers to articles marked as read.  If you
     would like to display as few summary lines as possible, but still
     connect as many loose threads as possible, you should set this
     variable to `some' or a number.  If you set it to a number, no
     more than that number of extra old headers will be fetched.  In
     either case, fetching old headers only works if the back end you
     are using carries overview files--this would normally be `nntp',
     `nnspool', `nnml', and `nnmaildir'.  Also remember that if the
     root of the thread has been expired by the server, there's not
     much Gnus can do about that.

     This variable can also be set to `invisible'.  This won't have
     any visible effects, but is useful if you use the `A T' command a
     lot (*Note Finding the Parent::).

`gnus-fetch-old-ephemeral-headers'
     Same as `gnus-fetch-old-headers', but only used for ephemeral
     newsgroups.

`gnus-build-sparse-threads'
     Fetching old headers can be slow.  A low-rent similar effect can be
     gotten by setting this variable to `some'.  Gnus will then look at
     the complete `References' headers of all articles and try to string
     together articles that belong in the same thread.  This will leave
     "gaps" in the threading display where Gnus guesses that an article
     is missing from the thread.  (These gaps appear like normal summary
     lines.  If you select a gap, Gnus will try to fetch the article in
     question.)  If this variable is `t', Gnus will display all these
     "gaps" without regard for whether they are useful for completing the
     thread or not.  Finally, if this variable is `more', Gnus won't cut
     off sparse leaf nodes that don't lead anywhere.  This variable is
     `nil' by default.

`gnus-read-all-available-headers'
     This is a rather obscure variable that few will find useful.
     It's intended for those non-news newsgroups where the back end
     has to fetch quite a lot to present the summary buffer, and where
     it's impossible to go back to parents of articles.  This is
     mostly the case in the web-based groups, like the `nnultimate'
     groups.

     If you don't use those, then it's safe to leave this as the
     default `nil'.  If you want to use this variable, it should be a
     regexp that matches the group name, or `t' for all groups.





File: gnus, Node: More Threading, Next: Low-Level Threading, Prev: Filling In Threads, Up: Customizing Threading

More Threading
..............

`gnus-show-threads'
     If this variable is `nil', no threading will be done, and all of
     the rest of the variables here will have no effect.  Turning
     threading off will speed group selection up a bit, but it is sure
     to make reading slower and more awkward.

`gnus-thread-hide-subtree'
     If non-`nil', all threads will be hidden when the summary buffer
     is generated.

     This can also be a predicate specifier (*Note Predicate Specifiers::).
     Available predicates are `gnus-article-unread-p' and
     `gnus-article-unseen-p'.

     Here's an example:

          (setq gnus-thread-hide-subtree
                '(or gnus-article-unread-p
                     gnus-article-unseen-p))

     (It's a pretty nonsensical example, since all unseen articles are
     also unread, but you get my drift.)


`gnus-thread-expunge-below'
     All threads that have a total score (as defined by
     `gnus-thread-score-function') less than this number will be
     expunged.  This variable is `nil' by default, which means that no
     threads are expunged.

`gnus-thread-hide-killed'
     if you kill a thread and this variable is non-`nil', the subtree
     will be hidden.

`gnus-thread-ignore-subject'
     Sometimes somebody changes the subject in the middle of a thread.
     If this variable is non-`nil', which is the default, the subject
     change is ignored.  If it is `nil', a change in the subject will
     result in a new thread.

`gnus-thread-indent-level'
     This is a number that says how much each sub-thread should be
     indented.  The default is 4.

`gnus-sort-gathered-threads-function'
     Sometimes, particularly with mailing lists, the order in which
     mails arrive locally is not necessarily the same as the order in
     which they arrived on the mailing list.  Consequently, when
     sorting sub-threads using the default
     `gnus-thread-sort-by-number', responses can end up appearing
     before the article to which they are responding to.  Setting this
     variable to an alternate value (e.g. `gnus-thread-sort-by-date'),
     in a group's parameters or in an appropriate hook
     (e.g. `gnus-summary-generate-hook') can produce a more logical
     sub-thread ordering in such instances.





File: gnus, Node: Low-Level Threading, Prev: More Threading, Up: Customizing Threading

Low-Level Threading
...................


`gnus-parse-headers-hook'
     Hook run before parsing any headers.

`gnus-alter-header-function'
     If non-`nil', this function will be called to allow alteration of
     article header structures.  The function is called with one
     parameter, the article header vector, which it may alter in any
     way.  For instance, if you have a mail-to-news gateway which
     alters the `Message-ID's in systematic ways (by adding prefixes
     and such), you can use this variable to un-scramble the
     `Message-ID's so that they are more meaningful.  Here's one
     example:

          (setq gnus-alter-header-function 'my-alter-message-id)

          (defun my-alter-message-id (header)
            (let ((id (mail-header-id header)))
              (when (string-match
                     "\\(<[^<>@]*\\)\\.?cygnus\\..*@\\([^<>@]*>\\)" id)
                (mail-header-set-id
                 (concat (match-string 1 id) "@" (match-string 2 id))
                 header))))





File: gnus, Node: Thread Commands, Prev: Customizing Threading, Up: Threading

Thread Commands
---------------


`T k'
`C-M-k'
     Mark all articles in the current (sub-)thread as read
     (`gnus-summary-kill-thread').  If the prefix argument is
     positive, remove all marks instead.  If the prefix argument is
     negative, tick articles instead.

`T l'
`C-M-l'
     Lower the score of the current (sub-)thread
     (`gnus-summary-lower-thread').

`T i'
     Increase the score of the current (sub-)thread
     (`gnus-summary-raise-thread').

`T #'
     Set the process mark on the current (sub-)thread
     (`gnus-uu-mark-thread').

`T M-#'
     Remove the process mark from the current (sub-)thread
     (`gnus-uu-unmark-thread').

`T T'
     Toggle threading (`gnus-summary-toggle-threads').

`T s'
     Expose the (sub-)thread hidden under the current article, if any
     (`gnus-summary-show-thread').

`T h'
     Hide the current (sub-)thread (`gnus-summary-hide-thread').

`T S'
     Expose all hidden threads (`gnus-summary-show-all-threads').

`T H'
     Hide all threads (`gnus-summary-hide-all-threads').

`T t'
     Re-thread the current article's thread
     (`gnus-summary-rethread-current').  This works even when the
     summary buffer is otherwise unthreaded.

`T ^'
     Make the current article the child of the marked (or previous)
     article (`gnus-summary-reparent-thread').

`T M-^'
     Make the current article the parent of the marked articles
     (`gnus-summary-reparent-children').


The following commands are thread movement commands.  They all
understand the numeric prefix.


`T n'
`C-M-f'
`M-down'
     Go to the next thread (`gnus-summary-next-thread').

`T p'
`C-M-b'
`M-up'
     Go to the previous thread (`gnus-summary-prev-thread').

`T d'
     Descend the thread (`gnus-summary-down-thread').

`T u'
     Ascend the thread (`gnus-summary-up-thread').

`T o'
     Go to the top of the thread (`gnus-summary-top-thread').

If you ignore subject while threading, you'll naturally end up with
threads that have several different subjects in them.  If you then
issue a command like `T k' (`gnus-summary-kill-thread') you might not
wish to kill the entire thread, but just those parts of the thread
that have the same subject as the current article.  If you like this
idea, you can fiddle with `gnus-thread-operation-ignore-subject'.  If
it is non-`nil' (which it is by default), subjects will be ignored
when doing thread commands.  If this variable is `nil', articles in
the same thread with different subjects will not be included in the
operation in question.  If this variable is `fuzzy', only articles
that have subjects fuzzily equal will be included (*Note Fuzzy
Matching::).




File: gnus, Node: Sorting the Summary Buffer, Next: Asynchronous Fetching, Prev: Threading, Up: Summary Buffer

Sorting the Summary Buffer
==========================

If you are using a threaded summary display, you can sort the threads by
setting `gnus-thread-sort-functions', which can be either a single
function, a list of functions, or a list containing functions and
`(not some-function)' elements.

By default, sorting is done on article numbers.  Ready-made sorting
predicate functions include `gnus-thread-sort-by-number',
`gnus-thread-sort-by-author', `gnus-thread-sort-by-recipient',
`gnus-thread-sort-by-subject',
`gnus-thread-sort-by-date',
`gnus-thread-sort-by-score',
`gnus-thread-sort-by-most-recent-number',
`gnus-thread-sort-by-most-recent-date',
`gnus-thread-sort-by-random' and
`gnus-thread-sort-by-total-score'.

Each function takes two threads and returns non-`nil' if the first
thread should be sorted before the other.  Note that sorting really is
normally done by looking only at the roots of each thread.

If you use more than one function, the primary sort key should be the
last function in the list.  You should probably always include
`gnus-thread-sort-by-number' in the list of sorting
functions--preferably first.  This will ensure that threads that are
equal with respect to the other sort criteria will be displayed in
ascending article order.

If you would like to sort by reverse score, then by subject, and
finally by number, you could do something like:

     (setq gnus-thread-sort-functions
           '(gnus-thread-sort-by-number
             gnus-thread-sort-by-subject
             (not gnus-thread-sort-by-total-score)))

The threads that have highest score will be displayed first in the
summary buffer.  When threads have the same score, they will be sorted
alphabetically.  The threads that have the same score and the same
subject will be sorted by number, which is (normally) the sequence in
which the articles arrived.

If you want to sort by score and then reverse arrival order, you could
say something like:

     (setq gnus-thread-sort-functions
           '((not gnus-thread-sort-by-number)
             gnus-thread-sort-by-score))

The function in the `gnus-thread-score-function' variable (default
`+') is used for calculating the total score of a thread.  Useful
functions might be `max', `min', or squared means, or whatever tickles
your fancy.

If you are using an unthreaded display for some strange reason or
other, you have to fiddle with the `gnus-article-sort-functions'
variable.  It is very similar to the
`gnus-thread-sort-functions', except that it uses slightly
different functions for article comparison.  Available sorting
predicate functions are `gnus-article-sort-by-number',
`gnus-article-sort-by-author',
`gnus-article-sort-by-subject', `gnus-article-sort-by-date',
`gnus-article-sort-by-random', and
`gnus-article-sort-by-score'.

If you want to sort an unthreaded summary display by subject, you
could say something like:

     (setq gnus-article-sort-functions
           '(gnus-article-sort-by-number
             gnus-article-sort-by-subject))

You can define group specific sorting via `gnus-parameters',
*Note Group Parameters::.




File: gnus, Node: Asynchronous Fetching, Next: Article Caching, Prev: Sorting the Summary Buffer, Up: Summary Buffer

Asynchronous Article Fetching
=============================

If you read your news from an NNTP server that's far away, the network
latencies may make reading articles a chore.  You have to wait for a
while after pressing `n' to go to the next article before the article
appears.  Why can't Gnus just go ahead and fetch the article while you
are reading the previous one?  Why not, indeed.

First, some caveats.  There are some pitfalls to using asynchronous
article fetching, especially the way Gnus does it.

Let's say you are reading article 1, which is short, and article 2 is
quite long, and you are not interested in reading that.  Gnus does not
know this, so it goes ahead and fetches article 2.  You decide to read
article 3, but since Gnus is in the process of fetching article 2, the
connection is blocked.

To avoid these situations, Gnus will open two (count 'em two)
connections to the server.  Some people may think this isn't a very
nice thing to do, but I don't see any real alternatives.  Setting up
that extra connection takes some time, so Gnus startup will be slower.

Gnus will fetch more articles than you will read.  This will mean that
the link between your machine and the NNTP server will become more
loaded than if you didn't use article pre-fetch.  The server itself
will also become more loaded--both with the extra article requests,
and the extra connection.

Ok, so now you know that you shouldn't really use this thing... unless
you really want to.

Here's how: Set `gnus-asynchronous' to `t'.  The rest should happen
automatically.

You can control how many articles are to be pre-fetched by setting
`gnus-use-article-prefetch'.  This is 30 by default, which means
that when you read an article in the group, the back end will pre-fetch
the next 30 articles.  If this variable is `t', the back end will
pre-fetch all the articles it can without bound.  If it is
`nil', no pre-fetching will be done.

There are probably some articles that you don't want to
pre-fetch--read articles, for instance.  The
`gnus-async-prefetch-article-p' variable controls whether an article
is to be pre-fetched.  This function should return non-`nil' when the
article in question is to be pre-fetched.  The default is
`gnus-async-unread-p', which returns `nil' on read articles.  The
function is called with an article data structure as the only
parameter.

If, for instance, you wish to pre-fetch only unread articles shorter
than 100 lines, you could say something like:

     (defun my-async-short-unread-p (data)
       "Return non-nil for short, unread articles."
       (and (gnus-data-unread-p data)
            (< (mail-header-lines (gnus-data-header data))
               100)))

     (setq gnus-async-prefetch-article-p 'my-async-short-unread-p)

These functions will be called many, many times, so they should
preferably be short and sweet to avoid slowing down Gnus too much.
It's probably a good idea to byte-compile things like this.

Articles have to be removed from the asynch buffer sooner or later.
The `gnus-prefetched-article-deletion-strategy' says when to remove
articles.  This is a list that may contain the following elements:

`read'
     Remove articles when they are read.

`exit'
     Remove articles when exiting the group.

The default value is `(read exit)'.





File: gnus, Node: Article Caching, Next: Persistent Articles, Prev: Asynchronous Fetching, Up: Summary Buffer

Article Caching
===============

If you have an *extremely* slow NNTP connection, you may consider
turning article caching on.  Each article will then be stored locally
under your home directory.  As you may surmise, this could potentially
use *huge* amounts of disk space, as well as eat up all your inodes so
fast it will make your head swim.  In vodka.

Used carefully, though, it could be just an easier way to save
articles.

To turn caching on, set `gnus-use-cache' to `t'.  By default,
all articles ticked or marked as dormant will then be copied
over to your local cache (`gnus-cache-directory').  Whether this
cache is flat or hierarchical is controlled by the
`gnus-use-long-file-name' variable, as usual.

When re-selecting a ticked or dormant article, it will be fetched from
the cache instead of from the server.  As articles in your cache will
never expire, this might serve as a method of saving articles while
still keeping them where they belong.  Just mark all articles you want
to save as dormant, and don't worry.

When an article is marked as read, is it removed from the cache.

The entering/removal of articles from the cache is controlled by the
`gnus-cache-enter-articles' and `gnus-cache-remove-articles'
variables.  Both are lists of symbols.  The first is `(ticked
dormant)' by default, meaning that ticked and dormant articles will be
put in the cache.  The latter is `(read)' by default, meaning that
articles marked as read are removed from the cache.  Possibly
symbols in these two lists are `ticked', `dormant',
`unread' and `read'.

So where does the massive article-fetching and storing come into the
picture?  The `gnus-jog-cache' command will go through all subscribed
newsgroups, request all unread articles, score them, and store them in
the cache.  You should only ever, ever ever ever, use this command if
1) your connection to the NNTP server is really, really, really slow
and 2) you have a really, really, really huge disk.  Seriously.  One
way to cut down on the number of articles downloaded is to score
unwanted articles down and have them marked as read.  They will not
then be downloaded by this command.

It is likely that you do not want caching on all groups.  For
instance, if your `nnml' mail is located under your home directory, it
makes no sense to cache it somewhere else under your home directory.
Unless you feel that it's neat to use twice as much space.

To limit the caching, you could set `gnus-cacheable-groups' to a
regexp of groups to cache, `^nntp' for instance, or set the
`gnus-uncacheable-groups' regexp to `^nnml', for instance.  Both
variables are `nil' by default.  If a group matches both variables,
the group is not cached.

The cache stores information on what articles it contains in its
active file (`gnus-cache-active-file').  If this file (or any other
parts of the cache) becomes all messed up for some reason or other,
Gnus offers two functions that will try to set things right.  `M-x
gnus-cache-generate-nov-databases' will (re)build all the NOV files,
and `gnus-cache-generate-active' will (re)generate the active file.

`gnus-cache-move-cache' will move your whole `gnus-cache-directory' to
some other location.  You get asked to where, isn't that cool?



File: gnus, Node: Persistent Articles, Next: Sticky Articles, Prev: Article Caching, Up: Summary Buffer

Persistent Articles
===================

Closely related to article caching, we have "persistent articles".  In
fact, it's just a different way of looking at caching, and much more
useful in my opinion.

Say you're reading a newsgroup, and you happen on to some valuable gem
that you want to keep and treasure forever.  You'd normally just save
it (using one of the many saving commands) in some file.  The problem
with that is that it's just, well, yucky.  Ideally you'd prefer just
having the article remain in the group where you found it forever;
untouched by the expiry going on at the news server.

This is what a "persistent article" is--an article that just won't be
deleted.  It's implemented using the normal cache functions, but you
use two explicit commands for managing persistent articles:


`*'
     Make the current article persistent (`gnus-cache-enter-article').

`M-*'
     Remove the current article from the persistent articles
     (`gnus-cache-remove-article').  This will normally delete the
     article.

Both these commands understand the process/prefix convention.

To avoid having all ticked articles (and stuff) entered into the
cache, you should set `gnus-use-cache' to `passive' if you're just
interested in persistent articles:

     (setq gnus-use-cache 'passive)



File: gnus, Node: Sticky Articles, Next: Article Backlog, Prev: Persistent Articles, Up: Summary Buffer

Sticky Articles
===============

When you select an article the current article buffer will be reused
according to the value of the variable `gnus-single-article-buffer'.
If its value is non-`nil' (the default) all articles reuse the same
article buffer.  Else each group has its own article buffer.

This implies that it's not possible to have more than one article
buffer in a group at a time.  But sometimes you might want to display
all the latest emails from your mother, your father, your aunt, your
uncle and your 17 cousins to coordinate the next christmas party.

That's where sticky articles come in handy.  A sticky article buffer
basically is a normal article buffer, but it won't be reused when you
select another article.  You can make an article sticky with:

`A S'
     Make the current article sticky.  If a prefix arg is given, ask
     for a name for this sticky article buffer.

To close a sticky article buffer you can use these commands:

`q'
     Puts this sticky article buffer at the end of the list of all
     buffers.

`k'
     Kills this sticky article buffer.

To kill all sticky article buffers you can use:

 -- Function: gnus-kill-sticky-article-buffers ARG
     Kill all sticky article buffers.  If a prefix ARG is given, ask
     for confirmation.



File: gnus, Node: Article Backlog, Next: Saving Articles, Prev: Sticky Articles, Up: Summary Buffer

Article Backlog
===============

If you have a slow connection, but the idea of using caching seems
unappealing to you (and it is, really), you can help the situation
some by switching on the "backlog".  This is where Gnus will buffer
already read articles so that it doesn't have to re-fetch articles
you've already read.  This only helps if you are in the habit of
re-selecting articles you've recently read, of course.  If you never
do that, turning the backlog on will slow Gnus down a little bit, and
increase memory usage some.

If you set `gnus-keep-backlog' to a number N, Gnus will store at most
N old articles in a buffer for later re-fetching.  If this variable is
non-`nil' and is not a number, Gnus will store *all* read articles,
which means that your Emacs will grow without bound before exploding
and taking your machine down with you.  I put that in there just to
keep y'all on your toes.

The default value is 20.




File: gnus, Node: Saving Articles, Next: Decoding Articles, Prev: Article Backlog, Up: Summary Buffer

Saving Articles
===============

Gnus can save articles in a number of ways.  Below is the
documentation for saving articles in a fairly straight-forward fashion
(i.e., little processing of the article is done before it is saved).
For a different approach (uudecoding, unsharing) you should use
`gnus-uu' (*Note Decoding Articles::).

For the commands listed here, the target is a file.  If you want to
save to a group, see the `B c' (`gnus-summary-copy-article') command
(*Note Mail Group Commands::).

If `gnus-save-all-headers' is non-`nil', Gnus will not delete unwanted
headers before saving the article.

If the preceding variable is `nil', all headers that match the
`gnus-saved-headers' regexp will be kept, while the rest will be
deleted before saving.


`O o'
`o'
     Save the current article using the default article saver
     (`gnus-summary-save-article').

`O m'
     Save the current article in a Unix mail box (mbox) file
     (`gnus-summary-save-article-mail').

`O r'
     Save the current article in Rmail format
     (`gnus-summary-save-article-rmail').

`O f'
     Save the current article in plain file format
     (`gnus-summary-save-article-file').

`O F'
     Write the current article in plain file format, overwriting any
     previous file contents (`gnus-summary-write-article-file').

`O b'
     Save the current article body in plain file format
     (`gnus-summary-save-article-body-file').

`O h'
     Save the current article in mh folder format
     (`gnus-summary-save-article-folder').

`O v'
     Save the current article in a VM folder
     (`gnus-summary-save-article-vm').

`O p'
`|'
     Save the current article in a pipe.  Uhm, like, what I mean
     is--Pipe the current article to a process
     (`gnus-summary-pipe-output').  If given a symbolic prefix (*Note
     Symbolic Prefixes::), include the complete headers in the piped
     output.

`O P'
     Save the current article into muttprint.  That is, print it using
     the external program Muttprint
     (http://muttprint.sourceforge.net/).  The program name and
     options to use is controlled by the variable
     `gnus-summary-muttprint-program'.  (`gnus-summary-muttprint').


All these commands use the process/prefix convention (*Note
Process/Prefix::).  If you save bunches of articles using these
functions, you might get tired of being prompted for files to save
each and every article in.  The prompting action is controlled by the
`gnus-prompt-before-saving' variable, which is `always' by default,
giving you that excessive prompting action you know and loathe.  If
you set this variable to `t' instead, you'll be prompted just once for
each series of articles you save.  If you like to really have Gnus do
all your thinking for you, you can even set this variable to `nil',
which means that you will never be prompted for files to save articles
in.  Gnus will simply save all the articles in the default files.


You can customize the `gnus-default-article-saver' variable to make
Gnus do what you want it to.  You can use any of the eight ready-made
functions below, or you can create your own.


`gnus-summary-save-in-rmail'
     This is the default format, "Babyl".  Uses the function in the
     `gnus-rmail-save-name' variable to get a file name to save the
     article in.  The default is `gnus-plain-save-name'.

`gnus-summary-save-in-mail'
     Save in a Unix mail (mbox) file.  Uses the function in the
     `gnus-mail-save-name' variable to get a file name to save the
     article in.  The default is `gnus-plain-save-name'.

`gnus-summary-save-in-file'
     Append the article straight to an ordinary file.  Uses the
     function in the `gnus-file-save-name' variable to get a file name
     to save the article in.  The default is `gnus-numeric-save-name'.

`gnus-summary-write-to-file'
     Write the article straight to an ordinary file.  The file is
     overwritten if it exists.  Uses the function in the
     `gnus-file-save-name' variable to get a file name to save the
     article in.  The default is `gnus-numeric-save-name'.

`gnus-summary-save-body-in-file'
     Append the article body to an ordinary file.  Uses the function
     in the `gnus-file-save-name' variable to get a file name to save
     the article in.  The default is `gnus-numeric-save-name'.

`gnus-summary-write-body-to-file'
     Write the article body straight to an ordinary file.  The file is
     overwritten if it exists.  Uses the function in the
     `gnus-file-save-name' variable to get a file name to save the
     article in.  The default is `gnus-numeric-save-name'.

`gnus-summary-save-in-folder'
     Save the article to an MH folder using `rcvstore' from the MH
     library.  Uses the function in the `gnus-folder-save-name' variable
     to get a file name to save the article in.  The default is
     `gnus-folder-save-name', but you can also use
     `gnus-Folder-save-name', which creates capitalized names.

`gnus-summary-save-in-vm'
     Save the article in a VM folder.  You have to have the VM mail
     reader to use this setting.

The symbol of each function may have the following properties:

`:decode'
     The value non-`nil' means save decoded articles.  This is
     meaningful only with `gnus-summary-save-in-file',
     `gnus-summary-save-body-in-file',
     `gnus-summary-write-to-file', and
     `gnus-summary-write-body-to-file'.

`:function'
     The value specifies an alternative function which appends, not
     overwrites, articles to a file.  This implies that when saving many
     articles at a time, `gnus-prompt-before-saving' is bound to
     `t' and all articles are saved in a single file.  This is
     meaningful only with `gnus-summary-write-to-file' and
     `gnus-summary-write-body-to-file'.

`:headers'
     The value specifies the symbol of a variable of which the value
     specifies headers to be saved.  If it is omitted,
     `gnus-save-all-headers' and `gnus-saved-headers' control what
     headers should be saved.

All of these functions, except for the last one, will save the article
in the `gnus-article-save-directory', which is initialized from the
`SAVEDIR' environment variable.  This is `~/News/' by default.

As you can see above, the functions use different functions to find a
suitable name of a file to save the article in.  Below is a list of
available functions that generate names:


`gnus-Numeric-save-name'
     File names like `~/News/Alt.andrea-dworkin/45'.

`gnus-numeric-save-name'
     File names like `~/News/alt.andrea-dworkin/45'.

`gnus-Plain-save-name'
     File names like `~/News/Alt.andrea-dworkin'.

`gnus-plain-save-name'
     File names like `~/News/alt.andrea-dworkin'.

`gnus-sender-save-name'
     File names like `~/News/larsi'.

You can have Gnus suggest where to save articles by plonking a regexp
into the `gnus-split-methods' alist.  For instance, if you would like
to save articles related to Gnus in the file `gnus-stuff', and
articles related to VM in `vm-stuff', you could set this variable to
something like:

     (("^Subject:.*gnus\\|^Newsgroups:.*gnus" "gnus-stuff")
      ("^Subject:.*vm\\|^Xref:.*vm" "vm-stuff")
      (my-choosing-function "../other-dir/my-stuff")
      ((equal gnus-newsgroup-name "mail.misc") "mail-stuff"))

We see that this is a list where each element is a list that has two
elements--the "match" and the "file".  The match can either be a
string (in which case it is used as a regexp to match on the article
head); it can be a symbol (which will be called as a function with the
group name as a parameter); or it can be a list (which will be
`eval'ed).  If any of these actions have a non-`nil' result, the
file" will be used as a default prompt.  In addition, the result of
the operation itself will be used if the function or form called
returns a string or a list of strings.

You basically end up with a list of file names that might be used when
saving the current article.  (All "matches" will be used.)  You will
then be prompted for what you really want to use as a name, with file
name completion over the results from applying this variable.

This variable is `((gnus-article-archive-name))' by default, which
means that Gnus will look at the articles it saves for an
`Archive-name' line and use that as a suggestion for the file name.

Here's an example function to clean up file names somewhat.  If you
have lots of mail groups called things like `nnml:mail.whatever', you
may want to chop off the beginning of these group names before
creating the file name to save to.  The following will do just that:

     (defun my-save-name (group)
       (when (string-match "^nnml:mail." group)
         (substring group (match-end 0))))

     (setq gnus-split-methods
           '((gnus-article-archive-name)
             (my-save-name)))


Finally, you have the `gnus-use-long-file-name' variable.  If it is
`nil', all the preceding functions will replace all periods (`.') in
the group names with slashes (`/')---which means that the functions
will generate hierarchies of directories instead of having all the
files in the top level directory (`~/News/alt/andrea-dworkin' instead
of `~/News/alt.andrea-dworkin'.)  This variable is `t' by default on
most systems.  However, for historical reasons, this is `nil' on Xenix
and usg-unix-v machines by default.

This function also affects kill and score file names.  If this
variable is a list, and the list contains the element `not-score',
long file names will not be used for score files, if it contains the
element `not-save', long file names will not be used for saving, and
if it contains the element `not-kill', long file names will not be
used for kill files.

If you'd like to save articles in a hierarchy that looks something
like a spool, you could

     (setq gnus-use-long-file-name '(not-save)) ; to get a hierarchy
     (setq gnus-default-article-saver
           'gnus-summary-save-in-file)          ; no encoding

Then just save with `o'.  You'd then read this hierarchy with
ephemeral `nneething' groups---`G D' in the group buffer, and the top
level directory as the argument (`~/News/').  Then just walk around to
the groups/directories with `nneething'.




File: gnus, Node: Decoding Articles, Next: Article Treatment, Prev: Saving Articles, Up: Summary Buffer

Decoding Articles
=================

Sometime users post articles (or series of articles) that have been
encoded in some way or other.  Gnus can decode them for you.

* Menu:

* Uuencoded Articles::          Uudecode articles.
* Shell Archives::              Unshar articles.
* PostScript Files::            Split PostScript.
* Other Files::                 Plain save and binhex.
* Decoding Variables::          Variables for a happy decoding.
* Viewing Files::               You want to look at the result of the decoding?

All these functions use the process/prefix convention (*Note
Process/Prefix::) for finding out what articles to work on, with the
extension that a "single article" means "a single series".  Gnus can
find out by itself what articles belong to a series, decode all the
articles and unpack/view/save the resulting file(s).

Gnus guesses what articles are in the series according to the
following simplish rule: The subjects must be (nearly) identical,
except for the last two numbers of the line.  (Spaces are largely
ignored, however.)

For example: If you choose a subject called `cat.gif (2/3)', Gnus will
find all the articles that match the regexp `^cat.gif
([0-9]+/[0-9]+).*$'.

Subjects that are non-standard, like `cat.gif (2/3) Part 6 of a
series', will not be properly recognized by any of the automatic
viewing commands, and you have to mark the articles manually with `#'.




File: gnus, Node: Uuencoded Articles, Next: Shell Archives, Prev: Decoding Articles, Up: Decoding Articles

Uuencoded Articles
------------------


`X u'
     Uudecodes the current series (`gnus-uu-decode-uu').

`X U'
     Uudecodes and saves the current series
     (`gnus-uu-decode-uu-and-save').

`X v u'
     Uudecodes and views the current series
     (`gnus-uu-decode-uu-view').

`X v U'
     Uudecodes, views and saves the current series
     (`gnus-uu-decode-uu-and-save-view').


Remember that these all react to the presence of articles marked with
the process mark.  If, for instance, you'd like to decode and save an
entire newsgroup, you'd typically do `M P a' (`gnus-uu-mark-all') and
then `X U' (`gnus-uu-decode-uu-and-save').

All this is very much different from how `gnus-uu' worked with
GNUS 4.1, where you had explicit keystrokes for everything under
the sun.  This version of `gnus-uu' generally assumes that you mark
articles in some way (*Note Setting Process Marks::) and then press
`X u'.

Note: When trying to decode articles that have names matching
`gnus-uu-notify-files', which is hard-coded to
`[Cc][Ii][Nn][Dd][Yy][0-9]+.\\(gif\\|jpg\\)', `gnus-uu' will
automatically post an article on `comp.unix.wizards' saying that you
have just viewed the file in question.  This feature can't be turned
off.




File: gnus, Node: Shell Archives, Next: PostScript Files, Prev: Uuencoded Articles, Up: Decoding Articles

Shell Archives
--------------

Shell archives ("shar files") used to be a popular way to distribute
sources, but it isn't used all that much today.  In any case, we have
some commands to deal with these:


`X s'
     Unshars the current series (`gnus-uu-decode-unshar').

`X S'
     Unshars and saves the current series
     (`gnus-uu-decode-unshar-and-save').

`X v s'
     Unshars and views the current series
     (`gnus-uu-decode-unshar-view').

`X v S'
     Unshars, views and saves the current series
     (`gnus-uu-decode-unshar-and-save-view').




File: gnus, Node: PostScript Files, Next: Other Files, Prev: Shell Archives, Up: Decoding Articles

PostScript Files
----------------


`X p'
     Unpack the current PostScript series
     (`gnus-uu-decode-postscript').

`X P'
     Unpack and save the current PostScript series
     (`gnus-uu-decode-postscript-and-save').

`X v p'
     View the current PostScript series
     (`gnus-uu-decode-postscript-view').

`X v P'
     View and save the current PostScript series
     (`gnus-uu-decode-postscript-and-save-view').




File: gnus, Node: Other Files, Next: Decoding Variables, Prev: PostScript Files, Up: Decoding Articles

Other Files
-----------

`X o'
     Save the current series (`gnus-uu-decode-save').

`X b'
     Unbinhex the current series (`gnus-uu-decode-binhex').  This
     doesn't really work yet.

`X Y'
     yEnc-decode the current series and save it
     (`gnus-uu-decode-yenc').




File: gnus, Node: Decoding Variables, Next: Viewing Files, Prev: Other Files, Up: Decoding Articles

Decoding Variables
------------------

Adjective, not verb.

* Menu:

* Rule Variables::              Variables that say how a file is to be viewed.
* Other Decode Variables::      Other decode variables.
* Uuencoding and Posting::      Variables for customizing uuencoding.




File: gnus, Node: Rule Variables, Next: Other Decode Variables, Prev: Decoding Variables, Up: Decoding Variables

Rule Variables
..............

Gnus uses "rule variables" to decide how to view a file.  All these
variables are of the form

           (list '(regexp1 command2)
                 '(regexp2 command2)
                 ...)


`gnus-uu-user-view-rules'
     This variable is consulted first when viewing files.  If you wish
     to use, for instance, `sox' to convert an `.au' sound file, you
     could say something like:
          (setq gnus-uu-user-view-rules
                (list '("\\\\.au$" "sox %s -t .aiff > /dev/audio")))

`gnus-uu-user-view-rules-end'
     This variable is consulted if Gnus couldn't make any matches from
     the user and default view rules.

`gnus-uu-user-archive-rules'
     This variable can be used to say what commands should be used to
     unpack archives.




File: gnus, Node: Other Decode Variables, Next: Uuencoding and Posting, Prev: Rule Variables, Up: Decoding Variables

Other Decode Variables
......................


`gnus-uu-grabbed-file-functions'
     All functions in this list will be called right after each file
     has been successfully decoded--so that you can move or view files
     right away, and don't have to wait for all files to be decoded
     before you can do anything.  Ready-made functions you can put in
     this list are:


     `gnus-uu-grab-view'
          View the file.

     `gnus-uu-grab-move'
          Move the file (if you're using a saving function.)

`gnus-uu-be-dangerous'
     Specifies what to do if unusual situations arise during decoding.
     If `nil', be as conservative as possible.  If `t', ignore things
     that didn't work, and overwrite existing files.  Otherwise, ask
     each time.

`gnus-uu-ignore-files-by-name'
     Files with name matching this regular expression won't be viewed.

`gnus-uu-ignore-files-by-type'
     Files with a MIME type matching this variable won't be viewed.
     Note that Gnus tries to guess what type the file is based on the
     name.  `gnus-uu' is not a MIME package (yet), so this is slightly
     kludgey.

`gnus-uu-tmp-dir'
     Where `gnus-uu' does its work.

`gnus-uu-do-not-unpack-archives'
     Non-`nil' means that `gnus-uu' won't peek inside archives looking
     for files to display.

`gnus-uu-view-and-save'
     Non-`nil' means that the user will always be asked to save a file
     after viewing it.

`gnus-uu-ignore-default-view-rules'
     Non-`nil' means that `gnus-uu' will ignore the default viewing
     rules.

`gnus-uu-ignore-default-archive-rules'
     Non-`nil' means that `gnus-uu' will ignore the default archive
     unpacking commands.

`gnus-uu-kill-carriage-return'
     Non-`nil' means that `gnus-uu' will strip all carriage returns
     from articles.

`gnus-uu-unmark-articles-not-decoded'
     Non-`nil' means that `gnus-uu' will mark unsuccessfully decoded
     articles as unread.

`gnus-uu-correct-stripped-uucode'
     Non-`nil' means that `gnus-uu' will *try* to fix uuencoded files
     that have had trailing spaces deleted.

`gnus-uu-pre-uudecode-hook'
     Hook run before sending a message to `uudecode'.

`gnus-uu-view-with-metamail'
     Non-`nil' means that `gnus-uu' will ignore the viewing
     commands defined by the rule variables and just fudge a MIME
     content type based on the file name.  The result will be fed to
     `metamail' for viewing.

`gnus-uu-save-in-digest'
     Non-`nil' means that `gnus-uu', when asked to save without
     decoding, will save in digests.  If this variable is `nil',
     `gnus-uu' will just save everything in a file without any
     embellishments.  The digesting almost conforms to RFC 1153--no
     easy way to specify any meaningful volume and issue numbers were
     found, so I simply dropped them.





File: gnus, Node: Uuencoding and Posting, Prev: Other Decode Variables, Up: Decoding Variables

Uuencoding and Posting
......................


`gnus-uu-post-include-before-composing'
     Non-`nil' means that `gnus-uu' will ask for a file to encode
     before you compose the article.  If this variable is `t', you can
     either include an encoded file with `C-c C-i' or have one
     included for you when you post the article.

`gnus-uu-post-length'
     Maximum length of an article.  The encoded file will be split
     into how many articles it takes to post the entire file.

`gnus-uu-post-threaded'
     Non-`nil' means that `gnus-uu' will post the encoded file in a
     thread.  This may not be smart, as no other decoder I have seen
     is able to follow threads when collecting uuencoded articles.
     (Well, I have seen one package that does that---`gnus-uu', but
     somehow, I don't think that counts...) Default is `nil'.

`gnus-uu-post-separate-description'
     Non-`nil' means that the description will be posted in a separate
     article.  The first article will typically be numbered (0/x).  If
     this variable is `nil', the description the user enters will be
     included at the beginning of the first article, which will be
     numbered (1/x).  Default is `t'.





File: gnus, Node: Viewing Files, Prev: Decoding Variables, Up: Decoding Articles

Viewing Files
-------------

After decoding, if the file is some sort of archive, Gnus will attempt
to unpack the archive and see if any of the files in the archive can
be viewed.  For instance, if you have a gzipped tar file `pics.tar.gz'
containing the files `pic1.jpg' and `pic2.gif', Gnus will uncompress
and de-tar the main file, and then view the two pictures.  This
unpacking process is recursive, so if the archive contains archives of
archives, it'll all be unpacked.

Finally, Gnus will normally insert a "pseudo-article" for each
extracted file into the summary buffer.  If you go to these
articles", you will be prompted for a command to run (usually Gnus
will make a suggestion), and then the command will be run.

If `gnus-view-pseudo-asynchronously' is `nil', Emacs will wait until
the viewing is done before proceeding.

If `gnus-view-pseudos' is `automatic', Gnus will not insert the
pseudo-articles into the summary buffer, but view them immediately.
If this variable is `not-confirm', the user won't even be asked for a
confirmation before viewing is done.

If `gnus-view-pseudos-separately' is non-`nil', one pseudo-article
will be created for each file to be viewed.  If `nil', all files that
use the same viewing command will be given as a list of parameters to
that command.

If `gnus-insert-pseudo-articles' is non-`nil', insert pseudo-articles
when decoding.  It is `t' by default.

So; there you are, reading your *pseudo-articles* in your *virtual
newsgroup* from the *virtual server*; and you think: Why isn't
anything real anymore? How did we get here?




File: gnus, Node: Article Treatment, Next: MIME Commands, Prev: Decoding Articles, Up: Summary Buffer

Article Treatment
=================

Reading through this huge manual, you may have quite forgotten that
the object of newsreaders is to actually, like, read what people have
written.  Reading articles.  Unfortunately, people are quite bad at
writing, so there are tons of functions and variables to make reading
these articles easier.

* Menu:

* Article Highlighting::        You want to make the article look like fruit salad.
* Article Fontisizing::         Making emphasized text look nice.
* Article Hiding::              You also want to make certain info go away.
* Article Washing::             Lots of way-neat functions to make life better.
* Article Header::              Doing various header transformations.
* Article Buttons::             Click on URLs, Message-IDs, addresses and the like.
* Article Button Levels::       Controlling appearance of buttons.
* Article Date::                Grumble, UT!
* Article Display::             Display various stuff--X-Face, Picons, Smileys
* Article Signature::           What is a signature?
* Article Miscellanea::         Various other stuff.




File: gnus, Node: Article Highlighting, Next: Article Fontisizing, Prev: Article Treatment, Up: Article Treatment

Article Highlighting
--------------------

Not only do you want your article buffer to look like fruit salad, but
you want it to look like technicolor fruit salad.


`W H a'
     Do much highlighting of the current article
     (`gnus-article-highlight').  This function highlights header,
     cited text, the signature, and adds buttons to the body and the
     head.

`W H h'
     Highlight the headers (`gnus-article-highlight-headers').  The
     highlighting will be done according to the `gnus-header-face-alist'
     variable, which is a list where each element has the form
     `(REGEXP NAME CONTENT)'.
     REGEXP is a regular expression for matching the
     header, NAME is the face used for highlighting the header name
     (*Note Faces and Fonts::) and CONTENT is the face for highlighting
     the header value.  The first match made will be used.  Note that
     REGEXP shouldn't have `^' prepended--Gnus will add one.

`W H c'
     Highlight cited text (`gnus-article-highlight-citation').

     Some variables to customize the citation highlights:


     `gnus-cite-parse-max-size'
          If the article size in bytes is bigger than this variable
          (which is 25000 by default), no citation highlighting will
          be performed.

     `gnus-cite-max-prefix'
          Maximum possible length for a citation prefix (default 20).

     `gnus-cite-face-list'
          List of faces used for highlighting citations (*Note Faces
          and Fonts::).  When there are citations from multiple
          articles in the same message, Gnus will try to give each
          citation from each article its own face.  This should make
          it easier to see who wrote what.

     `gnus-supercite-regexp'
          Regexp matching normal Supercite attribution lines.

     `gnus-supercite-secondary-regexp'
          Regexp matching mangled Supercite attribution lines.

     `gnus-cite-minimum-match-count'
          Minimum number of identical prefixes we have to see before
          we believe that it's a citation.

     `gnus-cite-attribution-prefix'
          Regexp matching the beginning of an attribution line.

     `gnus-cite-attribution-suffix'
          Regexp matching the end of an attribution line.

     `gnus-cite-attribution-face'
          Face used for attribution lines.  It is merged with the face
          for the cited text belonging to the attribution.

     `gnus-cite-ignore-quoted-from'
          If non-`nil', no citation highlighting will be performed on
          lines beginning with `>From '.  Those lines may have been
          quoted by MTAs in order not to mix up with the envelope From
          line.  The default value is `t'.



`W H s'
     Highlight the signature (`gnus-article-highlight-signature').
     Everything after `gnus-signature-separator' (*Note Article
     Signature::) in an article will be considered a signature and
     will be highlighted with `gnus-signature-face', which is `italic'
     by default.


*Note Customizing Articles::, for how to highlight articles automatically.




File: gnus, Node: Article Fontisizing, Next: Article Hiding, Prev: Article Highlighting, Up: Article Treatment

Article Fontisizing
-------------------

People commonly add emphasis to words in news articles by writing
things like `_this_' or `*this*' or `/this/'.  Gnus can make this look
nicer by running the article through the `W e'
(`gnus-article-emphasize') command.

How the emphasis is computed is controlled by the
`gnus-emphasis-alist' variable.  This is an alist where the first
element is a regular expression to be matched.  The second is a number
that says what regular expression grouping is used to find the entire
emphasized word.  The third is a number that says what regexp grouping
should be displayed and highlighted.  (The text between these two
groupings will be hidden.)  The fourth is the face used for
highlighting.

     (setq gnus-emphasis-alist
           '(("_\\(\\w+\\)_" 0 1 gnus-emphasis-underline)
             ("\\*\\(\\w+\\)\\*" 0 1 gnus-emphasis-bold)))


By default, there are seven rules, and they use the following faces:
`gnus-emphasis-bold', `gnus-emphasis-italic',
`gnus-emphasis-underline', `gnus-emphasis-bold-italic',
`gnus-emphasis-underline-italic',
`gnus-emphasis-underline-bold', and
`gnus-emphasis-underline-bold-italic'.

If you want to change these faces, you can either use `M-x customize',
or you can use `copy-face'.  For instance, if you want to make
`gnus-emphasis-italic' use a red face instead, you could say something
like:

     (copy-face 'red 'gnus-emphasis-italic)


If you want to highlight arbitrary words, you can use the
`gnus-group-highlight-words-alist' variable, which uses the same
syntax as `gnus-emphasis-alist'.  The `highlight-words' group
parameter (*Note Group Parameters::) can also be used.

*Note Customizing Articles::, for how to fontize articles automatically.




