Info file: gnus,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License" in the Emacs manual.

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding
     a copy of the license to the document, as described in section 6
     of the license.



INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus: (gnus).         The newsreader Gnus.
END-INFO-DIR-ENTRY








File: gnus, Node: Common Variables, Next: NNTP marks, Prev: Indirect Functions, Up: NNTP

Common Variables
................

The following variables affect the behavior of all, or several of the
pre-made connection functions.  When not specified, all functions are
affected (the values of the following variables will be used as the
default if each virtual `nntp' server doesn't specify those server
variables individually).


`nntp-pre-command'
     A command wrapper to use when connecting through a non native
     connection function (all except `nntp-open-network-stream',
     `nntp-open-tls-stream', and `nntp-open-ssl-stream').  This is
     where you would put a `SOCKS' wrapper for instance.

`nntp-address'
     The address of the NNTP server.

`nntp-port-number'
     Port number to connect to the NNTP server.  The default is
     `nntp'.  If you use NNTP over TLS/SSL, you may want to use
     integer ports rather than named ports (i.e, use `563' instead of
     `snews' or `nntps'), because external TLS/SSL tools may not work
     with named ports.

`nntp-end-of-line'
     String to use as end-of-line marker when talking to the NNTP
     server.  This is `\r\n' by default, but should be `\n' when using
     a non native telnet connection function.

`nntp-netcat-command'
     Command to use when connecting to the NNTP server through
     `netcat'.  This is *not* for an intermediate host.  This is
     just for the real NNTP server.  The default is
     `nc'.

`nntp-netcat-switches'
     A list of switches to pass to `nntp-netcat-command'.  The default
     is `()'.




File: gnus, Node: NNTP marks, Prev: Common Variables, Up: NNTP

NNTP marks
..........

Gnus stores marks (*Note Marking Articles::) for NNTP servers in marks
files.  A marks file records what marks you have set in a group and
each file is specific to the corresponding server.  Marks files are
stored in `~/News/marks' (`nntp-marks-directory') under a classic
hierarchy resembling that of a news server, for example marks for the
group `gmane.discuss' on the news.gmane.org server will be stored in
the file `~/News/marks/news.gmane.org/gmane/discuss/.marks'.

Marks files are useful because you can copy the `~/News/marks'
directory (using rsync, scp or whatever) to another Gnus installation,
and it will realize what articles you have read and marked.  The data
in `~/News/marks' has priority over the same data in
`~/.newsrc.eld'.

Note that marks files are very much server-specific: Gnus remembers
the article numbers so if you don't use the same servers on both
installations things are most likely to break (most NNTP servers do
not use the same article numbers as any other server).  However, if
you use servers A, B, C on one installation and servers A, D, E on the
other, you can sync the marks files for A and then you'll get
synchronization for that server between the two installations.

Using NNTP marks can possibly incur a performance penalty so if Gnus
feels sluggish, try setting the `nntp-marks-is-evil' variable to `t'.
Marks will then be stored in `~/.newsrc.eld'.

Related variables:


`nntp-marks-is-evil'
     If non-`nil', this back end will ignore any marks files.  The
     default is `nil'.

`nntp-marks-directory'
     The directory where marks for nntp groups will be stored.





File: gnus, Node: News Spool, Prev: NNTP, Up: Getting News

News Spool
----------

Subscribing to a foreign group from the local spool is extremely easy,
and might be useful, for instance, to speed up reading groups that
contain very big articles---`alt.binaries.pictures.furniture', for
instance.

Anyway, you just specify `nnspool' as the method and `""' (or anything
else) as the address.

If you have access to a local spool, you should probably use that as
the native select method (*Note Finding the News::).  It is normally
faster than using an `nntp' select method, but might not be.  It
depends.  You just have to try to find out what's best at your site.


`nnspool-inews-program'
     Program used to post an article.

`nnspool-inews-switches'
     Parameters given to the inews program when posting an article.

`nnspool-spool-directory'
     Where `nnspool' looks for the articles.  This is normally
     `/usr/spool/news/'.

`nnspool-nov-directory'
     Where `nnspool' will look for NOV files.  This is normally
     `/usr/spool/news/over.view/'.

`nnspool-lib-dir'
     Where the news lib dir is (`/usr/lib/news/' by default).

`nnspool-active-file'
     The name of the active file.

`nnspool-newsgroups-file'
     The name of the group descriptions file.

`nnspool-history-file'
     The name of the news history file.

`nnspool-active-times-file'
     The name of the active date file.

`nnspool-nov-is-evil'
     If non-`nil', `nnspool' won't try to use any NOV files that it
     finds.

`nnspool-sift-nov-with-sed'
     If non-`nil', which is the default, use `sed' to get the relevant
     portion from the overview file.  If `nil', `nnspool' will load
     the entire file into a buffer and process it there.





File: gnus, Node: Getting Mail, Next: Browsing the Web, Prev: Getting News, Up: Select Methods

Getting Mail
============

Reading mail with a newsreader--isn't that just plain WeIrD? But of
course.

* Menu:

* Mail in a Newsreader::        Important introductory notes.
* Getting Started Reading Mail::  A simple cookbook example.
* Splitting Mail::              How to create mail groups.
* Mail Sources::                How to tell Gnus where to get mail from.
* Mail Back End Variables::     Variables for customizing mail handling.
* Fancy Mail Splitting::        Gnus can do hairy splitting of incoming mail.
* Group Mail Splitting::        Use group customize to drive mail splitting.
* Incorporating Old Mail::      What about the old mail you have?
* Expiring Mail::               Getting rid of unwanted mail.
* Washing Mail::                Removing cruft from the mail you get.
* Duplicates::                  Dealing with duplicated mail.
* Not Reading Mail::            Using mail back ends for reading other files.
* Choosing a Mail Back End::    Gnus can read a variety of mail formats.




File: gnus, Node: Mail in a Newsreader, Next: Getting Started Reading Mail, Prev: Getting Mail, Up: Getting Mail

Mail in a Newsreader
--------------------

If you are used to traditional mail readers, but have decided to
switch to reading mail with Gnus, you may find yourself experiencing
something of a culture shock.

Gnus does not behave like traditional mail readers.  If you want to
make it behave that way, you can, but it's an uphill battle.

Gnus, by default, handles all its groups using the same approach.
This approach is very newsreaderly--you enter a group, see the
new/unread messages, and when you read the messages, they get marked
as read, and you don't see them any more.  (Unless you explicitly ask
for them.)

In particular, you do not do anything explicitly to delete messages.

Does this mean that all the messages that have been marked as read are
deleted?  How awful!

But, no, it means that old messages are "expired" according to some
scheme or other.  For news messages, the expire process is controlled
by the news administrator; for mail, the expire process is controlled
by you.  The expire process for mail is covered in depth in *Note
Expiring Mail::.

What many Gnus users find, after using it a while for both news and
mail, is that the transport mechanism has very little to do with how
they want to treat a message.

Many people subscribe to several mailing lists.  These are transported
via SMTP, and are therefore mail.  But we might go for weeks without
answering, or even reading these messages very carefully.  We may not
need to save them because if we should need to read one again, they
are archived somewhere else.

Some people have local news groups which have only a handful of
readers.  These are transported via NNTP, and are therefore news.  But
we may need to read and answer a large fraction of the messages very
carefully in order to do our work.  And there may not be an archive,
so we may need to save the interesting messages the same way we would
personal mail.

The important distinction turns out to be not the transport mechanism,
but other factors such as how interested we are in the subject matter,
or how easy it is to retrieve the message if we need to read it again.

Gnus provides many options for sorting mail into "groups" which behave
like newsgroups, and for treating each group (whether mail or news)
differently.

Some users never get comfortable using the Gnus (ahem) paradigm and
wish that Gnus should grow up and be a male, er, mail reader.  It is
possible to whip Gnus into a more mailreaderly being, but, as said
before, it's not easy.  People who prefer proper mail readers should
try VM instead, which is an excellent, and proper, mail reader.

I don't mean to scare anybody off, but I want to make it clear that
you may be required to learn a new way of thinking about messages.
After you've been subjected to The Gnus Way, you will come to love it.
I can guarantee it.  (At least the guy who sold me the Emacs
Subliminal Brain-Washing Functions that I've put into Gnus did
guarantee it.  You Will Be Assimilated.  You Love Gnus.  You Love The
Gnus Mail Way.  You Do.)




File: gnus, Node: Getting Started Reading Mail, Next: Splitting Mail, Prev: Mail in a Newsreader, Up: Getting Mail

Getting Started Reading Mail
----------------------------

It's quite easy to use Gnus to read your new mail.  You just plonk the
mail back end of your choice into `gnus-secondary-select-methods', and
things will happen automatically.

For instance, if you want to use `nnml' (which is a "one file per
mail" back end), you could put the following in your `~/.gnus.el'
file:

     (setq gnus-secondary-select-methods '((nnml "")))

Now, the next time you start Gnus, this back end will be queried for
new articles, and it will move all the messages in your spool file to
its directory, which is `~/Mail/' by default.  The new group that will
be created (`mail.misc') will be subscribed, and you can read it like
any other group.

You will probably want to split the mail into several groups, though:

     (setq nnmail-split-methods
           '(("junk" "^From:.*Lars Ingebrigtsen")
             ("crazy" "^Subject:.*die\\|^Organization:.*flabby")
             ("other" "")))

This will result in three new `nnml' mail groups being created:
`nnml:junk', `nnml:crazy', and `nnml:other'.  All the mail that
doesn't fit into the first two groups will be placed in the last
group.

This should be sufficient for reading mail with Gnus.  You might want
to give the other sections in this part of the manual a perusal,
though.  Especially *Note Choosing a Mail Back End:: and *Note
Expiring Mail::.




File: gnus, Node: Splitting Mail, Next: Mail Sources, Prev: Getting Started Reading Mail, Up: Getting Mail

Splitting Mail
--------------

The `nnmail-split-methods' variable says how the incoming mail is to
be split into groups.

     (setq nnmail-split-methods
       '(("mail.junk" "^From:.*Lars Ingebrigtsen")
         ("mail.crazy" "^Subject:.*die\\|^Organization:.*flabby")
         ("mail.other" "")))

This variable is a list of lists, where the first element of each of
these lists is the name of the mail group (they do not have to be
called something beginning with `mail', by the way), and the second
element is a regular expression used on the header of each mail to
determine if it belongs in this mail group.  The first string may
contain `\\1' forms, like the ones used by `replace-match' to insert
sub-expressions from the matched text.  For instance:

     ("list.\\1" "From:.* \\(.*\\)-list@majordomo.com")

In that case, `nnmail-split-lowercase-expanded' controls whether the
inserted text should be made lowercase.  *Note Fancy Mail Splitting::.

The second element can also be a function.  In that case, it will be
called narrowed to the headers with the first element of the rule as
the argument.  It should return a non-`nil' value if it thinks that
the mail belongs in that group.

The last of these groups should always be a general one, and the
regular expression should *always* be `""' so that it matches any
mails that haven't been matched by any of the other regexps.  (These
rules are processed from the beginning of the alist toward the end.
The first rule to make a match will "win", unless you have
crossposting enabled.  In that case, all matching rules will "win".)
If no rule matched, the mail will end up in the `bogus' group.  When
new groups are created by splitting mail, you may want to run
`gnus-group-find-new-groups' to see the new groups.  This also applies
to the `bogus' group.

If you like to tinker with this yourself, you can set this variable to
a function of your choice.  This function will be called without any
arguments in a buffer narrowed to the headers of an incoming mail
message.  The function should return a list of group names that it
thinks should carry this mail message.

Note that the mail back ends are free to maul the poor, innocent,
incoming headers all they want to.  They all add `Lines' headers;
some add `X-Gnus-Group' headers; most rename the Unix mbox
`From<SPACE>' line to something else.

The mail back ends all support cross-posting.  If several regexps
match, the mail will be "cross-posted" to all those groups.
`nnmail-crosspost' says whether to use this mechanism or not.  Note
that no articles are crossposted to the general (`""') group.

`nnmh' and `nnml' makes crossposts by creating hard links to the
crossposted articles.  However, not all file systems support hard
links.  If that's the case for you, set
`nnmail-crosspost-link-function' to `copy-file'.  (This variable is
`add-name-to-file' by default.)

If you wish to see where the previous mail split put the messages, you
can use the `M-x nnmail-split-history' command.  If you wish to see
where re-spooling messages would put the messages, you can use
`gnus-summary-respool-trace' and related commands (*Note Mail Group
Commands::).

Header lines longer than the value of
`nnmail-split-header-length-limit' are excluded from the split
function.

By default, splitting does not decode headers, so you can not match on
non-ASCII strings.  But it is useful if you want to match articles
based on the raw header data.  To enable it, set the
`nnmail-mail-splitting-decodes' variable to a non-`nil' value.  In
addition, the value of the `nnmail-mail-splitting-charset' variable is
used for decoding non-MIME encoded string when
`nnmail-mail-splitting-decodes' is non-`nil'.  The default value is
`nil' which means not to decode non-MIME encoded string.  A suitable
value for you will be `undecided' or be the charset used normally in
mails you are interested in.

By default, splitting is performed on all incoming messages.  If you
specify a `directory' entry for the variable `mail-sources' (*Note
Mail Source Specifiers::), however, then splitting does *not* happen
by default.  You can set the variable `nnmail-resplit-incoming' to a
non-`nil' value to make splitting happen even in this case.  (This
variable has no effect on other kinds of entries.)

Gnus gives you all the opportunity you could possibly want for
shooting yourself in the foot.  Let's say you create a group that will
contain all the mail you get from your boss.  And then you
accidentally unsubscribe from the group.  Gnus will still put all the
mail from your boss in the unsubscribed group, and so, when your boss
mails you "Have that report ready by Monday or you're fired!", you'll
never see it and, come Tuesday, you'll still believe that you're
gainfully employed while you really should be out collecting empty
bottles to save up for next month's rent money.




File: gnus, Node: Mail Sources, Next: Mail Back End Variables, Prev: Splitting Mail, Up: Getting Mail

Mail Sources
------------

Mail can be gotten from many different sources--the mail spool, from a
POP mail server, from a procmail directory, or from a maildir, for
instance.

* Menu:

* Mail Source Specifiers::      How to specify what a mail source is.
* Mail Source Customization::   Some variables that influence things.
* Fetching Mail::               Using the mail source specifiers.




File: gnus, Node: Mail Source Specifiers, Next: Mail Source Customization, Prev: Mail Sources, Up: Mail Sources

Mail Source Specifiers
......................

You tell Gnus how to fetch mail by setting `mail-sources' (*Note
Fetching Mail::) to a "mail source specifier".

Here's an example:

     (pop :server "pop3.mailserver.com" :user "myname")

As can be observed, a mail source specifier is a list where the first
element is a "mail source type", followed by an arbitrary number of
keywords".  Keywords that are not explicitly specified are given
default values.

The `mail-sources' is global for all mail groups.  You can specify an
additional mail source for a particular group by including the `group'
mail specifier in `mail-sources', and setting a `mail-source' group
parameter (*Note Group Parameters::) specifying a single mail source.
When this is used, `mail-sources' is typically just `(group)'; the
`mail-source' parameter for a group might look like this:

     (mail-source . (file :path "home/user/spools/foo.spool"))

This means that the group's (and only this group's) messages will be
fetched from the spool file `/user/spools/foo.spool'.

The following mail source types are available:

`file'
     Get mail from a single file; typically from the mail spool.

     Keywords:

     `:path'
          The file name.  Defaults to the value of the `MAIL'
          environment variable or the value of `rmail-spool-directory'
          (usually something like `/usr/mail/spool/user-name').

     `:prescript'
     `:postscript'
          Script run before/after fetching mail.

     An example file mail source:

          (file :path "/usr/spool/mail/user-name")

     Or using the default file name:

          (file)

     If the mail spool file is not located on the local machine, it's
     best to use POP or IMAP or the like to fetch the mail.  You can
     not use ange-ftp file names here--it has no way to lock the mail
     spool while moving the mail.

     If it's impossible to set up a proper server, you can use ssh
     instead.

          (setq mail-sources
                '((file :prescript "ssh host bin/getmail >%t")))

     The `getmail' script would look something like the following:

          #!/bin/sh
          #  getmail - move mail from spool to stdout
          #  flu@iki.fi

          MOVEMAIL=/usr/lib/emacs/20.3/i386-redhat-linux/movemail
          TMP=$HOME/Mail/tmp
          rm -f $TMP; $MOVEMAIL $MAIL $TMP >/dev/null && cat $TMP

     Alter this script to fit the `movemail' and temporary file you
     want to use.


`directory'
     Get mail from several files in a directory.  This is typically
     used when you have procmail split the incoming mail into several
     files.  That is, there is a one-to-one correspondence between
     files in that directory and groups, so that mail from the file
     `foo.bar.spool' will be put in the group `foo.bar'.  (You can
     change the suffix to be used instead of `.spool'.)  Setting
     `nnmail-scan-directory-mail-source-once' to non-`nil' forces Gnus
     to scan the mail source only once.  This is particularly useful
     if you want to scan mail groups at a specified level.

     There is also the variable `nnmail-resplit-incoming', if you set
     that to a non-`nil' value, then the normal splitting process is
     applied to all the files from the directory, *Note Splitting
     Mail::.

     Keywords:

     `:path'
          The name of the directory where the files are.  There is no
          default value.

     `:suffix'
          Only files ending with this suffix are used.  The default is
          `.spool'.

     `:predicate'
          Only files that have this predicate return non-`nil' are
          returned.  The default is `identity'.  This is used as an
          additional filter--only files that have the right suffix
          *and* satisfy this predicate are considered.

     `:prescript'
     `:postscript'
          Script run before/after fetching mail.


     An example directory mail source:

          (directory :path "/home/user-name/procmail-dir/"
                     :suffix ".prcml")

`pop'
     Get mail from a POP server.

     Keywords:

     `:server'
          The name of the POP server.  The default is taken from the
          `MAILHOST' environment variable.

     `:port'
          The port number of the POP server.  This can be a number
          (eg, `:port 1234') or a string (eg, `:port "pop3"').  If it
          is a string, it should be a service name as listed in
          `/etc/services' on Unix systems.  The default is `"pop3"'.
          On some systems you might need to specify it as `"pop-3"'
          instead.

     `:user'
          The user name to give to the POP server.  The default is the
          login name.

     `:password'
          The password to give to the POP server.  If not specified,
          the user is prompted.

     `:program'
          The program to use to fetch mail from the POP server.  This
          should be a `format'-like string.  Here's an example:

               fetchmail %u@%s -P %p %t

          The valid format specifier characters are:

          `t'
               The name of the file the mail is to be moved to.  This
               must always be included in this string.

          `s'
               The name of the server.

          `P'
               The port number of the server.

          `u'
               The user name to use.

          `p'
               The password to use.

          The values used for these specs are taken from the values
          you give the corresponding keywords.

     `:prescript'
          A script to be run before fetching the mail.  The syntax is
          the same as the `:program' keyword.  This can also be a
          function to be run.

     `:postscript'
          A script to be run after fetching the mail.  The syntax is
          the same as the `:program' keyword.  This can also be a
          function to be run.

     `:function'
          The function to use to fetch mail from the POP server.  The
          function is called with one parameter--the name of the file
          where the mail should be moved to.

     `:authentication'
          This can be either the symbol `password' or the symbol `apop'
          and says what authentication scheme to use.  The default is
          `password'.


     If the `:program' and `:function' keywords aren't specified,
     `pop3-movemail' will be used.  If `pop3-leave-mail-on-server' is
     non-`nil' the mail is to be left on the POP server after fetching
     when using `pop3-movemail'.  Note that POP servers maintain no
     state information between sessions, so what the client believes
     is there and what is actually there may not match up.  If they do
     not, then you may get duplicate mails or the whole thing can fall
     apart and leave you with a corrupt mailbox.

     Here are some examples for getting mail from a POP server.  Fetch
     from the default POP server, using the default user name, and
     default fetcher:

          (pop)

     Fetch from a named server with a named user and password:

          (pop :server "my.pop.server"
               :user "user-name" :password "secret")

     Use `movemail' to move the mail:

          (pop :program "movemail po:%u %t %p")

`maildir'
     Get mail from a maildir.  This is a type of mailbox that is
     supported by at least qmail and postfix, where each file in a
     special directory contains exactly one mail.

     Keywords:

     `:path'
          The name of the directory where the mails are stored.  The default is
          taken from the `MAILDIR' environment variable or
          `~/Maildir/'.
     `:subdirs'
          The subdirectories of the Maildir.  The default is
          `("new" "cur")'.


          You can also get mails from remote hosts (because maildirs
          don't suffer from locking problems).


     Two example maildir mail sources:

          (maildir :path "/home/user-name/Maildir/"
                   :subdirs ("cur" "new"))

          (maildir :path "/user@remotehost.org:~/Maildir/"
                   :subdirs ("new"))

`imap'
     Get mail from a IMAP server.  If you don't want to use
     IMAP as intended, as a network mail reading protocol (ie
     with nnimap), for some reason or other, Gnus let you treat it similar
     to a POP server and fetches articles from a given
     IMAP mailbox.  *Note IMAP::, for more information.

     Note that for the Kerberos, GSSAPI, TLS/SSL and STARTTLS support
     you may need external programs and libraries, *Note IMAP::.

     Keywords:

     `:server'
          The name of the IMAP server.  The default is taken from the
          `MAILHOST' environment variable.

     `:port'
          The port number of the IMAP server.  The default is `143', or
          `993' for TLS/SSL connections.

     `:user'
          The user name to give to the IMAP server.  The default is
          the login name.

     `:password'
          The password to give to the IMAP server.  If not specified,
          the user is prompted.

     `:stream'
          What stream to use for connecting to the server, this is one of the
          symbols in `imap-stream-alist'.  Right now, this means
          `gssapi', `kerberos4', `starttls', `tls',
          `ssl', `shell' or the default `network'.

     `:authentication'
          Which authenticator to use for authenticating to the server, this is
          one of the symbols in `imap-authenticator-alist'.  Right now,
          this means `gssapi', `kerberos4', `digest-md5',
          `cram-md5', `anonymous' or the default `login'.

     `:program'
          When using the `shell' :stream, the contents of this variable is
          mapped into the `imap-shell-program' variable.  This should be a
          `format'-like string (or list of strings).  Here's an example:

               ssh %s imapd

          Make sure nothing is interfering with the output of the
          program, e.g., don't forget to redirect the error output to
          the void.  The valid format specifier characters are:

          `s'
               The name of the server.

          `l'
               User name from `imap-default-user'.

          `p'
               The port number of the server.

          The values used for these specs are taken from the values
          you give the corresponding keywords.

     `:mailbox'
          The name of the mailbox to get mail from.  The default is
          `INBOX' which normally is the mailbox which receives
          incoming mail.

     `:predicate'
          The predicate used to find articles to fetch.  The default,
          `UNSEEN UNDELETED', is probably the best choice for most
          people, but if you sometimes peek in your mailbox with a
          IMAP client and mark some articles as read (or; SEEN) you
          might want to set this to `1:*'.  Then all articles in the
          mailbox is fetched, no matter what.  For a complete list of
          predicates, see RFC 2060 section 6.4.4.

     `:fetchflag'
          How to flag fetched articles on the server, the default
          `\Deleted' will mark them as deleted, an alternative would
          be `\Seen' which would simply mark them as read.  These are
          the two most likely choices, but more flags are defined in
          RFC 2060 section 2.3.2.

     `:dontexpunge'
          If non-`nil', don't remove all articles marked as deleted in
          the mailbox after finishing the fetch.


     An example IMAP mail source:

          (imap :server "mail.mycorp.com"
                :stream kerberos4
                :fetchflag "\\Seen")

`webmail'
     Get mail from a webmail server, such as `http://www.hotmail.com/',
     `http://webmail.netscape.com/', `http://www.netaddress.com/',
     `http://mail.yahoo.com/'.

     NOTE: Webmail largely depends on cookies.  A "one-line-cookie"
     patch is required for url "4.0pre.46".

     WARNING: Mails may be lost.  NO WARRANTY.

     Keywords:

     `:subtype'
          The type of the webmail server.  The default is `hotmail'.
          The alternatives are `netscape', `netaddress', `my-deja'.

     `:user'
          The user name to give to the webmail server.  The default is
          the login name.

     `:password'
          The password to give to the webmail server.  If not
          specified, the user is prompted.

     `:dontexpunge'
          If non-`nil', only fetch unread articles and don't move them
          to trash folder after finishing the fetch.


     An example webmail source:

          (webmail :subtype 'hotmail
                   :user "user-name"
                   :password "secret")

`group'
     Get the actual mail source from the `mail-source' group parameter,
     *Note Group Parameters::.


"Common Keywords"
     Common keywords can be used in any type of mail source.

     Keywords:

     `:plugged'
          If non-`nil', fetch the mail even when Gnus is unplugged.
          If you use directory source to get mail, you can specify it
          as in this example:

               (setq mail-sources
                     '((directory :path "/home/pavel/.Spool/"
                                  :suffix ""
                                  :plugged t)))

          Gnus will then fetch your mail even when you are unplugged.
          This is useful when you use local mail and news.



Function Interface
..................

Some of the above keywords specify a Lisp function to be executed.
For each keyword `:foo', the Lisp variable `foo' is bound to the value
of the keyword while the function is executing.  For example, consider
the following mail-source setting:

     (setq mail-sources '((pop :user "jrl"
                               :server "pophost" :function fetchfunc)))

While the function `fetchfunc' is executing, the symbol `user' is
bound to `"jrl"', and the symbol `server' is bound to `"pophost"'.
The symbols `port', `password', `program', `prescript', `postscript',
`function', and `authentication' are also bound (to their default
values).

See above for a list of keywords for each type of mail source.




File: gnus, Node: Mail Source Customization, Next: Fetching Mail, Prev: Mail Source Specifiers, Up: Mail Sources

Mail Source Customization
.........................

The following is a list of variables that influence how the mail is
fetched.  You would normally not need to set or change any of these
variables.

`mail-source-crash-box'
     File where mail will be stored while processing it.  The default is
     `~/.emacs-mail-crash-box'.

`mail-source-delete-incoming'
     If non-`nil', delete incoming files after handling them.  If `t',
     delete the files immediately, if `nil', never delete any files.
     If a positive number, delete files older than number of days (the
     deletion will only happen when receiving new mail).  You may also
     set `mail-source-delete-incoming' to `nil' and call
     `mail-source-delete-old-incoming' from a hook or interactively.
     `mail-source-delete-incoming' defaults to `2' in alpha Gnusae and
     `10' in released Gnusae.  *Note Gnus Development::.

`mail-source-delete-old-incoming-confirm'
     If non-`nil', ask for confirmation before deleting old incoming
     files.  This variable only applies when
     `mail-source-delete-incoming' is a positive number.

`mail-source-ignore-errors'
     If non-`nil', ignore errors when reading mail from a mail source.

`mail-source-directory'
     Directory where incoming mail source files (if any) will be stored.  The
     default is `~/Mail/'.  At present, the only thing this is used for
     is to say where the incoming files will be stored if the variable
     `mail-source-delete-incoming' is `nil' or a number.

`mail-source-incoming-file-prefix'
     Prefix for file name for storing incoming mail.  The default is
     `Incoming', in which case files will end up with names like
     `Incoming30630D_' or `Incoming298602ZD'.  This is really only
     relevant if `mail-source-delete-incoming' is `nil' or a number.

`mail-source-default-file-modes'
     All new mail files will get this file mode.  The default is 384.

`mail-source-movemail-program'
     If non-`nil', name of program for fetching new mail.  If
     `nil', `movemail' in EXEC-DIRECTORY.





File: gnus, Node: Fetching Mail, Prev: Mail Source Customization, Up: Mail Sources

Fetching Mail
.............

The way to actually tell Gnus where to get new mail from is to set
`mail-sources' to a list of mail source specifiers (*Note Mail Source
Specifiers::).

If this variable is `nil', the mail back ends will never attempt to
fetch mail by themselves.

If you want to fetch mail both from your local spool as well as a
POP mail server, you'd say something like:

     (setq mail-sources
           '((file)
             (pop :server "pop3.mail.server"
                  :password "secret")))

Or, if you don't want to use any of the keyword defaults:

     (setq mail-sources
           '((file :path "/var/spool/mail/user-name")
             (pop :server "pop3.mail.server"
                  :user "user-name"
                  :port "pop3"
                  :password "secret")))


When you use a mail back end, Gnus will slurp all your mail from your
inbox and plonk it down in your home directory.  Gnus doesn't move any
mail if you're not using a mail back end--you have to do a lot of
magic invocations first.  At the time when you have finished drawing
the pentagram, lightened the candles, and sacrificed the goat, you
really shouldn't be too surprised when Gnus moves your mail.





File: gnus, Node: Mail Back End Variables, Next: Fancy Mail Splitting, Prev: Mail Sources, Up: Getting Mail

Mail Back End Variables
-----------------------

These variables are (for the most part) pertinent to all the various
mail back ends.

`nnmail-read-incoming-hook'
     The mail back ends all call this hook after reading new mail.
     You can use this hook to notify any mail watch programs, if you
     want to.

`nnmail-split-hook'
     Hook run in the buffer where the mail headers of each message is
     kept just before the splitting based on these headers is done.
     The hook is free to modify the buffer contents in any way it sees
     fit--the buffer is discarded after the splitting has been done,
     and no changes performed in the buffer will show up in any files.
     `gnus-article-decode-encoded-words' is one likely function to add
     to this hook.

`nnmail-pre-get-new-mail-hook'
`nnmail-post-get-new-mail-hook'
     These are two useful hooks executed when treating new incoming
     mail---`nnmail-pre-get-new-mail-hook' (is called just before
     starting to handle the new mail) and
     `nnmail-post-get-new-mail-hook' (is called when the mail handling
     is done).  Here's and example of using these two hooks to change
     the default file modes the new mail files get:

          (add-hook 'nnmail-pre-get-new-mail-hook
                    (lambda () (set-default-file-modes 511)))

          (add-hook 'nnmail-post-get-new-mail-hook
                    (lambda () (set-default-file-modes 551)))

`nnmail-use-long-file-names'
     If non-`nil', the mail back ends will use long file and directory
     names.  Groups like `mail.misc' will end up in directories
     (assuming use of `nnml' back end) or files (assuming use of
     `nnfolder' back end) like `mail.misc'.  If it is `nil', the same
     group will end up in `mail/misc'.

`nnmail-delete-file-function'
     Function called to delete files.  It is `delete-file' by default.

`nnmail-cache-accepted-message-ids'
     If non-`nil', put the `Message-ID's of articles imported into the
     back end (via `Gcc', for instance) into the mail duplication
     discovery cache.  The default is `nil'.

`nnmail-cache-ignore-groups'
     This can be a regular expression or a list of regular
     expressions.  Group names that match any of the regular
     expressions will never be recorded in the `Message-ID' cache.

     This can be useful, for example, when using Fancy Splitting
     (*Note Fancy Mail Splitting::) together with the function
     `nnmail-split-fancy-with-parent'.





File: gnus, Node: Fancy Mail Splitting, Next: Group Mail Splitting, Prev: Mail Back End Variables, Up: Getting Mail

Fancy Mail Splitting
--------------------

If the rather simple, standard method for specifying how to split mail
doesn't allow you to do what you want, you can set
`nnmail-split-methods' to `nnmail-split-fancy'.  Then you can play
with the `nnmail-split-fancy' variable.

Let's look at an example value of this variable first:

     ;; Messages from the mailer daemon are not crossposted to any of
     ;; the ordinary groups.  Warnings are put in a separate group
     ;; from real errors.
     (| ("from" mail (| ("subject" "warn.*" "mail.warning")
                        "mail.misc"))
        ;; Non-error messages are crossposted to all relevant
        ;; groups, but we don't crosspost between the group for the
        ;; (ding) list and the group for other (ding) related mail.
        (& (| (any "ding@ifi\\.uio\\.no" "ding.list")
              ("subject" "ding" "ding.misc"))
           ;; Other mailing lists...
           (any "procmail@informatik\\.rwth-aachen\\.de" "procmail.list")
           (any "SmartList@informatik\\.rwth-aachen\\.de" "SmartList.list")
           ;; Both lists below have the same suffix, so prevent
           ;; cross-posting to mkpkg.list of messages posted only to
           ;; the bugs- list, but allow cross-posting when the
           ;; message was really cross-posted.
           (any "bugs-mypackage@somewhere" "mypkg.bugs")
           (any "mypackage@somewhere" - "bugs-mypackage" "mypkg.list")
           ;; People...
           (any "larsi@ifi\\.uio\\.no" "people.Lars_Magne_Ingebrigtsen"))
        ;; Unmatched mail goes to the catch all group.
        "misc.misc")

This variable has the format of a "split".  A split is a (possibly)
recursive structure where each split may contain other splits.  Here
are the possible split syntaxes:


`group'
     If the split is a string, that will be taken as a group name.
     Normal regexp match expansion will be done.  See below for
     examples.

`(FIELD VALUE [- RESTRICT [...] ] SPLIT [INVERT-PARTIAL])'
     The split can be a list containing at least three elements.  If the
     first element FIELD (a regexp matching a header) contains
     VALUE (also a regexp) then store the message as specified by
     SPLIT.

     If RESTRICT (yet another regexp) matches some string after
     FIELD and before the end of the matched VALUE, the
     SPLIT is ignored.  If none of the RESTRICT clauses match,
     SPLIT is processed.

     The last element INVERT-PARTIAL is optional.  If it is non-`nil',
     the match-partial-words behavior controlled by the variable
     `nnmail-split-fancy-match-partial-words' (see below) is be
     inverted.  (New in Gnus 5.10.7)

`(| SPLIT ...)'
     If the split is a list, and the first element is `|' (vertical
     bar), then process each SPLIT until one of them matches.  A SPLIT
     is said to match if it will cause the mail message to be stored
     in one or more groups.

`(& SPLIT ...)'
     If the split is a list, and the first element is `&', then
     process all SPLITs in the list.

`junk'
     If the split is the symbol `junk', then don't save (i.e., delete)
     this message.  Use with extreme caution.

`(: FUNCTION ARG1 ARG2 ...)'
     If the split is a list, and the first element is `:', then the
     second element will be called as a function with ARGS given as
     arguments.  The function should return a SPLIT.

     For instance, the following function could be used to split based
     on the body of the messages:

          (defun split-on-body ()
            (save-excursion
              (save-restriction
                (widen)
                (goto-char (point-min))
                (when (re-search-forward "Some.*string" nil t)
                  "string.group"))))

     The buffer is narrowed to the header of the message in question
     when FUNCTION is run.  That's why `(widen)' needs to be called
     after `save-excursion' and `save-restriction' in the example
     above.  Also note that with the nnimap backend, message bodies
     will not be downloaded by default.  You need to set
     `nnimap-split-download-body' to `t' to do that (*Note Splitting
     in IMAP::).

`(! FUNC SPLIT)'
     If the split is a list, and the first element is `!', then SPLIT
     will be processed, and FUNC will be called as a function with the
     result of SPLIT as argument.  FUNC should return a split.

`nil'
     If the split is `nil', it is ignored.


In these splits, FIELD must match a complete field name.

Normally, VALUE in these splits must match a complete *word* according
to the fundamental mode syntax table.  In other words, all VALUE's
will be implicitly surrounded by `\<...\>' markers, which are word
delimiters.  Therefore, if you use the following split, for example,

     (any "joe" "joemail")

messages sent from `joedavis@foo.org' will normally not be filed in
`joemail'.  If you want to alter this behavior, you can use any of the
following three ways:

  1. You can set the `nnmail-split-fancy-match-partial-words' variable
     to non-`nil' in order to ignore word boundaries and instead the
     match becomes more like a grep.  This variable controls whether partial
     words are matched during fancy splitting.  The default value is
     `nil'.

     Note that it influences all VALUE's in your split rules.

  2. VALUE beginning with `.*' ignores word boundaries in front of
     a word.  Similarly, if VALUE ends with `.*', word boundaries
     in the rear of a word will be ignored.  For example, the VALUE
     `"@example\\.com"' does not match `foo@example.com' but
     `".*@example\\.com"' does.

  3. You can set the INVERT-PARTIAL flag in your split rules of the
     `(FIELD VALUE ...)' types, aforementioned in this section.  If
     the flag is set, word boundaries on both sides of a word are
     ignored even if `nnmail-split-fancy-match-partial-words' is
     `nil'.  Contrarily, if the flag is set, word boundaries are not
     ignored even if `nnmail-split-fancy-match-partial-words' is
     non-`nil'.  (New in Gnus 5.10.7)

FIELD and VALUE can also be Lisp symbols, in that case
they are expanded as specified by the variable
`nnmail-split-abbrev-alist'.  This is an alist of cons cells,
where the CAR of a cell contains the key, and the CDR
contains the associated value.  Predefined entries in
`nnmail-split-abbrev-alist' include:

`from'
     Matches the `From', `Sender' and `Resent-From' fields.
`to'
     Matches the `To', `Cc', `Apparently-To',
     `Resent-To' and `Resent-Cc' fields.
`any'
     Is the union of the `from' and `to' entries.

`nnmail-split-fancy-syntax-table' is the syntax table in effect when
all this splitting is performed.

If you want to have Gnus create groups dynamically based on some
information in the headers (i.e., do `replace-match'-like
substitutions in the group names), you can say things like:

     (any "debian-\\b\\(\\w+\\)@lists.debian.org" "mail.debian.\\1")

In this example, messages sent to `debian-foo@lists.debian.org' will
be filed in `mail.debian.foo'.

If the string contains the element `\&', then the previously matched
string will be substituted.  Similarly, the elements `\\1' up to `\\9'
will be substituted with the text matched by the groupings 1 through
9.

Where `nnmail-split-lowercase-expanded' controls whether the lowercase
of the matched string should be used for the substitution.  Setting it
as non-`nil' is useful to avoid the creation of multiple groups when
users send to an address using different case
(i.e. mailing-list@domain vs Mailing-List@Domain).  The default value
is `t'.

`nnmail-split-fancy-with-parent' is a function which allows you to
split followups into the same groups their parents are in.  Sometimes
you can't make splitting rules for all your mail.  For example, your
boss might send you personal mail regarding different projects you are
working on, and as you can't tell your boss to put a distinguishing
string into the subject line, you have to resort to manually moving
the messages into the right group.  With this function, you only have
to do it once per thread.

To use this feature, you have to set `nnmail-treat-duplicates' and
`nnmail-cache-accepted-message-ids' to a non-`nil' value.  And then
you can include `nnmail-split-fancy-with-parent' using the colon
feature, like so:
     (setq nnmail-treat-duplicates 'warn     ; or `delete'
           nnmail-cache-accepted-message-ids t
           nnmail-split-fancy
           '(| (: nnmail-split-fancy-with-parent)
               ;; other splits go here
             ))

This feature works as follows: when `nnmail-treat-duplicates' is
non-`nil', Gnus records the message id of every message it sees in the
file specified by the variable `nnmail-message-id-cache-file',
together with the group it is in (the group is omitted for non-mail
messages).  When mail splitting is invoked, the function
`nnmail-split-fancy-with-parent' then looks at the References (and
In-Reply-To) header of each message to split and searches the file
specified by `nnmail-message-id-cache-file' for the message ids.  When
it has found a parent, it returns the corresponding group name unless
the group name matches the regexp
`nnmail-split-fancy-with-parent-ignore-groups'.  It is recommended
that you set `nnmail-message-id-cache-length' to a somewhat higher
number than the default so that the message ids are still in the
cache.  (A value of 5000 appears to create a file some 300 kBytes in
size.)  When `nnmail-cache-accepted-message-ids' is non-`nil', Gnus
also records the message ids of moved articles, so that the followup
messages goes into the new group.

Also see the variable `nnmail-cache-ignore-groups' if you don't want
certain groups to be recorded in the cache.  For example, if all
outgoing messages are written to an "outgoing" group, you could set
`nnmail-cache-ignore-groups' to match that group name.  Otherwise,
answers to all your messages would end up in the "outgoing" group.




File: gnus, Node: Group Mail Splitting, Next: Incorporating Old Mail, Prev: Fancy Mail Splitting, Up: Getting Mail

Group Mail Splitting
--------------------

If you subscribe to dozens of mailing lists but you don't want to
maintain mail splitting rules manually, group mail splitting is for you.
You just have to set `to-list' and/or `to-address' in group
parameters or group customization and set `nnmail-split-methods' to
`gnus-group-split'.  This splitting function will scan all groups
for those parameters and split mail accordingly, i.e., messages posted
from or to the addresses specified in the parameters `to-list' or
`to-address' of a mail group will be stored in that group.

Sometimes, mailing lists have multiple addresses, and you may want
mail splitting to recognize them all: just set the `extra-aliases'
group parameter to the list of additional addresses and it's done.  If
you'd rather use a regular expression, set `split-regexp'.

All these parameters in a group will be used to create an
`nnmail-split-fancy' split, in which the FIELD is `any',
the VALUE is a single regular expression that matches
`to-list', `to-address', all of `extra-aliases' and all
matches of `split-regexp', and the SPLIT is the name of the
group.  RESTRICTs are also supported: just set the
`split-exclude' parameter to a list of regular expressions.

If you can't get the right split to be generated using all these
parameters, or you just need something fancier, you can set the
parameter `split-spec' to an `nnmail-split-fancy' split.  In
this case, all other aforementioned parameters will be ignored by
`gnus-group-split'.  In particular, `split-spec' may be set to
`nil', in which case the group will be ignored by
`gnus-group-split'.

`gnus-group-split' will do cross-posting on all groups that match, by
defining a single `&' fancy split containing one split for each group.
If a message doesn't match any split, it will be stored in the group
named in `gnus-group-split-default-catch-all-group', unless some group
has `split-spec' set to `catch-all', in which case that group is used
as the catch-all group.  Even though this variable is often used just
to name a group, it may also be set to an arbitrarily complex fancy
split (after all, a group name is a fancy split), and this may be
useful to split mail that doesn't go to any mailing list to personal
mail folders.  Note that this fancy split is added as the last element
of a `|' split list that also contains a `&' split with the rules
extracted from group parameters.

It's time for an example.  Assume the following group parameters have
been defined:

     nnml:mail.bar:
     ((to-address . "bar@femail.com")
      (split-regexp . ".*@femail\\.com"))
     nnml:mail.foo:
     ((to-list . "foo@nowhere.gov")
      (extra-aliases "foo@localhost" "foo-redist@home")
      (split-exclude "bugs-foo" "rambling-foo")
      (admin-address . "foo-request@nowhere.gov"))
     nnml:mail.others:
     ((split-spec . catch-all))

Setting `nnmail-split-methods' to `gnus-group-split' will
behave as if `nnmail-split-fancy' had been selected and variable
`nnmail-split-fancy' had been set as follows:

     (| (& (any "\\(bar@femail\\.com\\|.*@femail\\.com\\)" "mail.bar")
           (any "\\(foo@nowhere\\.gov\\|foo@localhost\\|foo-redist@home\\)"
                - "bugs-foo" - "rambling-foo" "mail.foo"))
        "mail.others")

If you'd rather not use group splitting for all your mail groups, you
may use it for only some of them, by using `nnmail-split-fancy' splits
like this:

     (: gnus-group-split-fancy GROUPS NO-CROSSPOST CATCH-ALL)

GROUPS may be a regular expression or a list of group names whose
parameters will be scanned to generate the output split.  NO-CROSSPOST
can be used to disable cross-posting; in this case, a single `|' split
will be output.  CATCH-ALL is the fall back fancy split, used like
`gnus-group-split-default-catch-all-group'.  If CATCH-ALL is `nil', or
if `split-regexp' matches the empty string in any selected group, no
catch-all split will be issued.  Otherwise, if some group has
`split-spec' set to `catch-all', this group will override the value of
the CATCH-ALL argument.

Unfortunately, scanning all groups and their parameters can be quite
slow, especially considering that it has to be done for every message.
But don't despair!  The function `gnus-group-split-setup' can be used
to enable `gnus-group-split' in a much more efficient way.  It sets
`nnmail-split-methods' to `nnmail-split-fancy' and sets
`nnmail-split-fancy' to the split produced by
`gnus-group-split-fancy'.  Thus, the group parameters are only scanned
once, no matter how many messages are split.

However, if you change group parameters, you'd have to update
`nnmail-split-fancy' manually.  You can do it by running
`gnus-group-split-update'.  If you'd rather have it updated
automatically, just tell `gnus-group-split-setup' to do it for you.
For example, add to your `~/.gnus.el':

     (gnus-group-split-setup AUTO-UPDATE CATCH-ALL)

If AUTO-UPDATE is non-`nil', `gnus-group-split-update' will be added
to `nnmail-pre-get-new-mail-hook', so you won't ever have to worry
about updating `nnmail-split-fancy' again.  If you don't omit
CATCH-ALL (it's optional, equivalent to `nil'),
`gnus-group-split-default-catch-all-group' will be set to its value.

Because you may want to change `nnmail-split-fancy' after it is set
by `gnus-group-split-update', this function will run
`gnus-group-split-updated-hook' just before finishing.



