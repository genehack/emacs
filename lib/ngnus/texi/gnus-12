Info file: gnus,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License" in the Emacs manual.

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding
     a copy of the license to the document, as described in section 6
     of the license.



INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus: (gnus).         The newsreader Gnus.
END-INFO-DIR-ENTRY








File: gnus, Node: Document Server Internals, Prev: Document Groups, Up: Document Groups

Document Server Internals
.........................

Adding new document types to be recognized by `nndoc' isn't difficult.
You just have to whip up a definition of what the document looks like,
write a predicate function to recognize that document type, and then
hook into `nndoc'.

First, here's an example document type definition:

     (mmdf
      (article-begin .  "^\^A\^A\^A\^A\n")
      (body-end .  "^\^A\^A\^A\^A\n"))

The definition is simply a unique "name" followed by a series of
regexp pseudo-variable settings.  Below are the possible
variables--don't be daunted by the number of variables; most document
types can be defined with very few settings:

`first-article'
     If present, `nndoc' will skip past all text until it finds
     something that match this regexp.  All text before this will be
     totally ignored.

`article-begin'
     This setting has to be present in all document type definitions.
     It says what the beginning of each article looks like.  To do
     more complicated things that cannot be dealt with a simple
     regexp, you can use `article-begin-function' instead of this.

`article-begin-function'
     If present, this should be a function that moves point to the
     beginning of each article.  This setting overrides
     `article-begin'.

`head-begin'
     If present, this should be a regexp that matches the head of the
     article.  To do more complicated things that cannot be dealt with
     a simple regexp, you can use `head-begin-function' instead of
     this.

`head-begin-function'
     If present, this should be a function that moves point to the
     head of the article.  This setting overrides `head-begin'.

`head-end'
     This should match the end of the head of the article.  It defaults to
     `^$'---the empty line.

`body-begin'
     This should match the beginning of the body of the article.  It
     defaults to `^\n'.  To do more complicated things that cannot be
     dealt with a simple regexp, you can use `body-begin-function'
     instead of this.

`body-begin-function'
     If present, this function should move point to the beginning of
     the body of the article.  This setting overrides `body-begin'.

`body-end'
     If present, this should match the end of the body of the article.
     To do more complicated things that cannot be dealt with a simple
     regexp, you can use `body-end-function' instead of this.

`body-end-function'
     If present, this function should move point to the end of the
     body of the article.  This setting overrides `body-end'.

`file-begin'
     If present, this should match the beginning of the file.  All
     text before this regexp will be totally ignored.

`file-end'
     If present, this should match the end of the file.  All text
     after this regexp will be totally ignored.


So, using these variables `nndoc' is able to dissect a document file
into a series of articles, each with a head and a body.  However, a
few more variables are needed since not all document types are all
that news-like--variables needed to transform the head or the body
into something that's palatable for Gnus:

`prepare-body-function'
     If present, this function will be called when requesting an
     article.  It will be called with point at the start of the body,
     and is useful if the document has encoded some parts of its
     contents.

`article-transform-function'
     If present, this function is called when requesting an article.
     It's meant to be used for more wide-ranging transformation of
     both head and body of the article.

`generate-head-function'
     If present, this function is called to generate a head that Gnus
     can understand.  It is called with the article number as a
     parameter, and is expected to generate a nice head for the
     article in question.  It is called when requesting the headers of
     all articles.

`generate-article-function'
     If present, this function is called to generate an entire article
     that Gnus can understand.  It is called with the article number
     as a parameter when requesting all articles.

`dissection-function'
     If present, this function is called to dissect a document by itself,
     overriding `first-article', `article-begin',
     `article-begin-function', `head-begin',
     `head-begin-function', `head-end', `body-begin',
     `body-begin-function', `body-end', `body-end-function',
     `file-begin', and `file-end'.


Let's look at the most complicated example I can come up
with--standard digests:

     (standard-digest
      (first-article . ,(concat "^" (make-string 70 ?-) "\n\n+"))
      (article-begin . ,(concat "\n\n" (make-string 30 ?-) "\n\n+"))
      (prepare-body-function . nndoc-unquote-dashes)
      (body-end-function . nndoc-digest-body-end)
      (head-end . "^ ?$")
      (body-begin . "^ ?\n")
      (file-end . "^End of .*digest.*[0-9].*\n\\*\\*\\|^End of.*Digest *$")
      (subtype digest guess))

We see that all text before a 70-width line of dashes is ignored; all
text after a line that starts with that `^End of' is also ignored;
each article begins with a 30-width line of dashes; the line
separating the head from the body may contain a single space; and that
the body is run through `nndoc-unquote-dashes' before being delivered.

To hook your own document definition into `nndoc', use the
`nndoc-add-type' function.  It takes two parameters--the first is the
definition itself and the second (optional) parameter says where in
the document type definition alist to put this definition.  The alist
is traversed sequentially, and `nndoc-TYPE-type-p' is called for a
given type TYPE.  So `nndoc-mmdf-type-p' is called to see whether a
document is of `mmdf' type, and so on.  These type predicates should
return `nil' if the document is not of the correct type; `t' if it is
of the correct type; and a number if the document might be of the
correct type.  A high number means high probability; a low number
means low probability with `0' being the lowest valid number.




File: gnus, Node: SOUP, Next: Mail-To-News Gateways, Prev: Document Groups, Up: Other Sources

SOUP
----

In the PC world people often talk about "offline" newsreaders.  These
are thingies that are combined reader/news transport monstrosities.
With built-in modem programs.  Yecchh!

Of course, us Unix Weenie types of human beans use things like `uucp'
and, like, `nntpd' and set up proper news and mail transport things
like Ghod intended.  And then we just use normal newsreaders.

However, it can sometimes be convenient to do something that's a bit
easier on the brain if you have a very slow modem, and you're not
really that interested in doing things properly.

A file format called SOUP has been developed for transporting news and
mail from servers to home machines and back again.  It can be a bit
fiddly.

First some terminology:


"server"
     This is the machine that is connected to the outside world and
     where you get news and/or mail from.

"home machine"
     This is the machine that you want to do the actual reading and
     responding on.  It is typically not connected to the rest of the
     world in any way.

"packet"
     Something that contains messages and/or commands.  There are two
     kinds of packets:

     "message packets"
          These are packets made at the server, and typically contain
          lots of messages for you to read.  These are called
          `SoupoutX.tgz' by default, where X is a number.

     "response packets"
          These are packets made at the home machine, and typically
          contains replies that you've written.  These are called
          `SoupinX.tgz' by default, where X is a number.





  1. You log in on the server and create a SOUP packet.  You can
     either use a dedicated SOUP thingie (like the `awk' program), or
     you can use Gnus to create the packet with its SOUP commands (`O
     s' and/or `G s b'; and then `G s p') (*Note SOUP Commands::).

  2. You transfer the packet home.  Rail, boat, car or modem will do
     fine.

  3. You put the packet in your home directory.

  4. You fire up Gnus on your home machine using the `nnsoup' back end
     as the native or secondary server.

  5. You read articles and mail and answer and followup to the things
     you want (*Note SOUP Replies::).

  6. You do the `G s r' command to pack these replies into a SOUP
     packet.

  7. You transfer this packet to the server.

  8. You use Gnus to mail this packet out with the `G s s' command.

  9. You then repeat until you die.


So you basically have a bipartite system--you use `nnsoup' for reading
and Gnus for packing/sending these SOUP packets.

* Menu:

* SOUP Commands::               Commands for creating and sending SOUP packets
* SOUP Groups::                 A back end for reading SOUP packets.
* SOUP Replies::                How to enable `nnsoup' to take over mail and news.




File: gnus, Node: SOUP Commands, Next: SOUP Groups, Prev: SOUP, Up: SOUP

SOUP Commands
.............

These are commands for creating and manipulating SOUP packets.

`G s b'
     Pack all unread articles in the current group
     (`gnus-group-brew-soup').  This command understands the
     process/prefix convention.

`G s w'
     Save all SOUP data files (`gnus-soup-save-areas').

`G s s'
     Send all replies from the replies packet
     (`gnus-soup-send-replies').

`G s p'
     Pack all files into a SOUP packet (`gnus-soup-pack-packet').

`G s r'
     Pack all replies into a replies packet (`nnsoup-pack-replies').

`O s'
     This summary-mode command adds the current article to a SOUP
     packet (`gnus-soup-add-article').  It understands the
     process/prefix convention (*Note Process/Prefix::).



There are a few variables to customize where Gnus will put all these
thingies:


`gnus-soup-directory'
     Directory where Gnus will save intermediate files while composing
     SOUP packets.  The default is `~/SoupBrew/'.

`gnus-soup-replies-directory'
     This is what Gnus will use as a temporary directory while sending
     our reply packets.  `~/SoupBrew/SoupReplies/' is the default.

`gnus-soup-prefix-file'
     Name of the file where Gnus stores the last used prefix.  The default is
     `gnus-prefix'.

`gnus-soup-packer'
     A format string command for packing a SOUP packet.  The default is
     `tar cf - %s | gzip > $HOME/Soupout%d.tgz'.

`gnus-soup-unpacker'
     Format string command for unpacking a SOUP packet.  The default is
     `gunzip -c %s | tar xvf -'.

`gnus-soup-packet-directory'
     Where Gnus will look for reply packets.  The default is `~/'.

`gnus-soup-packet-regexp'
     Regular expression matching SOUP reply packets in
     `gnus-soup-packet-directory'.





File: gnus, Node: SOUP Groups, Next: SOUP Replies, Prev: SOUP Commands, Up: SOUP

SOUP Groups
...........

`nnsoup' is the back end for reading SOUP packets.  It will read
incoming packets, unpack them, and put them in a directory where you
can read them at leisure.

These are the variables you can use to customize its behavior:


`nnsoup-tmp-directory'
     When `nnsoup' unpacks a SOUP packet, it does it in this
     directory.  (`/tmp/' by default.)

`nnsoup-directory'
     `nnsoup' then moves each message and index file to this
     directory.  The default is `~/SOUP/'.

`nnsoup-replies-directory'
     All replies will be stored in this directory before being packed
     into a reply packet.  The default is `~/SOUP/replies/'.

`nnsoup-replies-format-type'
     The SOUP format of the replies packets.  The default is `?n'
     (rnews), and I don't think you should touch that variable.  I
     probably shouldn't even have documented it.  Drats!  Too late!

`nnsoup-replies-index-type'
     The index type of the replies packet.  The default is `?n', which
     means "none".  Don't fiddle with this one either!

`nnsoup-active-file'
     Where `nnsoup' stores lots of information.  This is not an "active
     file" in the `nntp' sense; it's an Emacs Lisp file.  If you lose
     this file or mess it up in any way, you're dead.  The default is
     `~/SOUP/active'.

`nnsoup-packer'
     Format string command for packing a reply SOUP packet.  The
     default is `tar cf - %s | gzip > $HOME/Soupin%d.tgz'.

`nnsoup-unpacker'
     Format string command for unpacking incoming SOUP packets.  The
     default is `gunzip -c %s | tar xvf -'.

`nnsoup-packet-directory'
     Where `nnsoup' will look for incoming packets.  The default is
     `~/'.

`nnsoup-packet-regexp'
     Regular expression matching incoming SOUP packets.  The default is
     `Soupout'.

`nnsoup-always-save'
     If non-`nil', save the replies buffer after each posted message.





File: gnus, Node: SOUP Replies, Prev: SOUP Groups, Up: SOUP

SOUP Replies
............

Just using `nnsoup' won't mean that your postings and mailings end up
in SOUP reply packets automagically.  You have to work a bit more for
that to happen.

The `nnsoup-set-variables' command will set the appropriate
variables to ensure that all your followups and replies end up in the
SOUP system.

In specific, this is what it does:

     (setq message-send-news-function 'nnsoup-request-post)
     (setq message-send-mail-function 'nnsoup-request-mail)

And that's it, really.  If you only want news to go into the SOUP
system you just use the first line.  If you only want mail to be
SOUPed you use the second.




File: gnus, Node: Mail-To-News Gateways, Prev: SOUP, Up: Other Sources

Mail-To-News Gateways
---------------------

If your local `nntp' server doesn't allow posting, for some reason or
other, you can post using one of the numerous mail-to-news gateways.
The `nngateway' back end provides the interface.

Note that you can't read anything from this back end--it can only be
used to post with.

Server variables:

`nngateway-address'
     This is the address of the mail-to-news gateway.

`nngateway-header-transformation'
     News headers often have to be transformed in some odd way or
     other for the mail-to-news gateway to accept it.  This variable
     says what transformation should be called, and defaults to
     `nngateway-simple-header-transformation'.  The function is called
     narrowed to the headers to be transformed and with one
     parameter--the gateway address.

     This default function just inserts a new `To' header based on the
     `Newsgroups' header and the gateway address.  For instance, an
     article with this `Newsgroups' header:

          Newsgroups: alt.religion.emacs

     will get this `To' header inserted:

          To: alt-religion-emacs@GATEWAY

     The following pre-defined functions exist:


     `nngateway-simple-header-transformation'
          Creates a `To' header that looks like
          NEWSGROUP@`nngateway-address'.


     `nngateway-mail2news-header-transformation'
          Creates a `To' header that looks like
          `nngateway-address'.


Here's an example:

     (setq gnus-post-method
           '(nngateway
             "mail2news@replay.com"
             (nngateway-header-transformation
              nngateway-mail2news-header-transformation)))

So, to use this, simply say something like:

     (setq gnus-post-method '(nngateway "GATEWAY.ADDRESS"))





File: gnus, Node: Combined Groups, Next: Email Based Diary, Prev: Other Sources, Up: Select Methods

Combined Groups
===============

Gnus allows combining a mixture of all the other group types into
bigger groups.

* Menu:

* Virtual Groups::              Combining articles from many groups.
* Kibozed Groups::              Looking through parts of the newsfeed for articles.




File: gnus, Node: Virtual Groups, Next: Kibozed Groups, Prev: Combined Groups, Up: Combined Groups

Virtual Groups
--------------

An "nnvirtual group" is really nothing more than a collection of other
groups.

For instance, if you are tired of reading many small groups, you can
put them all in one big group, and then grow tired of reading one big,
unwieldy group.  The joys of computing!

You specify `nnvirtual' as the method.  The address should be a regexp
to match component groups.

All marks in the virtual group will stick to the articles in the
component groups.  So if you tick an article in a virtual group, the
article will also be ticked in the component group from whence it
came.  (And vice versa--marks from the component groups will also be
shown in the virtual group.).  To create an empty virtual group, run
`G V' (`gnus-group-make-empty-virtual') in the group buffer and edit
the method regexp with `M-e' (`gnus-group-edit-group-method')

Here's an example `nnvirtual' method that collects all Andrea Dworkin
newsgroups into one, big, happy newsgroup:

     (nnvirtual "^alt\\.fan\\.andrea-dworkin$\\|^rec\\.dworkin.*")

The component groups can be native or foreign; everything should work
smoothly, but if your computer explodes, it was probably my fault.

Collecting the same group from several servers might actually be a
good idea if users have set the Distribution header to limit
distribution.  If you would like to read `soc.motss' both from a
server in Japan and a server in Norway, you could use the following as
the group regexp:

     "^nntp\\+server\\.jp:soc\\.motss$\\|^nntp\\+server\\.no:soc\\.motss$"

(Remember, though, that if you're creating the group with `G m', you
shouldn't double the backslashes, and you should leave off the quote
characters at the beginning and the end of the string.)

This should work kinda smoothly--all articles from both groups should
end up in this one, and there should be no duplicates.  Threading (and
the rest) will still work as usual, but there might be problems with
the sequence of articles.  Sorting on date might be an option here
(*Note Selecting a Group::).

One limitation, however--all groups included in a virtual group have
to be alive (i.e., subscribed or unsubscribed).  Killed or zombie
groups can't be component groups for `nnvirtual' groups.

If the `nnvirtual-always-rescan' variable is non-`nil' (which is the
default), `nnvirtual' will always scan groups for unread articles when
entering a virtual group.  If this variable is `nil' and you read
articles in a component group after the virtual group has been
activated, the read articles from the component group will show up
when you enter the virtual group.  You'll also see this effect if you
have two virtual groups that have a component group in common.  If
that's the case, you should set this variable to `t'.  Or you can just
tap `M-g' on the virtual group every time before you enter it--it'll
have much the same effect.

`nnvirtual' can have both mail and news groups as component groups.
When responding to articles in `nnvirtual' groups, `nnvirtual' has to
ask the back end of the component group the article comes from whether
it is a news or mail back end.  However, when you do a `^', there is
typically no sure way for the component back end to know this, and in
that case `nnvirtual' tells Gnus that the article came from a not-news
back end.  (Just to be on the safe side.)

`C-c C-n' in the message buffer will insert the `Newsgroups' line from
the article you respond to in these cases.

`nnvirtual' groups do not inherit anything but articles and marks from
component groups--group parameters, for instance, are not inherited.




File: gnus, Node: Kibozed Groups, Prev: Virtual Groups, Up: Combined Groups

Kibozed Groups
--------------

"Kibozing" is defined by the OED as "grepping through (parts of) the
news feed".  `nnkiboze' is a back end that will do this for you.  Oh
joy!  Now you can grind any NNTP server down to a halt with useless
requests!  Oh happiness!

To create a kibozed group, use the `G k' command in the group buffer.

The address field of the `nnkiboze' method is, as with
`nnvirtual', a regexp to match groups to be "included" in the
`nnkiboze' group.  That's where most similarities between
`nnkiboze' and `nnvirtual' end.

In addition to this regexp detailing component groups, an `nnkiboze'
group must have a score file to say what articles are to be included
in the group (*Note Scoring::).

You must run `M-x nnkiboze-generate-groups' after creating the
`nnkiboze' groups you want to have.  This command will take time.
Lots of time.  Oodles and oodles of time.  Gnus has to fetch the
headers from all the articles in all the component groups and run them
through the scoring process to determine if there are any articles in
the groups that are to be part of the `nnkiboze' groups.

Please limit the number of component groups by using restrictive
regexps.  Otherwise your sysadmin may become annoyed with you, and the
NNTP site may throw you off and never let you back in again.  Stranger
things have happened.

`nnkiboze' component groups do not have to be alive--they can be dead,
and they can be foreign.  No restrictions.

The generation of an `nnkiboze' group means writing two files in
`nnkiboze-directory', which is `~/News/kiboze/' by default.  One
contains the NOV header lines for all the articles in the group, and
the other is an additional `.newsrc' file to store information on what
groups have been searched through to find component articles.

Articles marked as read in the `nnkiboze' group will have their NOV
lines removed from the NOV file.




File: gnus, Node: Email Based Diary, Next: Gnus Unplugged, Prev: Combined Groups, Up: Select Methods

Email Based Diary
=================

This section describes a special mail back end called `nndiary', and
its companion library `gnus-diary'.  It is "special" in the sense that
it is not meant to be one of the standard alternatives for reading
mail with Gnus.  See *Note Choosing a Mail Back End:: for that.
Instead, it is used to treat *some* of your mails in a special way,
namely, as event reminders.

Here is a typical scenario:

   * You've got a date with Andy Mc Dowell or Bruce Willis (select
     according to your sexual preference) in one month.  You don't
     want to forget it.
   * So you send a "reminder" message (actually, a diary one) to
     yourself.
   * You forget all about it and keep on getting and reading new mail,
     as usual.
   * From time to time, as you type `g' in the group buffer and as the
     date is getting closer, the message will pop up again to remind
     you of your appointment, just as if it were new and unread.
   * Read your "new" messages, this one included, and start dreaming
     again of the night you're gonna have.
   * Once the date is over (you actually fell asleep just after
     dinner), the message will be automatically deleted if it is
     marked as expirable.

The Gnus Diary back end has the ability to handle regular appointments
(that wouldn't ever be deleted) as well as punctual ones, operates as
a real mail back end and is configurable in many ways.  All of this is
explained in the sections below.

* Menu:

* The NNDiary Back End::        Basic setup and usage.
* The Gnus Diary Library::      Utility toolkit on top of nndiary.
* Sending or Not Sending::      A final note on sending diary messages.




File: gnus, Node: The NNDiary Back End, Next: The Gnus Diary Library, Prev: Email Based Diary, Up: Email Based Diary

The NNDiary Back End
--------------------

`nndiary' is a back end very similar to `nnml' (*Note Mail Spool::).
Actually, it could appear as a mix of `nnml' and `nndraft'.  If you
know `nnml', you're already familiar with the message storing scheme
of `nndiary': one file per message, one directory per group.

  Before anything, there is one requirement to be able to run
`nndiary' properly: you *must* use the group timestamp feature of
Gnus.  This adds a timestamp to each group's parameters.  *Note Group
Timestamp:: to see how it's done.

* Menu:

* Diary Messages::              What makes a message valid for nndiary.
* Running NNDiary::             NNDiary has two modes of operation.
* Customizing NNDiary::         Bells and whistles.



File: gnus, Node: Diary Messages, Next: Running NNDiary, Prev: The NNDiary Back End, Up: The NNDiary Back End

Diary Messages
..............

`nndiary' messages are just normal ones, except for the mandatory
presence of 7 special headers.  These headers are of the form
`X-Diary-<something>', `<something>' being one of `Minute', `Hour',
`Dom', `Month', `Year', `Time-Zone' and `Dow'.  `Dom' means "Day of
Month", and `dow' means "Day of Week".  These headers actually behave
like crontab specifications and define the event date(s):

   * For all headers except the `Time-Zone' one, a header value is
     either a star (meaning all possible values), or a list of fields
     (separated by a comma).
   * A field is either an integer, or a range.
   * A range is two integers separated by a dash.
   * Possible integer values are 0--59 for `Minute', 0--23 for `Hour',
     1--31 for `Dom', 1--12 for `Month', above 1971 for `Year' and
     0--6 for `Dow' (0 meaning Sunday).
   * As a special case, a star in either `Dom' or `Dow' doesn't mean
     all possible values", but "use only the other field".  Note that
     if both are star'ed, the use of either one gives the same result.
   * The `Time-Zone' header is special in that it can only have one
     value (`GMT', for instance).  A star doesn't mean "all possible
     values" (because it makes no sense), but "the current local time
     zone".  Most of the time, you'll be using a star here.  However, for a
     list of available time zone values, see the variable
     `nndiary-headers'.

As a concrete example, here are the diary headers to add to your
message for specifying "Each Monday and each 1st of month, at 12:00,
20:00, 21:00, 22:00, 23:00 and 24:00, from 1999 to 2010" (I'll let you
find what to do then):

     X-Diary-Minute: 0
     X-Diary-Hour: 12, 20-24
     X-Diary-Dom: 1
     X-Diary-Month: *
     X-Diary-Year: 1999-2010
     X-Diary-Dow: 1
     X-Diary-Time-Zone: *



File: gnus, Node: Running NNDiary, Next: Customizing NNDiary, Prev: Diary Messages, Up: The NNDiary Back End

Running NNDiary
...............

`nndiary' has two modes of operation: "traditional" (the default) and
autonomous".  In traditional mode, `nndiary' does not get new mail by
itself.  You have to move (`B m') or copy (`B c') mails from your
primary mail back end to nndiary groups in order to handle them as
diary messages.  In autonomous mode, `nndiary' retrieves its own mail
and handles it independently from your primary mail back end.

One should note that Gnus is not inherently designed to allow several
master" mail back ends at the same time.  However, this does make
sense with `nndiary': you really want to send and receive diary
messages to your diary groups directly.  So, `nndiary' supports being
sort of a "second primary mail back end" (to my knowledge, it is the
only back end offering this feature).  However, there is a limitation
(which I hope to fix some day): respooling doesn't work in autonomous
mode.

In order to use `nndiary' in autonomous mode, you have several things
to do:

   * Allow `nndiary' to retrieve new mail by itself.  Put the
     following line in your `~/.gnus.el' file:

          (setq nndiary-get-new-mail t)
   * You must arrange for diary messages (those containing `X-Diary-*'
     headers) to be split in a private folder *before* Gnus treat
     them.  Again, this is needed because Gnus cannot (yet ?) properly
     handle multiple primary mail back ends.  Getting those messages
     from a separate source will compensate this misfeature to some
     extent.

     As an example, here's my procmailrc entry to store diary files in
     `~/.nndiary' (the default `nndiary' mail source file):

          :0 HD :
          * ^X-Diary
          .nndiary

Once this is done, you might want to customize the following two
options that affect the diary mail retrieval and splitting processes:

 -- Variable: nndiary-mail-sources
     This is the diary-specific replacement for the standard
     `mail-sources' variable.  It obeys the same syntax, and defaults to
     `(file :path "~/.nndiary")'.

 -- Variable: nndiary-split-methods
     This is the diary-specific replacement for the standard
     `nnmail-split-methods' variable.  It obeys the same syntax.

  Finally, you may add a permanent `nndiary' virtual server
(something like `(nndiary "diary")' should do) to your
`gnus-secondary-select-methods'.

  Hopefully, almost everything (see the TODO section in `nndiary.el')
will work as expected when you restart Gnus: in autonomous mode,
typing `g' and `M-g' in the group buffer, will also get your new diary
mails and split them according to your diary-specific rules, `F' will
find your new diary groups etc.



File: gnus, Node: Customizing NNDiary, Prev: Running NNDiary, Up: The NNDiary Back End

Customizing NNDiary
...................

Now that `nndiary' is up and running, it's time to customize it.  The
custom group is called `nndiary' (no, really ?!).  You should browse
it to figure out which options you'd like to tweak.  The following two
variables are probably the only ones you will want to change:

 -- Variable: nndiary-reminders
     This is the list of times when you want to be reminded of your
     appointments (e.g. 3 weeks before, then 2 days before, then 1
     hour before and that's it).  Remember that "being reminded" means
     that the diary message will pop up as brand new and unread again
     when you get new mail.

 -- Variable: nndiary-week-starts-on-monday
     Rather self-explanatory.  Otherwise, Sunday is assumed (this is
     the default).




File: gnus, Node: The Gnus Diary Library, Next: Sending or Not Sending, Prev: The NNDiary Back End, Up: Email Based Diary

The Gnus Diary Library
----------------------

Using `nndiary' manually (I mean, writing the headers by hand and so
on) would be rather boring.  Fortunately, there is a library called
`gnus-diary' written on top of `nndiary', that does many useful things
for you.

  In order to use it, add the following line to your `~/.gnus.el'
file:

     (require 'gnus-diary)

  Also, you shouldn't use any `gnus-user-format-function-[d|D]' (*Note
Summary Buffer Lines::).  `gnus-diary' provides both of these (sorry
if you used them before).


* Menu:

* Diary Summary Line Format::           A nicer summary buffer line format.
* Diary Articles Sorting::              A nicer way to sort messages.
* Diary Headers Generation::            Not doing it manually.
* Diary Group Parameters::              Not handling them manually.



File: gnus, Node: Diary Summary Line Format, Next: Diary Articles Sorting, Prev: The Gnus Diary Library, Up: The Gnus Diary Library

Diary Summary Line Format
.........................

Displaying diary messages in standard summary line format (usually
something like `From Joe: Subject') is pretty useless.  Most of the
time, you're the one who wrote the message, and you mostly want to see
the event's date.

  `gnus-diary' provides two supplemental user formats to be used in
summary line formats.  `D' corresponds to a formatted time string for
the next occurrence of the event (e.g. "Sat, Sep 22 01, 12:00"), while
`d' corresponds to an approximative remaining time until the next
occurrence of the event (e.g. "in 6 months, 1 week").

  For example, here's how Joe's birthday is displayed in my
`nndiary+diary:birthdays' summary buffer (note that the message is
expirable, but will never be deleted, as it specifies a periodic
event):

        E  Sat, Sep 22 01, 12:00: Joe's birthday (in 6 months, 1 week)

In order to get something like the above, you would normally add the
following line to your diary groups'parameters:

     (gnus-summary-line-format "%U%R%z %uD: %(%s%) (%ud)\n")

However, `gnus-diary' does it automatically (*Note Diary Group
Parameters::).  You can however customize the provided summary line
format with the following user options:

 -- Variable: gnus-diary-summary-line-format
     Defines the summary line format used for diary groups (*Note
     Summary Buffer Lines::).  `gnus-diary' uses it to automatically
     update the diary groups'parameters.

 -- Variable: gnus-diary-time-format
     Defines the format to display dates in diary summary buffers.
     This is used by the `D' user format.  See the docstring for
     details.

 -- Variable: gnus-diary-delay-format-function
     Defines the format function to use for displaying delays
     (remaining times) in diary summary buffers.  This is used by the
     `d' user format.  There are currently built-in functions for
     English and French; you can also define your own.  See the
     docstring for details.



File: gnus, Node: Diary Articles Sorting, Next: Diary Headers Generation, Prev: Diary Summary Line Format, Up: The Gnus Diary Library

Diary Articles Sorting
......................

`gnus-diary' provides new sorting functions (*Note Sorting the Summary
Buffer:: ) called `gnus-summary-sort-by-schedule',
`gnus-thread-sort-by-schedule' and `gnus-article-sort-by-schedule'.
These functions let you organize your diary summary buffers from the
closest event to the farthest one.

`gnus-diary' automatically installs `gnus-summary-sort-by-schedule' as
a menu item in the summary buffer's "sort" menu, and the two others as
the primary (hence default) sorting functions in the group parameters
(*Note Diary Group Parameters::).



File: gnus, Node: Diary Headers Generation, Next: Diary Group Parameters, Prev: Diary Articles Sorting, Up: The Gnus Diary Library

Diary Headers Generation
........................

`gnus-diary' provides a function called `gnus-diary-check-message' to
help you handle the `X-Diary-*' headers.  This function ensures that
the current message contains all the required diary headers, and
prompts you for values or corrections if needed.

  This function is hooked into the `nndiary' back end, so that moving
or copying an article to a diary group will trigger it automatically.
It is also bound to `C-c C-f d' in `message-mode' and
`article-edit-mode' in order to ease the process of converting a usual
mail to a diary one.

  This function takes a prefix argument which will force prompting of
all diary headers, regardless of their presence or validity.  That
way, you can very easily reschedule an already valid diary message,
for instance.



File: gnus, Node: Diary Group Parameters, Prev: Diary Headers Generation, Up: The Gnus Diary Library

Diary Group Parameters
......................

When you create a new diary group, or visit one, `gnus-diary'
automatically checks your group parameters and if needed, sets the
summary line format to the diary-specific value, installs the
diary-specific sorting functions, and also adds the different
`X-Diary-*' headers to the group's posting-style.  It is then easier
to send a diary message, because if you use `C-u a' or `C-u m' on a
diary group to prepare a message, these headers will be inserted
automatically (although not filled with proper values yet).



File: gnus, Node: Sending or Not Sending, Prev: The Gnus Diary Library, Up: Email Based Diary

Sending or Not Sending
----------------------

Well, assuming you've read all of the above, here are two final notes
on mail sending with `nndiary':

   * `nndiary' is a *real* mail back end.  You really send real diary
     messsages for real.  This means for instance that you can give
     appointments to anybody (provided they use Gnus and `nndiary') by
     sending the diary message to them as well.
   * However, since `nndiary' also has a `request-post' method, you
     can also use `C-u a' instead of `C-u m' on a diary group and the
     message won't actually be sent; just stored locally in the
     group. This comes in very handy for private appointments.



File: gnus, Node: Gnus Unplugged, Prev: Email Based Diary, Up: Select Methods

Gnus Unplugged
==============

In olden times (ca. February '88), people used to run their
newsreaders on big machines with permanent connections to the net.
News transport was dealt with by news servers, and all the newsreaders
had to do was to read news.  Believe it or not.

Nowadays most people read news and mail at home, and use some sort of
modem to connect to the net.  To avoid running up huge phone bills, it
would be nice to have a way to slurp down all the news and mail, hang
up the phone, read for several hours, and then upload any responses
you have to make.  And then you repeat the procedure.

Of course, you can use news servers for doing this as well.  I've used
`inn' together with `slurp', `pop' and `sendmail' for some years, but
doing that's a bore.  Moving the news server functionality up to the
newsreader makes sense if you're the only person reading news on a
machine.

Setting up Gnus as an "offline" newsreader is quite simple.  In fact,
you don't have to configure anything as the agent is now enabled by
default (*Note gnus-agent: Agent Variables.).

Of course, to use it as such, you have to learn a few new commands.

* Menu:

* Agent Basics::                How it all is supposed to work.
* Agent Categories::            How to tell the Gnus Agent what to download.
* Agent Commands::              New commands for all the buffers.
* Agent Visuals::               Ways that the agent may effect your summary buffer.
* Agent as Cache::              The Agent is a big cache too.
* Agent Expiry::                How to make old articles go away.
* Agent Regeneration::          How to recover from lost connections and other accidents.
* Agent and flags::             How the Agent maintains flags.
* Agent and IMAP::              How to use the Agent with IMAP.
* Outgoing Messages::           What happens when you post/mail something?
* Agent Variables::             Customizing is fun.
* Example Setup::               An example `~/.gnus.el' file for offline people.
* Batching Agents::             How to fetch news from a `cron' job.
* Agent Caveats::               What you think it'll do and what it does.




File: gnus, Node: Agent Basics, Next: Agent Categories, Prev: Gnus Unplugged, Up: Gnus Unplugged

Agent Basics
------------

First, let's get some terminology out of the way.

The Gnus Agent is said to be "unplugged" when you have severed the
connection to the net (and notified the Agent that this is the case).
When the connection to the net is up again (and Gnus knows this), the
Agent is "plugged".

The "local" machine is the one you're running on, and which isn't
connected to the net continuously.

"Downloading" means fetching things from the net to your local
machine.  "Uploading" is doing the opposite.

You know that Gnus gives you all the opportunity you'd ever want for
shooting yourself in the foot.  Some people call it flexibility.  Gnus
is also customizable to a great extent, which means that the user has
a say on how Gnus behaves.  Other newsreaders might unconditionally
shoot you in your foot, but with Gnus, you have a choice!

Gnus is never really in plugged or unplugged state.  Rather, it
applies that state to each server individually.  This means that some
servers can be plugged while others can be unplugged.  Additionally,
some servers can be ignored by the Agent altogether (which means that
they're kinda like plugged always).

So when you unplug the Agent and then wonder why is Gnus opening a
connection to the Net, the next step to do is to look whether all
servers are agentized.  If there is an unagentized server, you found
the culprit.

Another thing is the "offline" state.  Sometimes, servers aren't
reachable.  When Gnus notices this, it asks you whether you want the
server to be switched to offline state.  If you say yes, then the
server will behave somewhat as if it was unplugged, except that Gnus
will ask you whether you want to switch it back online again.

Let's take a typical Gnus session using the Agent.


   * You start Gnus with `gnus-unplugged'.  This brings up the Gnus
     Agent in a disconnected state.  You can read all the news that
     you have already fetched while in this mode.

   * You then decide to see whether any new news has arrived.  You
     connect your machine to the net (using PPP or whatever), and then
     hit `J j' to make Gnus become "plugged" and use `g' to check for
     new mail as usual.  To check for new mail in unplugged mode
     (*Note Mail Source Specifiers::).

   * You can then read the new news immediately, or you can download
     the news onto your local machine.  If you want to do the latter,
     you press `g' to check if there are any new news and then `J s'
     to fetch all the eligible articles in all the groups.  (To let
     Gnus know which articles you want to download, *Note Agent
     Categories::).

   * After fetching the articles, you press `J j' to make Gnus become
     unplugged again, and you shut down the PPP thing (or whatever).
     And then you read the news offline.

   * And then you go to step 2.

Here are some things you should do the first time (or so) that you use
the Agent.


   * Decide which servers should be covered by the Agent.  If you have a mail
     back end, it would probably be nonsensical to have it covered by the
     Agent.  Go to the server buffer (`^' in the group buffer) and press
     `J a' on the server (or servers) that you wish to have covered by the
     Agent (*Note Server Agent Commands::), or `J r' on automatically
     added servers you do not wish to have covered by the Agent.  By default,
     all `nntp' and `nnimap' servers in `gnus-select-method' and
     `gnus-secondary-select-methods' are agentized.

   * Decide on download policy.  It's fairly simple once you decide
     whether you are going to use agent categories, topic parameters,
     and/or group parameters to implement your policy.  If you're new
     to gnus, it is probably best to start with a category, *Note
     Agent Categories::.

     Both topic parameters (*Note Topic Parameters::) and agent
     categories (*Note Agent Categories::) provide for setting a
     policy that applies to multiple groups.  Which you use is
     entirely up to you.  Topic parameters do override categories so,
     if you mix the two, you'll have to take that into account.  If
     you have a few groups that deviate from your policy, you can use
     group parameters (*Note Group Parameters::) to configure them.

   * Uhm... that's it.




File: gnus, Node: Agent Categories, Next: Agent Commands, Prev: Agent Basics, Up: Gnus Unplugged

Agent Categories
----------------

One of the main reasons to integrate the news transport layer into the
newsreader is to allow greater control over what articles to download.
There's not much point in downloading huge amounts of articles, just
to find out that you're not interested in reading any of them.  It's
better to be somewhat more conservative in choosing what to download,
and then mark the articles for downloading manually if it should turn
out that you're interested in the articles anyway.

One of the more effective methods for controlling what is to be
downloaded is to create a "category" and then assign some (or all)
groups to this category.  Groups that do not belong in any other
category belong to the `default' category.  Gnus has its own buffer
for creating and managing categories.

If you prefer, you can also use group parameters (*Note Group
Parameters::) and topic parameters (*Note Topic Parameters::) for an
alternative approach to controlling the agent.  The only real
difference is that categories are specific to the agent (so there is
less to learn) while group and topic parameters include the kitchen
sink.

Since you can set agent parameters in several different places we have
a rule to decide which source to believe.  This rule specifies that
the parameter sources are checked in the following order: group
parameters, topic parameters, agent category, and finally customizable
variables.  So you can mix all of these sources to produce a wide
range of behavior, just don't blame me if you don't remember where you
put your settings.

* Menu:

* Category Syntax::             What a category looks like.
* Category Buffer::             A buffer for maintaining categories.
* Category Variables::          Customize'r'Us.




File: gnus, Node: Category Syntax, Next: Category Buffer, Prev: Agent Categories, Up: Agent Categories

Category Syntax
...............

A category consists of a name, the list of groups belonging to the
category, and a number of optional parameters that override the
customizable variables.  The complete list of agent parameters are
listed below.

`agent-groups'
     The list of groups that are in this category.

`agent-predicate'
     A predicate which (generally) gives a rough outline of which
     articles are eligible for downloading; and

`agent-score'
     a score rule which (generally) gives you a finer granularity when
     deciding what articles to download.  (Note that this "download
     score" is not necessarily related to normal scores.)

`agent-enable-expiration'
     a boolean indicating whether the agent should expire old articles
     in this group.  Most groups should be expired to conserve disk
     space.  In fact, its probably safe to say that the gnus.*
     hierarchy contains the only groups that should not be expired.

`agent-days-until-old'
     an integer indicating the number of days that the agent should
     wait before deciding that a read article is safe to expire.

`agent-low-score'
     an integer that overrides the value of `gnus-agent-low-score'.

`agent-high-score'
     an integer that overrides the value of `gnus-agent-high-score'.

`agent-short-article'
     an integer that overrides the value of
     `gnus-agent-short-article'.

`agent-long-article'
     an integer that overrides the value of `gnus-agent-long-article'.

`agent-enable-undownloaded-faces'
     a symbol indicating whether the summary buffer should display
     undownloaded articles using the
     `gnus-summary-*-undownloaded-face' faces.  Any symbol other than
     `nil' will enable the use of undownloaded faces.

The name of a category can not be changed once the category has been
created.

Each category maintains a list of groups that are exclusive members of
that category.  The exclusivity rule is automatically enforced, add a
group to a new category and it is automatically removed from its old
category.

A predicate in its simplest form can be a single predicate such as
`true' or `false'.  These two will download every available article or
nothing respectively.  In the case of these two special predicates an
additional score rule is superfluous.

Predicates of `high' or `low' download articles in respect of
their scores in relationship to `gnus-agent-high-score' and
`gnus-agent-low-score' as described below.

To gain even finer control of what is to be regarded eligible for
download a predicate can consist of a number of predicates with
logical operators sprinkled in between.

Perhaps some examples are in order.

Here's a simple predicate.  (It's the default predicate, in fact, used
for all groups that don't belong to any other category.)

     short

Quite simple, eh?  This predicate is true if and only if the article
is short (for some value of "short").

Here's a more complex predicate:

     (or high
         (and
          (not low)
          (not long)))

This means that an article should be downloaded if it has a high
score, or if the score is not low and the article is not long.  You
get the drift.

The available logical operators are `or', `and' and
`not'.  (If you prefer, you can use the more "C"-ish operators
`|', `&' and `!' instead.)

The following predicates are pre-defined, but if none of these fit
what you want to do, you can write your own.

When evaluating each of these predicates, the named constant will be
bound to the value determined by calling `gnus-agent-find-parameter'
on the appropriate parameter.  For example, gnus-agent-short-article
will be bound to `(gnus-agent-find-parameter group
'agent-short-article)'.  This means that you can specify a predicate
in your category then tune that predicate to individual groups.

`short'
     True if the article is shorter than `gnus-agent-short-article'
     lines; default 100.

`long'
     True if the article is longer than `gnus-agent-long-article'
     lines; default 200.

`low'
     True if the article has a download score less than
     `gnus-agent-low-score'; default 0.

`high'
     True if the article has a download score greater than
     `gnus-agent-high-score'; default 0.

`spam'
     True if the Gnus Agent guesses that the article is spam.  The
     heuristics may change over time, but at present it just computes
     a checksum and sees whether articles match.

`true'
     Always true.

`false'
     Always false.

If you want to create your own predicate function, here's what you
have to know: The functions are called with no parameters, but the
`gnus-headers' and `gnus-score' dynamic variables are bound to useful
values.

For example, you could decide that you don't want to download articles
that were posted more than a certain number of days ago (e.g. posted
more than `gnus-agent-expire-days' ago) you might write a function
something along the lines of the following:

     (defun my-article-old-p ()
       "Say whether an article is old."
       (< (time-to-days (date-to-time (mail-header-date gnus-headers)))
          (- (time-to-days (current-time)) gnus-agent-expire-days)))

with the predicate then defined as:

     (not my-article-old-p)

or you could append your predicate to the predefined
`gnus-category-predicate-alist' in your `~/.gnus.el' or wherever.

     (require 'gnus-agent)
     (setq  gnus-category-predicate-alist
       (append gnus-category-predicate-alist
              '((old . my-article-old-p))))

and simply specify your predicate as:

     (not old)

If/when using something like the above, be aware that there are many
misconfigured systems/mailers out there and so an article's date is
not always a reliable indication of when it was posted.  Hell, some
people just don't give a damn.

The above predicates apply to *all* the groups which belong to the
category.  However, if you wish to have a specific predicate for an
individual group within a category, or you're just too lazy to set up
a new category, you can enter a group's individual predicate in its
group parameters like so:

     (agent-predicate . short)

This is the group/topic parameter equivalent of the agent category default.
Note that when specifying a single word predicate like this, the
`agent-predicate' specification must be in dotted pair notation.

The equivalent of the longer example from above would be:

     (agent-predicate or high (and (not low) (not long)))

The outer parenthesis required in the category specification are not
entered here as, not being in dotted pair notation, the value of the
predicate is assumed to be a list.


Now, the syntax of the download score is the same as the syntax of
normal score files, except that all elements that require actually
seeing the article itself are verboten.  This means that only the
following headers can be scored on: `Subject', `From',
`Date', `Message-ID', `References', `Chars',
`Lines', and `Xref'.

As with predicates, the specification of the `download score rule' to
use in respect of a group can be in either the category definition if
it's to be applicable to all groups in therein, or a group's
parameters if it's to be specific to that group.

In both of these places the `download score rule' can take one of
three forms:

  1. Score rule

     This has the same syntax as a normal Gnus score file except only
     a subset of scoring keywords are available as mentioned above.

     example:

        * Category specification

               (("from"
                      ("Lars Ingebrigtsen" 1000000 nil s))
               ("lines"
                      (500 -100 nil <)))

        * Group/Topic Parameter specification

               (agent-score ("from"
                                  ("Lars Ingebrigtsen" 1000000 nil s))
                            ("lines"
                                  (500 -100 nil <)))

          Again, note the omission of the outermost parenthesis here.

  2. Agent score file

     These score files must *only* contain the permitted scoring
     keywords stated above.

     example:

        * Category specification

               ("~/News/agent.SCORE")

          or perhaps

               ("~/News/agent.SCORE" "~/News/agent.group.SCORE")

        * Group Parameter specification

               (agent-score "~/News/agent.SCORE")

          Additional score files can be specified as above.  Need I
          say anything about parenthesis?

  3. Use `normal' score files

     If you don't want to maintain two sets of scoring rules for a group, and
     your desired `downloading' criteria for a group are the same as your
     `reading' criteria then you can tell the agent to refer to your
     `normal' score files when deciding what to download.

     These directives in either the category definition or a group's
     parameters will cause the agent to read in all the applicable
     score files for a group, *filtering out* those sections that do
     not relate to one of the permitted subset of scoring keywords.

        * Category Specification

               file

        * Group Parameter specification

               (agent-score . file)



